<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drabinki Przemys≈Çowe - Wizualizacja 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
        }
        #container {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 100;
            max-width: 250px;
        }
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
        }
        .btn {
            display: block;
            width: 50px;
            height: 50px;
            margin-bottom: 10px;
            background: rgba(0, 200, 100, 0.9);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active {
            transform: scale(0.95);
            background: rgba(0, 255, 120, 1);
        }
        .btn-remove {
            background: rgba(200, 50, 50, 0.9);
        }
        .btn-remove:active {
            background: rgba(255, 70, 70, 1);
        }
        .btn-tech {
            background: rgba(50, 100, 200, 0.9);
            font-size: 18px;
        }
        .btn-tech:active {
            background: rgba(70, 120, 255, 1);
        }
        #ladderSelector {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 100;
        }
        #ladderSelector select {
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }
        #techDrawing {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 200;
            display: none;
        }
        #connectionPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            z-index: 300;
            display: none;
            color: white;
            font-size: 14px;
            min-width: 300px;
        }
        #connectionPanel.active {
            display: block;
        }
        #connectionPanel h3 {
            margin: 0 0 20px 0;
            text-align: center;
            color: #4CAF50;
        }
        .connection-row {
            margin: 10px 0;
        }
        .connection-row label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
        }
        .connection-types {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .connection-type-btn {
            padding: 12px 25px;
            background: #333;
            color: white;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .connection-type-btn:hover {
            background: #444;
        }
        .connection-type-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        .wspornik-row {
            margin: 15px 0;
        }
        .wspornik-row label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
        }
        .wspornik-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 4px;
            outline: none;
        }
        .wspornik-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        #wspornikGlobalSlider1::-webkit-slider-thumb,
        #wspornikGlobalSlider2::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        #wspornikGlobalSlider2::-webkit-slider-thumb {
            background: #2196F3;
        }
        .wspornik-value {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
            color: #4CAF50;
        }
        .wspornik-types {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .wspornik-type-btn {
            padding: 10px 15px;
            background: #333;
            color: white;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }
        .wspornik-type-btn:hover {
            background: #444;
        }
        .wspornik-type-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        #connectionPanel button.close-btn {
            width: 100%;
            margin-top: 20px;
            padding: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
        }
        #connectionPanel button.close-btn:hover {
            background: #444;
        }
        .rotation-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        .rotation-row label {
            width: 50px;
        }
        .rotation-btn {
            width: 40px;
            height: 40px;
            background: rgba(50, 100, 200, 0.9);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
        }
        .rotation-btn:hover {
            background: rgba(70, 120, 255, 1);
        }
        #closeRotation {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            background: rgba(200, 50, 50, 0.9);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #techDrawing.active {
            display: block;
        }
        #closeDrawing {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: rgba(200, 50, 50, 0.9);
            color: white;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 201;
            display: none;
        }
        #closeDrawing.active {
            display: block;
        }
        #switchView {
            position: fixed;
            top: 70px;
            right: 10px;
            width: 120px;
            height: 50px;
            background: rgba(50, 100, 200, 0.9);
            color: white;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            z-index: 201;
            display: none;
        }
        #switchView.active {
            display: block;
        }
        #status {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: lime;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            z-index: 100;
            font-weight: bold;
        }
        .connector-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            color: white;
        }
        .connector-item:last-child {
            border-bottom: none;
        }
        .connector-item select {
            padding: 5px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid white;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        /* Responsive styles for mobile */
        @media (max-width: 480px) {
            #ladderSelector {
                left: 10px !important;
                max-width: calc(100vw - 20px);
            }
            #laddersContainer {
                flex-direction: column !important;
            }
            #ladder1Panel, #ladder2Panel {
                min-width: 100% !important;
                max-width: 100% !important;
            }
            #controls {
                flex-direction: row !important;
                flex-wrap: wrap !important;
                justify-content: center !important;
                gap: 5px !important;
            }
            #controls .btn {
                margin-bottom: 3px !important;
            }
            #atticControlsTop {
                right: 5px !important;
                top: 5px !important;
            }
            #atticControlsTop .btn {
                padding: 6px !important;
                font-size: 11px !important;
            }
            #togglePanelsBtn {
                padding: 6px 10px !important;
                font-size: 14px !important;
            }
            #info {
                max-width: 200px !important;
                font-size: 11px !important;
                padding: 8px !important;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <button id="closeInfo" style="position: absolute; top: 3px; right: 5px; background: none; border: none; color: white; font-size: 14px; cursor: pointer; opacity: 0.7;">&times;</button>
        <strong>Drabinka przemys≈Çowa</strong><br>
        Telefon:<br>
        - 1 palec: obrot<br>
        - 2 palce: zoom + przesuwanie<br>
        Komputer:<br>
        - mysz: obrot<br>
        - Shift+mysz: przesuwanie<br>
        - scroll: zoom
    </div>
    <!-- Standardowe kontrolki (bez attyki) -->
    <div id="controls">
        <button class="btn" id="add7Btn" title="Dodaj drabinƒô x7 (1922mm)">+7</button>
        <button class="btn btn-remove" id="remove7Btn" title="Usu≈Ñ drabinƒô x7 (1922mm)">-7</button>
        <button class="btn btn-tech" id="techBtn" title="Rysunek techniczny">üìê</button>
        <button class="btn btn-tech" id="measureBtn" title="Miarka - kliknij 2 punkty">üìè</button>
        <button class="btn btn-tech" id="sciskaneBtn" title="Uchwyty ≈õciskane - kliknij aby dodaƒá">üîß</button>
    </div>
    <div id="measureResult" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: lime; padding: 20px; border-radius: 10px; border: 2px solid lime; font-size: 24px; font-weight: bold; display: none; z-index: 300;"></div>
    <!-- Przycisk oczka do chowania/pokazywania paneli -->
    <button id="togglePanelsBtn" title="Poka≈º/ukryj panele" style="position: fixed; bottom: 10px; left: 10px; z-index: 101; background: rgba(0,0,0,0.85); border: 2px solid white; border-radius: 8px; padding: 8px 12px; color: white; font-size: 16px; cursor: pointer;">üëÅ‚Äçüó®</button>

    <!-- Zunifikowany panel dolny lewy -->
    <div id="ladderSelector">
        <div id="laddersContainer" style="display: flex; flex-wrap: wrap; gap: 8px;">
            <!-- Panel Drabiny 1 (zawsze widoczny) -->
            <div id="ladder1Panel" style="background: rgba(0,0,0,0.85); padding: 10px; border-radius: 8px; border: 2px solid #4CAF50; min-width: 130px;">
                <div id="ladder1Title" style="color: #4CAF50; font-weight: bold; text-align: center; margin-bottom: 5px; font-size: 12px; display: none;">Drabina 1</div>
                <select id="ladderSelect" style="width: 100%; padding: 6px; background: #222; color: white; border: 1px solid #4CAF50; border-radius: 4px; font-size: 12px; margin-bottom: 5px;">
                    <option value="0">Brak ko≈Ñcowej</option>
                    <option value="1">x1 (175mm)</option>
                    <option value="2">x2 (450mm)</option>
                    <option value="3">x3 (725mm)</option>
                    <option value="4">x4 (1000mm)</option>
                    <option value="5">x5 (1275mm)</option>
                    <option value="6">x6 (1550mm)</option>
                    <option value="7alt">x7 ALT (1825mm)</option>
                </select>
                <div id="connectorList" style="max-height: 150px; overflow-y: auto; font-size: 11px;"></div>
                <div style="margin-top: 5px;">
                    <label style="color: #4CAF50; font-size: 10px; display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="wspornikDisable1" style="margin: 0;">
                        Brak wspornik√≥w
                    </label>
                    <div id="wspornikSliderContainer1" style="margin-top: 5px;">
                        <label style="color: #4CAF50; font-size: 10px;">Odleg≈Ço≈õƒá: <span id="wspornikGlobalValue1">21</span>cm (<span id="wspornikGlobalType1">kr√≥tki</span>)</label>
                        <input type="range" id="wspornikGlobalSlider1" min="160" max="460" value="215" style="width: 100%; height: 6px; -webkit-appearance: none; background: #333; border-radius: 3px; outline: none;">
                    </div>
                </div>
            </div>
            <!-- Panel Drabiny 2 (widoczny tylko w trybie attyki) -->
            <div id="ladder2Panel" style="display: none; background: rgba(0,0,0,0.85); padding: 10px; border-radius: 8px; border: 2px solid #2196F3; min-width: 130px;">
                <div style="color: #2196F3; font-weight: bold; text-align: center; margin-bottom: 5px; font-size: 12px;">Drabina 2</div>
                <select id="ladderSelect2" style="width: 100%; padding: 6px; background: #222; color: white; border: 1px solid #2196F3; border-radius: 4px; font-size: 12px; margin-bottom: 5px;">
                    <option value="0">Brak ko≈Ñcowej</option>
                    <option value="1">x1 (175mm)</option>
                    <option value="2">x2 (450mm)</option>
                    <option value="3">x3 (725mm)</option>
                    <option value="4">x4 (1000mm)</option>
                    <option value="5">x5 (1275mm)</option>
                    <option value="6">x6 (1550mm)</option>
                    <option value="7alt">x7 ALT (1825mm)</option>
                </select>
                <div id="connectorList2" style="max-height: 150px; overflow-y: auto; font-size: 11px;"></div>
                <div style="margin-top: 5px;">
                    <label style="color: #2196F3; font-size: 10px; display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="wspornikDisable2" style="margin: 0;">
                        Brak wspornik√≥w
                    </label>
                    <div id="wspornikSliderContainer2" style="margin-top: 5px;">
                        <label style="color: #2196F3; font-size: 10px;">Odleg≈Ço≈õƒá: <span id="wspornikGlobalValue2">21</span>cm (<span id="wspornikGlobalType2">kr√≥tki</span>)</label>
                        <input type="range" id="wspornikGlobalSlider2" min="160" max="460" value="215" style="width: 100%; height: 6px; -webkit-appearance: none; background: #333; border-radius: 3px; outline: none;">
                    </div>
                </div>
            </div>
        </div>
        <!-- Wyb√≥r porƒôczy - zawsze na dole -->
        <div style="margin-top: 8px;">
            <select id="handrailSelect" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.85); color: white; border: 2px solid white; border-radius: 6px; font-size: 13px; font-weight: bold; cursor: pointer;">
                <option value="none">Brak porƒôczy</option>
                <option value="safety">Porƒôcze asekuracyjne</option>
                <option value="platform">Porƒôcze z podestem</option>
                <option value="attic">Przej≈õcie przez attykƒô</option>
            </select>
        </div>
        <!-- Kosz ochronny - przyciski dla ka≈ºdej drabiny -->
        <div id="safetyCageControls" style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 5px;">
            <div id="safetyCage1" style="background: rgba(0,0,0,0.7); padding: 5px 8px; border-radius: 5px; border: 1px solid #4CAF50;">
                <span style="color: #4CAF50; font-size: 11px;">Kosz D1:</span>
                <button id="addCage1" style="background: #4CAF50; color: white; border: none; border-radius: 3px; padding: 2px 8px; cursor: pointer; font-weight: bold;">+1</button>
                <span id="cageCount1" style="color: white; font-size: 12px; margin: 0 3px;">0/0</span>
                <button id="removeCage1" style="background: #f44336; color: white; border: none; border-radius: 3px; padding: 2px 8px; cursor: pointer; font-weight: bold;">-1</button>
            </div>
            <div id="safetyCage2" style="display: none; background: rgba(0,0,0,0.7); padding: 5px 8px; border-radius: 5px; border: 1px solid #2196F3;">
                <span style="color: #2196F3; font-size: 11px;">Kosz D2:</span>
                <button id="addCage2" style="background: #2196F3; color: white; border: none; border-radius: 3px; padding: 2px 8px; cursor: pointer; font-weight: bold;">+1</button>
                <span id="cageCount2" style="color: white; font-size: 12px; margin: 0 3px;">0/0</span>
                <button id="removeCage2" style="background: #f44336; color: white; border: none; border-radius: 3px; padding: 2px 8px; cursor: pointer; font-weight: bold;">-1</button>
            </div>
        </div>
        <!-- Wyb√≥r koloru modeli i tekstury -->
        <div style="margin-top: 8px; display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.7); padding: 5px 8px; border-radius: 5px;">
            <span style="color: white; font-size: 11px;">Kolor:</span>
            <input type="color" id="modelColorPicker" value="#707389" style="width: 40px; height: 25px; border: none; border-radius: 3px; cursor: pointer;">
            <label style="color: white; font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                <input type="checkbox" id="textureToggle" checked style="cursor: pointer;">
                Ocynk
            </label>
        </div>
    </div>

    <!-- Kontrolki dla attyki - przyciski u g√≥ry (prawy g√≥rny r√≥g) -->
    <div id="atticControlsTop" style="display: none; position: fixed; top: 10px; right: 10px; z-index: 100;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px;">
            <button class="btn" id="add7Btn2" title="Dodaj x7 (Drabina 2)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">+7 <span style="font-size:9px;">D2</span></button>
            <button class="btn" id="add7Btn1" title="Dodaj x7 (Drabina 1)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">+7 <span style="font-size:9px;">D1</span></button>
            <button class="btn btn-remove" id="remove7Btn2" title="Usu≈Ñ x7 (Drabina 2)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">-7 <span style="font-size:9px;">D2</span></button>
            <button class="btn btn-remove" id="remove7Btn1" title="Usu≈Ñ x7 (Drabina 1)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">-7 <span style="font-size:9px;">D1</span></button>
            <div></div>
            <button class="btn btn-tech" id="techBtn2" title="Rysunek techniczny" style="margin-bottom: 0;">üìê</button>
            <div></div>
            <button class="btn btn-tech" id="measureBtn2" title="Miarka" style="margin-bottom: 0;">üìè</button>
            <div></div>
            <button class="btn btn-tech" id="sciskaneBtn2" title="Uchwyty ≈õciskane" style="margin-bottom: 0;">üîß</button>
        </div>
    </div>
    <div id="status">Ladowanie...</div>
    <div id="collisionWarning" style="display: none; position: fixed; top: 50px; left: 50%; transform: translateX(-50%); background: rgba(255, 152, 0, 0.95); color: #000; padding: 10px 20px; border-radius: 8px; font-weight: bold; z-index: 1000; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px solid #ff9800;">
        <span id="collisionWarningText"></span>
        <button id="collisionWarningClose" style="margin-left: 15px; background: #000; color: #ff9800; border: 1px solid #000; border-radius: 4px; padding: 2px 8px; cursor: pointer; font-weight: bold;">X</button>
    </div>

    <canvas id="techDrawing"></canvas>
    <button id="closeDrawing">‚úï</button>
    <button id="switchView">Widok z boku</button>

    <div id="connectionPanel">
        <h3>Ustawienia ≈ÇƒÖczenia</h3>
        <div class="connection-row">
            <label>Typ ≈ÇƒÖczenia:</label>
            <div class="connection-types">
                <button class="connection-type-btn" id="connTypeBtnUchwyt" onclick="setConnectionType('uchwyt')">Uchwyt</button>
                <button class="connection-type-btn" id="connTypeBtnLacznik" onclick="setConnectionType('lacznik')">≈ÅƒÖcznik</button>
                <button class="connection-type-btn" id="connTypeBtnSciskany" style="display: none;" onclick="setMidRungConnType('sciskany')">≈öciski</button>
            </div>
        </div>
        <div id="wspornikOptions" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
            <div class="wspornik-row">
                <label>Typ wspornika:</label>
                <div class="wspornik-types">
                    <button class="wspornik-type-btn" data-type="krotki" onclick="setWspornikTypeFromPanel('krotki')">Kr√≥tki</button>
                    <button class="wspornik-type-btn" data-type="sredni" onclick="setWspornikTypeFromPanel('sredni')">≈öredni</button>
                    <button class="wspornik-type-btn" data-type="dlugi" onclick="setWspornikTypeFromPanel('dlugi')">D≈Çugi</button>
                    <button class="wspornik-type-btn" data-type="none" onclick="setWspornikTypeFromPanel('none')">Brak</button>
                </div>
            </div>
            <div class="wspornik-row" id="wspornikSliderRow">
                <label>Odleg≈Ço≈õƒá od ≈õciany:</label>
                <input type="range" class="wspornik-slider" id="wspornikSlider" min="160" max="260" value="210" oninput="updateWspornikDistance(this.value)">
                <div class="wspornik-value"><span id="wspornikDistanceValue">21</span> cm</div>
            </div>
        </div>
        <button id="midRungRemoveBtn" class="close-btn" style="display: none; background: #c33; margin-bottom: 10px;" onclick="removeMidRungBracket()">Usu≈Ñ uchwyt</button>
        <button class="close-btn" onclick="closeConnectionPanel()">Zamknij</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script>
        var statusDiv = document.getElementById('status');
        
        // Wymiary w mm (dla ≈Çatwiejszych oblicze≈Ñ, skalujemy p√≥≈∫niej do m)
        var DIMS = {
            rungWidth: 30,        // 30mm x 30mm
            rungHeight: 30,
            rungLength: 500,      // 500mm d≈Çugo≈õƒá szczebla
            railWidth: 50,        // 50mm profil pod≈Çu≈ºnicy (szeroko≈õƒá)
            railDepth: 30,        // 30mm profil pod≈Çu≈ºnicy (g≈Çƒôboko≈õƒá)
            firstRungFromTop: 130, // 130mm (13cm) od g√≥ry do pierwszego szczebla
            rungSpacing: 275,     // 275mm rozstaw miƒôdzy szczebami (g√≥ra do g√≥ra)
            
            // Porƒôcze asekuracyjne (odwr√≥cona litera L)
            handrailVertical: 1011,   // 1011mm przed≈Çu≈ºenie pionowe
            handrailHorizontal: 540,  // 540mm ramiƒô poziome
            handrailWidth: 30,        // 30mm szeroko≈õƒá profilu
            
            // Przej≈õcie przez attykƒô
            atticRailHeight: 1650,    // 1650mm wysoko≈õƒá pod≈Çu≈ºnic od ≈ÇƒÖczenia do g√≥ry
            atticRungs: 2,            // 2 dodatkowe szczeble
            
            // Ceownik ≈ÇƒÖczƒÖcy drabiny x7 (kszta≈Çt [)
            connectorHeight: 100,     // 100mm (10cm) wysoko≈õƒá ceownika
            connectorBackWidth: 56,   // 56mm tylna ≈õcianka (50mm + 6mm rozszerzenie)
            connectorArmDepth: 30,    // 30mm ramiona boczne (wƒÖskie)
            connectorThickness: 3,    // 3mm grubo≈õƒá ≈õcian ceownika
            
            // Wymiary ca≈Çkowite pod≈Çu≈ºnic dla r√≥≈ºnych ilo≈õci szczebli
            railHeights: {
                1: 175,
                2: 450,
                3: 725,
                4: 1000,
                5: 1275,
                6: 1550,
                7: 1922,
                '7alt': 1825  // Alternatywna drabina x7
            }
        };
        
        // Przelicz mm na jednostki Three.js (1 jednostka = 100mm dla lepszej skali)
        var SCALE = 0.01; // 1mm = 0.01 jednostek
        
        // Konfiguracja drabin - osobna dla ka≈ºdej drabiny przy przej≈õciu przez attykƒô
        var currentLadder = 1;  // Aktualnie edytowana drabina (1 lub 2)

        // Drabina 1 (przednia)
        var numX7Ladders1 = 0;
        var finalLadderRungs1 = 0;
        var connectorTypes1 = [];
        var sciskaneHandles1 = [];
        var wspornikTypes1 = [];      // Typ wspornika per pozycja: 'none', 'krotki', 'sredni', 'dlugi'
        var wspornikTypesSaved1 = []; // Zapisany typ przed zmianƒÖ na ≈ÇƒÖcznik
        var wspornikDistances1 = [];  // Odleg≈Ço≈õƒá wspornika od ≈õciany w mm
        var defaultWspornik1 = 'krotki'; // Domy≈õlny typ wspornika dla nowych
        var globalWspornikDistance1 = 215; // Globalna odleg≈Ço≈õƒá wspornik√≥w w mm
        var wspornikDisabled1 = false; // Czy wsporniki wy≈ÇƒÖczone

        // Drabina 2 (tylna, 107cm do ty≈Çu, obr√≥cona 180¬∞)
        var numX7Ladders2 = 0;
        var finalLadderRungs2 = 0;
        var connectorTypes2 = [];
        var sciskaneHandles2 = [];
        var wspornikTypes2 = [];      // Typ wspornika per pozycja
        var wspornikTypesSaved2 = []; // Zapisany typ przed zmianƒÖ na ≈ÇƒÖcznik
        var wspornikDistances2 = [];  // Odleg≈Ço≈õƒá wspornika od ≈õciany w mm
        var defaultWspornik2 = 'krotki'; // Domy≈õlny typ wspornika dla nowych
        var globalWspornikDistance2 = 215; // Globalna odleg≈Ço≈õƒá wspornik√≥w w mm
        var wspornikDisabled2 = false; // Czy wsporniki wy≈ÇƒÖczone

        // Centralna konfiguracja geometrii dla ka≈ºdej drabiny
        var ladderGeometryConfig = {
            1: {
                zOffset: 0,
                rotationZ: 0,  // Obr√≥t ca≈Çej drabiny w osi Z
                // ≈ÅƒÖczniki/Uchwyty (uchwyt.obj)
                connector: {
                    left: { x: Math.PI * 0.5, y: Math.PI, z: 0 },   // X=90¬∞, Y=180¬∞
                    right: { x: Math.PI * 0.5, y: 0, z: 0 },        // X=90¬∞
                    zOffset: 0,           // ≈ÅƒÖczniki (lacznik)
                    uchwytZOffset: 0      // Uchwyty (uchwyt)
                },
                // Uchwyty ≈õciskane (sciskany.obj)
                sciskane: {
                    left: { x: Math.PI * 0.5, y: 0, z: Math.PI },   // Obr√≥cone o 180¬∞ w Y
                    right: { x: Math.PI * 0.5, y: Math.PI, z: Math.PI },
                    leftZOffset: -45,   // Offset Z lewego (+10mm do przodu)
                    rightZOffset: -45   // Offset Z prawego (+10mm do przodu)
                },
                // Wsporniki do mocowania do ≈õciany
                wspornik: {
                    left: { x: 0, y: 0, z: 0 },
                    right: { x: 0, y: Math.PI, z: 0 },
                    zOffset: -150   // Offset Z (za uchwytem)
                }
            },
            2: {
                zOffset: -1070,
                rotationZ: Math.PI,  // Obr√≥t 180¬∞ w osi Z
                // ≈ÅƒÖczniki/Uchwyty - osobne dla drabiny 2
                connector: {
                    left: { x: Math.PI * 1.5, y: Math.PI, z: 0 },   // 180¬∞ w d√≥≈Ç + 180¬∞ w bok
                    right: { x: Math.PI * 1.5, y: 0, z: 0 },        // 180¬∞ w d√≥≈Ç + 180¬∞ w bok
                    zOffset: 0,           // ≈ÅƒÖczniki (lacznik) na 0
                    uchwytZOffset: 124    // Uchwyty (uchwyt) +124mm
                },
                // Uchwyty ≈õciskane - osobne dla drabiny 2
                sciskane: {
                    left: { x: Math.PI * 0.5, y: Math.PI, z: 0 },   // Obr√≥cone o 180¬∞ w Y
                    right: { x: Math.PI * 0.5, y: 0, z: 0 },
                    leftZOffset: 44,    // -20mm
                    rightZOffset: 44    // -20mm
                },
                // Wsporniki - osobne dla drabiny 2
                wspornik: {
                    left: { x: 0, y: Math.PI, z: 0 },
                    right: { x: 0, y: 0, z: 0 },
                    zOffset: 150   // Offset Z (za uchwytem, odwr√≥cony)
                }
            }
        };

        // Aliasy do aktualnie edytowanej drabiny (dla kompatybilno≈õci)
        var numX7Ladders = 0;
        var finalLadderRungs = 0;
        var connectorTypes = [];
        var sciskaneHandles = [];

        var handrailType = 'none';  // Typ porƒôczy: 'none', 'safety', 'platform', 'attic'
        var useGalvanizedTexture = true;  // Czy u≈ºywaƒá tekstury ocynku
        var safetyCageCount1 = 0;  // Liczba obrƒôczy kosza ochronnego dla drabiny 1
        var safetyCageCount2 = 0;  // Liczba obrƒôczy kosza ochronnego dla drabiny 2
        var midRungBracket1 = true;  // Uchwyt miƒôdzy 2. a 3. szczeblem dla drabiny 1
        var midRungBracket2 = true;  // Uchwyt miƒôdzy 2. a 3. szczeblem dla drabiny 2
        var midRungBracketConnType1 = 'uchwyt';  // Typ ≈ÇƒÖcznika: 'uchwyt' lub 'sciskany'
        var midRungBracketConnType2 = 'uchwyt';
        var midRungBracketWspornikType1 = 'krotki';  // Typ wspornika dla uchwytu miƒôdzy szczebla
        var midRungBracketWspornikType2 = 'krotki';
        var midRungBracketDistance1 = 215;  // Odleg≈Ço≈õƒá wspornika
        var midRungBracketDistance2 = 215;
        var modelColor = 0x707389;  // Aktualny kolor modeli (112, 115, 137)
        var sciskaneMode = false;  // Tryb dodawania uchwyt√≥w ≈õciskanych
        var sciskanePreviewObjects = [];  // Obiekty podglƒÖdu
        var sciskanePlacedObjects = [];  // Umieszczone uchwyty ≈õciskane

        // Za≈Çadowane modele OBJ
        var loadedModels = {
            powielana: null,  // drabinapowielana.obj (x7 standardowa)
            koncowa: {},      // koncowa-x1.obj do koncowa-x7.obj
            uchwyt: null,     // uchwyt.obj
            lacznik: null,    // lacznik.obj
            porecz: null,     // porecz.obj
            uchwytPoreczy: null,  // uchwyt poreczy.obj
            attyka: null,     // przejscieprzezattyke.obj
            krataWema: null,  // krata wema.obj
            sciskany: null,   // uchwyt sciskany.obj
            obrecz: null,     // obrecz.obj (kosz ochronny)
            katownikX2: null, // katownik_x2.obj
            katownikX3: null, // katownik_x3.obj
            katownikX4: null, // katownik_x4.obj
            // Wsporniki do mocowania do ≈õciany
            wspornikKrotki: null,       // wspornik_krotki.obj (symetryczny)
            wspornikSredniLewy: null,   // wspornik_sredni_lewy.obj
            wspornikSredniPrawy: null,  // wspornik_sredni_prawy.obj
            wspornikDlugiLewy: null,    // wspornik_dlugi_lewy.obj
            wspornikDlugiPrawy: null,   // wspornik_dlugi_prawy.obj
            podestKrotki: null          // podest_krotki.obj
        };
        var modelsLoaded = false;

        // Typ ≈ÇƒÖcznika dla ka≈ºdego po≈ÇƒÖczenia (tablica: 'uchwyt' lub 'lacznik')
        var connectorTypes = [];

        // Funkcja ≈Çadowania wszystkich modeli OBJ
        // Tekstura ocynku z pliku JPG (modularna)
        var textureLoader = new THREE.TextureLoader();
        var galvanizedTexture = textureLoader.load('ocynk.jpg', function(texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(0.008, 0.008);
        });
        galvanizedTexture.wrapS = THREE.RepeatWrapping;
        galvanizedTexture.wrapT = THREE.RepeatWrapping;
        galvanizedTexture.repeat.set(0.008, 0.008);

        function loadAllModels(callback) {
            var loader = new THREE.OBJLoader();
            var modelsToLoad = 25; // 1 powielana + 7 ko≈Ñcowych + uchwyt + lacznik + porecz + uchwyt poreczy + attyka + krata wema + sciskany + obrecz + 3 kƒÖtowniki + 5 wspornik√≥w + podest
            var modelsLoadedCount = 0;

            // Materia≈Ç dla modeli - ocynkowany metal
            var modelMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.9,
                map: galvanizedTexture
            });

            function onModelLoaded() {
                modelsLoadedCount++;
                statusDiv.innerHTML = '≈Åadowanie modeli: ' + modelsLoadedCount + '/' + modelsToLoad;
                if (modelsLoadedCount === modelsToLoad) {
                    modelsLoaded = true;
                    callback();
                }
            }

            function applyMaterial(obj) {
                // Oblicz bounding box
                var box = new THREE.Box3().setFromObject(obj);
                var center = box.getCenter(new THREE.Vector3());
                var size = box.getSize(new THREE.Vector3());

                // Utw√≥rz kontener i przesu≈Ñ model do ≈õrodka
                var container = new THREE.Group();
                obj.position.set(-center.x, -center.y, -center.z);
                container.add(obj);

                // Zastosuj materia≈Ç
                obj.traverse(function(child) {
                    if (child.isMesh) {
                        child.material = modelMaterial.clone();
                    }
                });

                // Zapisz wymiary modelu
                container.userData.originalHeight = size.y;
                container.userData.originalWidth = size.x;
                container.userData.originalDepth = size.z;

                console.log('Model za≈Çadowany, wymiary (mm):', size.x.toFixed(0), 'x', size.y.toFixed(0), 'x', size.z.toFixed(0));

                return container;
            }

            // ≈Åaduj drabinapowielana.obj
            loader.load('drabinapowielana.obj', function(obj) {
                loadedModels.powielana = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania drabinapowielana.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj koncowa-x1.obj do koncowa-x7.obj
            for (var i = 1; i <= 7; i++) {
                (function(index) {
                    loader.load('koncowa-x' + index + '.obj', function(obj) {
                        loadedModels.koncowa[index] = applyMaterial(obj);
                        onModelLoaded();
                    }, undefined, function(err) {
                        console.error('B≈ÇƒÖd ≈Çadowania koncowa-x' + index + '.obj:', err);
                        onModelLoaded();
                    });
                })(i);
            }

            // ≈Åaduj bryla400.obj (zamiast uchwyt.obj)
            loader.load('bryla400.obj', function(obj) {
                loadedModels.uchwyt = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania bryla400.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj lacznik.obj
            loader.load('lacznik.obj', function(obj) {
                loadedModels.lacznik = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania lacznik.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj porecz.obj
            loader.load('porecz.obj', function(obj) {
                loadedModels.porecz = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania porecz.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj uchwyt poreczy.obj
            loader.load('uchwyt poreczy.obj', function(obj) {
                loadedModels.uchwytPoreczy = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania uchwyt poreczy.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj przejscieprzezattyke.obj
            loader.load('przejscieprzezattyke.obj', function(obj) {
                loadedModels.attyka = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania przejscieprzezattyke.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj krata wema.obj
            loader.load('krata wema.obj', function(obj) {
                loadedModels.krataWema = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania krata wema.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj uchwyt sciskany.obj
            loader.load('uchwyt sciskany.obj', function(obj) {
                loadedModels.sciskany = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania uchwyt sciskany.obj:', err);
                // Fallback - u≈ºyj zwyk≈Çego uchwytu je≈õli nie ma modelu ≈õciskanego
                onModelLoaded();
            });

            // ≈Åaduj obrecz.obj (kosz ochronny)
            loader.load('obrecz.obj', function(obj) {
                loadedModels.obrecz = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania obrecz.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj kƒÖtowniki
            loader.load('katownikx2.obj', function(obj) {
                loadedModels.katownikX2 = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania katownikx2.obj:', err);
                onModelLoaded();
            });

            loader.load('katownikx3.obj', function(obj) {
                loadedModels.katownikX3 = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania katownikx3.obj:', err);
                onModelLoaded();
            });

            loader.load('katownik_x4.obj', function(obj) {
                loadedModels.katownikX4 = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania katownik_x4.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj wsporniki
            loader.load('wspornik_krotki.obj', function(obj) {
                loadedModels.wspornikKrotki = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania wspornik_krotki.obj:', err);
                onModelLoaded();
            });

            loader.load('wspornik_sredni_lewy.obj', function(obj) {
                loadedModels.wspornikSredniLewy = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania wspornik_sredni_lewy.obj:', err);
                onModelLoaded();
            });

            loader.load('wspornik_sredni_prawy.obj', function(obj) {
                loadedModels.wspornikSredniPrawy = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania wspornik_sredni_prawy.obj:', err);
                onModelLoaded();
            });

            loader.load('wspornik_dlugi_lewy.obj', function(obj) {
                loadedModels.wspornikDlugiLewy = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania wspornik_dlugi_lewy.obj:', err);
                onModelLoaded();
            });

            loader.load('wspornik_dlugi_prawy.obj', function(obj) {
                loadedModels.wspornikDlugiPrawy = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania wspornik_dlugi_prawy.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj podest_krotki.obj (dla porƒôczy z podestem)
            loader.load('podest_krotki.obj', function(obj) {
                loadedModels.podestKrotki = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania podest_krotki.obj:', err);
                onModelLoaded();
            });
        }

        // Synchronizuj aliasy z aktualnƒÖ drabinƒÖ
        function syncLadderAliases() {
            if (currentLadder === 1) {
                numX7Ladders = numX7Ladders1;
                finalLadderRungs = finalLadderRungs1;
                connectorTypes = connectorTypes1;
                sciskaneHandles = sciskaneHandles1;
            } else {
                numX7Ladders = numX7Ladders2;
                finalLadderRungs = finalLadderRungs2;
                connectorTypes = connectorTypes2;
                sciskaneHandles = sciskaneHandles2;
            }
        }

        // Zapisz aliasy do aktualnej drabiny
        function saveLadderAliases() {
            if (currentLadder === 1) {
                numX7Ladders1 = numX7Ladders;
                finalLadderRungs1 = finalLadderRungs;
                connectorTypes1 = connectorTypes;
                sciskaneHandles1 = sciskaneHandles;
            } else {
                numX7Ladders2 = numX7Ladders;
                finalLadderRungs2 = finalLadderRungs;
                connectorTypes2 = connectorTypes;
                sciskaneHandles2 = sciskaneHandles;
            }
        }

        // Prze≈ÇƒÖcz na wybranƒÖ drabinƒô
        function switchToLadder(ladderNum) {
            saveLadderAliases();  // Zapisz obecne ustawienia
            currentLadder = ladderNum;
            syncLadderAliases();  // Wczytaj ustawienia nowej drabiny
        }

        function getLadderHeight(rungs) {
            return DIMS.railHeights[rungs];
        }

        // Oblicz wysoko≈õƒá dla konkretnej drabiny (1 lub 2)
        function getTotalHeightForLadder(ladderNum) {
            var x7Count = (ladderNum === 1) ? numX7Ladders1 : numX7Ladders2;
            var finalRungs = (ladderNum === 1) ? finalLadderRungs1 : finalLadderRungs2;

            var total = x7Count * getLadderHeight(7);
            if (finalRungs === '7alt') {
                total += getLadderHeight('7alt');
            } else if (finalRungs > 0) {
                total += getLadderHeight(finalRungs);
            }
            return total;
        }

        function getTotalHeight() {
            var total = numX7Ladders * getLadderHeight(7);
            if (finalLadderRungs === '7alt') {
                total += getLadderHeight('7alt');
            } else if (finalLadderRungs > 0) {
                total += getLadderHeight(finalLadderRungs);
            }

            // Attyka NIE dodaje do wysoko≈õci - jest na g√≥rze

            return total;
        }

        // Wysoko≈õƒá ko≈Ñcowej drabiny (koncowa)
        function getKoncowaHeight() {
            if (finalLadderRungs === '7alt') {
                return getLadderHeight('7alt');
            } else if (finalLadderRungs > 0) {
                return getLadderHeight(finalLadderRungs);
            }
            return 0;
        }
        
        function getLadderSections() {
            var sections = [];

            // Dodaj wszystkie drabiny x7 standardowe
            for (var i = 0; i < numX7Ladders; i++) {
                sections.push({rungs: 7, type: 'standard'});
            }

            // Dodaj ko≈ÑcowƒÖ drabinƒô (je≈õli jest)
            if (finalLadderRungs === '7alt') {
                sections.push({rungs: 7, type: 'alt'});
            } else if (finalLadderRungs > 0) {
                sections.push({rungs: finalLadderRungs, type: 'final'});
            }

            return sections;
        }

        // Pobierz sekcje dla konkretnej drabiny (1 lub 2)
        function getLadderSectionsForLadder(ladderNum) {
            var x7Count = (ladderNum === 1) ? numX7Ladders1 : numX7Ladders2;
            var finalRungs = (ladderNum === 1) ? finalLadderRungs1 : finalLadderRungs2;
            var sections = [];

            for (var i = 0; i < x7Count; i++) {
                sections.push({rungs: 7, type: 'standard'});
            }

            if (finalRungs === '7alt') {
                sections.push({rungs: 7, type: 'alt'});
            } else if (finalRungs > 0) {
                sections.push({rungs: finalRungs, type: 'final'});
            }

            return sections;
        }

        // Pobierz typ ≈ÇƒÖcznik√≥w dla konkretnej drabiny
        function getConnectorTypesForLadder(ladderNum) {
            return (ladderNum === 1) ? connectorTypes1 : connectorTypes2;
        }

        // Pobierz typy wspornik√≥w dla konkretnej drabiny
        function getWspornikTypesForLadder(ladderNum) {
            return (ladderNum === 1) ? wspornikTypes1 : wspornikTypes2;
        }

        // Pobierz domy≈õlny typ wspornika dla konkretnej drabiny
        function getDefaultWspornikForLadder(ladderNum) {
            // Sprawd≈∫ czy wsporniki sƒÖ wy≈ÇƒÖczone
            if (ladderNum === 1 && wspornikDisabled1) return 'none';
            if (ladderNum === 2 && wspornikDisabled2) return 'none';
            return (ladderNum === 1) ? defaultWspornik1 : defaultWspornik2;
        }

        // Obs≈Çuga klikania na ≈ÇƒÖczniki
        var selectedConnector = null;
        var connectorObjects = [];  // Lista wszystkich ≈ÇƒÖcznik√≥w w scenie
        var raycaster = null;
        var mouse = new THREE.Vector2();

        var selectedPairIndex = null;

        // Miarka
        var measureMode = false;
        var measurePoint1 = null;
        var measurePoint2 = null;
        var measureLine = null;
        var measureLabel = null;

        // Panel ≈ÇƒÖczenia (po≈ÇƒÖczony dla ≈ÇƒÖcznik√≥w i wspornik√≥w)
        var selectedWspornik = null;
        var selectedWspornikPairIndex = null;
        var selectedWspornikLadderNum = null;
        var selectedWspornikIsSciskane = false;
        var selectedWspornikHandleIndex = null;

        function closeConnectionPanel() {
            document.getElementById('connectionPanel').classList.remove('active');
            selectedConnector = null;
            selectedPairIndex = null;
            selectedWspornik = null;
            selectedWspornikPairIndex = null;
            selectedWspornikLadderNum = null;
            selectedWspornikIsSciskane = false;
            selectedWspornikHandleIndex = null;
            selectedSciskaneOffset = null;
            selectedSciskaneLadderNum = null;
            selectedIsMidRungBracket = false;

            // Resetuj UI do stanu domy≈õlnego (dla zwyk≈Çych ≈ÇƒÖcznik√≥w)
            document.getElementById('connTypeBtnUchwyt').style.display = 'inline-block';
            document.getElementById('connTypeBtnLacznik').style.display = 'inline-block';
            document.getElementById('connTypeBtnSciskany').style.display = 'none';
            document.getElementById('midRungRemoveBtn').style.display = 'none';

            // Przywr√≥ƒá domy≈õlne onclick
            document.getElementById('connTypeBtnUchwyt').onclick = function() { setConnectionType('uchwyt'); };
            document.getElementById('connTypeBtnLacznik').onclick = function() { setConnectionType('lacznik'); };
            document.getElementById('connTypeBtnSciskany').onclick = function() { setMidRungConnType('sciskany'); };
            document.getElementById('midRungRemoveBtn').onclick = removeMidRungBracket;
        }

        // Domy≈õlne odleg≈Ço≈õci dla typ√≥w wspornik√≥w (mm)
        var wspornikDefaultDistances = {
            'krotki': 215,  // 21.5cm (zakres 16-26cm)
            'sredni': 315,  // 31.5cm (zakres 26-36cm)
            'dlugi': 415    // 41.5cm (zakres 36-46cm)
        };

        // Zakresy odleg≈Ço≈õci dla typ√≥w wspornik√≥w (mm)
        var wspornikDistanceRanges = {
            'krotki': { min: 160, max: 260 },
            'sredni': { min: 260, max: 360 },
            'dlugi': { min: 360, max: 460 }
        };

        // Okre≈õl typ wspornika na podstawie odleg≈Ço≈õci
        function getWspornikTypeFromDistance(distanceMm) {
            if (distanceMm < 260) return 'krotki';
            if (distanceMm < 360) return 'sredni';
            return 'dlugi';
        }

        // Aktualizuj wszystkie wsporniki globalnie dla drabiny
        function updateGlobalWspornikDistance(ladderNum, distanceMm) {
            var type = getWspornikTypeFromDistance(distanceMm);

            if (ladderNum === 1) {
                globalWspornikDistance1 = distanceMm;
                defaultWspornik1 = type;
                // Aktualizuj wszystkie wsporniki
                for (var i = 0; i < wspornikTypes1.length; i++) {
                    if (wspornikTypes1[i] !== 'none') {
                        wspornikTypes1[i] = type;
                        wspornikDistances1[i] = distanceMm;
                    }
                }
                // Aktualizuj wsporniki przy uchwytach ≈õciskanych
                for (var i = 0; i < sciskaneHandles1.length; i++) {
                    if (sciskaneHandles1[i].wspornikType !== 'none') {
                        sciskaneHandles1[i].wspornikType = type;
                        sciskaneHandles1[i].wspornikDistance = distanceMm;
                    }
                }
                // Aktualizuj specjalny uchwyt miƒôdzy 2. a 3. szczeblem
                if (midRungBracketWspornikType1 !== 'none') {
                    midRungBracketWspornikType1 = type;
                    midRungBracketDistance1 = distanceMm;
                }
            } else {
                globalWspornikDistance2 = distanceMm;
                defaultWspornik2 = type;
                for (var i = 0; i < wspornikTypes2.length; i++) {
                    if (wspornikTypes2[i] !== 'none') {
                        wspornikTypes2[i] = type;
                        wspornikDistances2[i] = distanceMm;
                    }
                }
                for (var i = 0; i < sciskaneHandles2.length; i++) {
                    if (sciskaneHandles2[i].wspornikType !== 'none') {
                        sciskaneHandles2[i].wspornikType = type;
                        sciskaneHandles2[i].wspornikDistance = distanceMm;
                    }
                }
                // Aktualizuj specjalny uchwyt miƒôdzy 2. a 3. szczeblem
                if (midRungBracketWspornikType2 !== 'none') {
                    midRungBracketWspornikType2 = type;
                    midRungBracketDistance2 = distanceMm;
                }
            }
        }

        // W≈ÇƒÖcz/wy≈ÇƒÖcz wszystkie wsporniki dla drabiny
        function toggleAllWsporniki(ladderNum, disabled) {
            var type = disabled ? 'none' : getWspornikTypeFromDistance(ladderNum === 1 ? globalWspornikDistance1 : globalWspornikDistance2);

            if (ladderNum === 1) {
                wspornikDisabled1 = disabled;
                defaultWspornik1 = type;
                for (var i = 0; i < wspornikTypes1.length; i++) {
                    wspornikTypes1[i] = type;
                }
                for (var i = 0; i < sciskaneHandles1.length; i++) {
                    sciskaneHandles1[i].wspornikType = type;
                }
                // Specjalny uchwyt miƒôdzy 2. a 3. szczeblem
                midRungBracketWspornikType1 = type;
            } else {
                wspornikDisabled2 = disabled;
                defaultWspornik2 = type;
                for (var i = 0; i < wspornikTypes2.length; i++) {
                    wspornikTypes2[i] = type;
                }
                for (var i = 0; i < sciskaneHandles2.length; i++) {
                    sciskaneHandles2[i].wspornikType = type;
                }
                // Specjalny uchwyt miƒôdzy 2. a 3. szczeblem
                midRungBracketWspornikType2 = type;
            }
        }

        var selectedIsMidRungBracket = false;  // Czy edytujemy uchwyt miƒôdzy 2. a 3. szczeblem

        function openConnectionPanel(connector, wspornik) {
            // Mo≈ºna otworzyƒá z ≈ÇƒÖcznika lub wspornika
            // ZAWSZE resetuj wszystkie zmienne selekcji na start
            selectedConnector = null;
            selectedWspornik = null;
            selectedPairIndex = null;
            selectedWspornikPairIndex = null;
            selectedWspornikIsSciskane = false;
            selectedWspornikHandleIndex = null;
            selectedIsMidRungBracket = false;

            if (connector) {
                selectedConnector = connector;
                selectedPairIndex = connector.userData.pairIndex;
                selectedWspornikLadderNum = connector.userData.ladderNum || 1;
                selectedWspornikPairIndex = selectedPairIndex;
                selectedIsMidRungBracket = connector.userData.isMidRungBracket || false;
            }
            if (wspornik) {
                selectedWspornik = wspornik;
                selectedWspornikLadderNum = wspornik.userData.ladderNum || 1;
                selectedWspornikIsSciskane = wspornik.userData.isSciskaneWspornik || false;
                selectedIsMidRungBracket = wspornik.userData.isMidRungBracket || false;
                if (selectedWspornikIsSciskane) {
                    selectedWspornikHandleIndex = wspornik.userData.sciskaneHandleIndex;
                } else if (!selectedIsMidRungBracket) {
                    selectedWspornikPairIndex = wspornik.userData.pairIndex;
                    selectedPairIndex = selectedWspornikPairIndex;
                }
            }

            // Sprawd≈∫ czy to uchwyt porƒôczy (nie mo≈ºna zmieniƒá)
            if (handrailType === 'safety' && selectedPairIndex === 0) {
                return;
            }

            // Je≈õli to uchwyt miƒôdzy 2. a 3. szczeblem - specjalny panel (tylko w trybie edycji)
            if (selectedIsMidRungBracket) {
                if (sciskaneMode) {
                    openMidRungBracketPanel();
                }
                return;
            }

            // Pobierz aktualny typ ≈ÇƒÖcznika
            var targetConnectorTypes = (selectedWspornikLadderNum === 1) ? connectorTypes1 : connectorTypes2;
            var currentConnectorType = targetConnectorTypes[selectedPairIndex] || 'uchwyt';

            // WA≈ªNE: Resetuj onclick handlers do domy≈õlnych dla zwyk≈Çych ≈ÇƒÖcznik√≥w
            // (mog≈Çy byƒá zmienione przez openSciskaneEditPanel lub openMidRungBracketPanel)
            document.getElementById('connTypeBtnUchwyt').style.display = 'inline-block';
            document.getElementById('connTypeBtnLacznik').style.display = 'inline-block';
            document.getElementById('connTypeBtnSciskany').style.display = 'none';
            document.getElementById('midRungRemoveBtn').style.display = 'none';
            document.getElementById('connTypeBtnUchwyt').onclick = function() { setConnectionType('uchwyt'); };
            document.getElementById('connTypeBtnLacznik').onclick = function() { setConnectionType('lacznik'); };

            // Aktualizuj przyciski typu ≈ÇƒÖczenia
            updateConnectionTypeButtons(currentConnectorType);

            // Je≈õli uchwyt - poka≈º opcje wspornika
            if (currentConnectorType === 'uchwyt') {
                showWspornikOptions();
            } else {
                document.getElementById('wspornikOptions').style.display = 'none';
            }

            document.getElementById('connectionPanel').classList.add('active');
        }

        function openMidRungBracketPanel() {
            // Panel dla uchwytu miƒôdzy 2. a 3. szczeblem
            var connType = (selectedWspornikLadderNum === 1) ? midRungBracketConnType1 : midRungBracketConnType2;
            var wspornikType = (selectedWspornikLadderNum === 1) ? midRungBracketWspornikType1 : midRungBracketWspornikType2;
            var wspornikDistance = (selectedWspornikLadderNum === 1) ? midRungBracketDistance1 : midRungBracketDistance2;

            // Poka≈º przyciski Uchwyt i ≈öciski (ukryj ≈ÅƒÖcznik)
            document.getElementById('connTypeBtnUchwyt').style.display = 'inline-block';
            document.getElementById('connTypeBtnLacznik').style.display = 'none';
            document.getElementById('connTypeBtnSciskany').style.display = 'inline-block';

            // Ustaw aktywny typ
            document.getElementById('connTypeBtnUchwyt').classList.remove('active');
            document.getElementById('connTypeBtnSciskany').classList.remove('active');
            if (connType === 'sciskany') {
                document.getElementById('connTypeBtnSciskany').classList.add('active');
            } else {
                document.getElementById('connTypeBtnUchwyt').classList.add('active');
            }

            // Zmie≈Ñ onclick dla przycisk√≥w aby u≈ºywa≈Çy setMidRungConnType
            document.getElementById('connTypeBtnUchwyt').onclick = function() { setMidRungConnType('uchwyt'); };
            document.getElementById('connTypeBtnSciskany').onclick = function() { setMidRungConnType('sciskany'); };

            // Poka≈º przycisk usuwania z poprawnym onclick
            var removeBtn = document.getElementById('midRungRemoveBtn');
            if (removeBtn) {
                removeBtn.style.display = 'block';
                removeBtn.onclick = removeMidRungBracket;
            }

            // Poka≈º opcje wspornika
            showMidRungWspornikOptions(wspornikType, wspornikDistance);

            document.getElementById('connectionPanel').classList.add('active');
        }

        function setMidRungConnType(type) {
            if (selectedWspornikLadderNum === 1) {
                midRungBracketConnType1 = type;
            } else {
                midRungBracketConnType2 = type;
            }

            // Aktualizuj przyciski
            document.getElementById('connTypeBtnUchwyt').classList.remove('active');
            document.getElementById('connTypeBtnSciskany').classList.remove('active');
            if (type === 'sciskany') {
                document.getElementById('connTypeBtnSciskany').classList.add('active');
            } else {
                document.getElementById('connTypeBtnUchwyt').classList.add('active');
            }

            createLadder();
        }

        function showMidRungWspornikOptions(type, distance) {
            var wspornikOptions = document.getElementById('wspornikOptions');
            wspornikOptions.style.display = 'block';

            // Ustaw aktywny typ
            document.querySelectorAll('.wspornik-type-btn').forEach(function(btn) {
                btn.classList.remove('active');
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                }
            });

            // Ustaw slider (tylko je≈õli nie 'none')
            if (type !== 'none') {
                var range = wspornikDistanceRanges[type] || wspornikDistanceRanges['krotki'];
                var slider = document.getElementById('wspornikSlider');
                slider.min = range.min;
                slider.max = range.max;
                slider.value = Math.max(range.min, Math.min(range.max, distance));
                document.getElementById('wspornikDistanceValue').textContent = Math.round(slider.value / 10);
            }
        }

        function removeMidRungBracket() {
            if (selectedWspornikLadderNum === 1) {
                midRungBracket1 = false;
            } else {
                midRungBracket2 = false;
            }
            closeConnectionPanel();
            createLadder();
        }

        // Zmienne dla edycji uchwytu ≈õciskanego
        var selectedSciskaneOffset = null;
        var selectedSciskaneLadderNum = null;

        function openSciskaneEditPanel(offsetFromBottom, ladderNum) {
            // Resetuj poprzednie selekcje
            selectedConnector = null;
            selectedWspornik = null;
            selectedPairIndex = null;
            selectedWspornikPairIndex = null;
            selectedIsMidRungBracket = false;

            selectedSciskaneOffset = offsetFromBottom;
            selectedSciskaneLadderNum = ladderNum;
            selectedWspornikLadderNum = ladderNum;
            selectedWspornikIsSciskane = true;

            // Znajd≈∫ dane uchwytu
            var handles = (ladderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
            var handleData = null;
            var handleIndex = -1;
            for (var i = 0; i < handles.length; i++) {
                if (handles[i].offsetFromBottom === offsetFromBottom) {
                    handleData = handles[i];
                    handleIndex = i;
                    break;
                }
            }
            if (!handleData) return;

            selectedWspornikHandleIndex = handleIndex;

            var connType = handleData.connType || 'sciskany';
            var wspornikType = handleData.wspornikType || 'krotki';
            var wspornikDistance = handleData.wspornikDistance || 215;

            // Poka≈º przyciski Uchwyt i ≈öciski (ukryj ≈ÅƒÖcznik)
            document.getElementById('connTypeBtnUchwyt').style.display = 'inline-block';
            document.getElementById('connTypeBtnLacznik').style.display = 'none';
            document.getElementById('connTypeBtnSciskany').style.display = 'inline-block';

            // Ustaw aktywny typ
            document.getElementById('connTypeBtnUchwyt').classList.remove('active');
            document.getElementById('connTypeBtnSciskany').classList.remove('active');
            if (connType === 'uchwyt') {
                document.getElementById('connTypeBtnUchwyt').classList.add('active');
            } else {
                document.getElementById('connTypeBtnSciskany').classList.add('active');
            }

            // Zmie≈Ñ onclick dla przycisk√≥w
            document.getElementById('connTypeBtnUchwyt').onclick = function() { setSciskaneConnType('uchwyt'); };
            document.getElementById('connTypeBtnSciskany').onclick = function() { setSciskaneConnType('sciskany'); };

            // Poka≈º przycisk usuwania
            var removeBtn = document.getElementById('midRungRemoveBtn');
            if (removeBtn) {
                removeBtn.style.display = 'block';
                removeBtn.onclick = removeSciskaneHandle;
            }

            // Poka≈º opcje wspornika
            showSciskaneWspornikOptions(wspornikType, wspornikDistance);

            document.getElementById('connectionPanel').classList.add('active');
        }

        function setSciskaneConnType(type) {
            var handles = (selectedSciskaneLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
            for (var i = 0; i < handles.length; i++) {
                if (handles[i].offsetFromBottom === selectedSciskaneOffset) {
                    handles[i].connType = type;
                    break;
                }
            }

            // Aktualizuj przyciski
            document.getElementById('connTypeBtnUchwyt').classList.remove('active');
            document.getElementById('connTypeBtnSciskany').classList.remove('active');
            if (type === 'uchwyt') {
                document.getElementById('connTypeBtnUchwyt').classList.add('active');
            } else {
                document.getElementById('connTypeBtnSciskany').classList.add('active');
            }

            createLadder();
        }

        function showSciskaneWspornikOptions(type, distance) {
            var wspornikOptions = document.getElementById('wspornikOptions');
            wspornikOptions.style.display = 'block';

            // Ustaw aktywny typ
            document.querySelectorAll('.wspornik-type-btn').forEach(function(btn) {
                btn.classList.remove('active');
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                }
            });

            // Ustaw slider
            if (type !== 'none') {
                var range = wspornikDistanceRanges[type] || wspornikDistanceRanges['krotki'];
                var slider = document.getElementById('wspornikSlider');
                slider.min = range.min;
                slider.max = range.max;
                slider.value = Math.max(range.min, Math.min(range.max, distance));
                document.getElementById('wspornikDistanceValue').textContent = Math.round(slider.value / 10);
            }
        }

        function removeSciskaneHandle() {
            var handles = (selectedSciskaneLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
            for (var i = 0; i < handles.length; i++) {
                if (handles[i].offsetFromBottom === selectedSciskaneOffset) {
                    handles.splice(i, 1);
                    break;
                }
            }
            closeConnectionPanel();
            createLadder();
        }

        function updateConnectionTypeButtons(activeType) {
            document.getElementById('connTypeBtnUchwyt').classList.remove('active');
            document.getElementById('connTypeBtnLacznik').classList.remove('active');
            if (activeType === 'uchwyt') {
                document.getElementById('connTypeBtnUchwyt').classList.add('active');
            } else {
                document.getElementById('connTypeBtnLacznik').classList.add('active');
            }
        }

        function showWspornikOptions() {
            var currentType, currentDistance;

            if (selectedWspornikIsSciskane) {
                var ladderHandles = (selectedWspornikLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                if (ladderHandles[selectedWspornikHandleIndex]) {
                    currentType = ladderHandles[selectedWspornikHandleIndex].wspornikType || 'krotki';
                    currentDistance = ladderHandles[selectedWspornikHandleIndex].wspornikDistance || wspornikDefaultDistances[currentType];
                }
            } else {
                var targetTypes = (selectedWspornikLadderNum === 1) ? wspornikTypes1 : wspornikTypes2;
                var targetDistances = (selectedWspornikLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                currentType = targetTypes[selectedWspornikPairIndex] || 'krotki';
                currentDistance = targetDistances[selectedWspornikPairIndex] || wspornikDefaultDistances[currentType];
            }

            // Aktualizuj przyciski typu wspornika
            updateWspornikTypeButtons(currentType);

            // Aktualizuj slider
            updateWspornikSlider(currentType, currentDistance);

            document.getElementById('wspornikOptions').style.display = 'block';
        }

        function setConnectionType(type) {
            if (selectedPairIndex === null) return;

            var targetConnectorTypes = (selectedWspornikLadderNum === 1) ? connectorTypes1 : connectorTypes2;
            var targetWspornikTypes = (selectedWspornikLadderNum === 1) ? wspornikTypes1 : wspornikTypes2;
            var targetWspornikSaved = (selectedWspornikLadderNum === 1) ? wspornikTypesSaved1 : wspornikTypesSaved2;

            var oldType = targetConnectorTypes[selectedPairIndex];

            // Je≈õli zmiana z uchwyt na ≈ÇƒÖcznik - zapisz aktualny wspornik i usu≈Ñ
            if (oldType === 'uchwyt' && type === 'lacznik') {
                targetWspornikSaved[selectedPairIndex] = targetWspornikTypes[selectedPairIndex] || 'none';
                targetWspornikTypes[selectedPairIndex] = 'none';
            }
            // Je≈õli zmiana z ≈ÇƒÖcznik na uchwyt - przywr√≥ƒá zapisany wspornik
            else if (oldType === 'lacznik' && type === 'uchwyt') {
                var savedType = targetWspornikSaved[selectedPairIndex];
                if (savedType && savedType !== 'none') {
                    targetWspornikTypes[selectedPairIndex] = savedType;
                } else {
                    var defaultWspornik = (selectedWspornikLadderNum === 1) ? defaultWspornik1 : defaultWspornik2;
                    targetWspornikTypes[selectedPairIndex] = defaultWspornik;
                }
            }

            targetConnectorTypes[selectedPairIndex] = type;

            // Aktualizuj UI
            updateConnectionTypeButtons(type);

            if (type === 'uchwyt') {
                showWspornikOptions();
            } else {
                // ≈ÅƒÖcznik - zamknij panel
                closeConnectionPanel();
            }

            createLadder();
        }

        function updateWspornikTypeButtons(activeType) {
            var buttons = document.querySelectorAll('.wspornik-type-btn');
            buttons.forEach(function(btn) {
                btn.classList.remove('active');
                if (btn.textContent === 'Kr√≥tki' && activeType === 'krotki') btn.classList.add('active');
                if (btn.textContent === '≈öredni' && activeType === 'sredni') btn.classList.add('active');
                if (btn.textContent === 'D≈Çugi' && activeType === 'dlugi') btn.classList.add('active');
                if (btn.textContent === 'Brak' && activeType === 'none') btn.classList.add('active');
            });

            // Poka≈º/ukryj slider
            var sliderRow = document.getElementById('wspornikSliderRow');
            sliderRow.style.display = (activeType === 'none') ? 'none' : 'block';
        }

        function updateWspornikSlider(type, currentDistance) {
            if (type === 'none') return;

            var range = wspornikDistanceRanges[type] || wspornikDistanceRanges['krotki'];
            var slider = document.getElementById('wspornikSlider');

            // Ustaw warto≈õƒá w zakresie
            var value = currentDistance || wspornikDefaultDistances[type];
            value = Math.max(range.min, Math.min(range.max, value));

            // Ustaw min/max przed value
            slider.min = range.min;
            slider.max = range.max;
            slider.value = value;

            document.getElementById('wspornikDistanceValue').textContent = Math.round(value / 10);
        }

        function setWspornikTypeFromPanel(type) {
            // Mo≈ºe byƒá otwarte z wspornika, ≈ÇƒÖcznika, midRungBracket lub sciskane
            if (selectedWspornik === null && selectedPairIndex === null && !selectedIsMidRungBracket && !selectedWspornikIsSciskane) return;

            if (selectedIsMidRungBracket) {
                // Specjalny uchwyt miƒôdzy 2. a 3. szczeblem
                if (selectedWspornikLadderNum === 1) {
                    midRungBracketWspornikType1 = type;
                    if (type !== 'none') {
                        var range = wspornikDistanceRanges[type];
                        if (midRungBracketDistance1 < range.min || midRungBracketDistance1 > range.max) {
                            midRungBracketDistance1 = wspornikDefaultDistances[type];
                        }
                    }
                } else {
                    midRungBracketWspornikType2 = type;
                    if (type !== 'none') {
                        var range = wspornikDistanceRanges[type];
                        if (midRungBracketDistance2 < range.min || midRungBracketDistance2 > range.max) {
                            midRungBracketDistance2 = wspornikDefaultDistances[type];
                        }
                    }
                }
            } else if (selectedWspornikIsSciskane) {
                var ladderHandles = (selectedWspornikLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                if (ladderHandles[selectedWspornikHandleIndex]) {
                    ladderHandles[selectedWspornikHandleIndex].wspornikType = type;
                    if (type !== 'none') {
                        var range = wspornikDistanceRanges[type];
                        var currentDist = ladderHandles[selectedWspornikHandleIndex].wspornikDistance || 0;
                        if (currentDist < range.min || currentDist > range.max) {
                            ladderHandles[selectedWspornikHandleIndex].wspornikDistance = wspornikDefaultDistances[type];
                        }
                    }
                }
            } else {
                var targetTypes = (selectedWspornikLadderNum === 1) ? wspornikTypes1 : wspornikTypes2;
                var targetDistances = (selectedWspornikLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                targetTypes[selectedWspornikPairIndex] = type;
                if (type !== 'none') {
                    var range = wspornikDistanceRanges[type];
                    var currentDist = targetDistances[selectedWspornikPairIndex] || 0;
                    if (currentDist < range.min || currentDist > range.max) {
                        targetDistances[selectedWspornikPairIndex] = wspornikDefaultDistances[type];
                    }
                }
            }

            updateWspornikTypeButtons(type);
            if (type !== 'none') {
                var newDistance = wspornikDefaultDistances[type];
                if (selectedIsMidRungBracket) {
                    newDistance = (selectedWspornikLadderNum === 1) ? midRungBracketDistance1 : midRungBracketDistance2;
                } else if (selectedWspornikIsSciskane) {
                    var ladderHandles = (selectedWspornikLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                    newDistance = ladderHandles[selectedWspornikHandleIndex].wspornikDistance || wspornikDefaultDistances[type];
                } else {
                    var targetDistances = (selectedWspornikLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                    newDistance = targetDistances[selectedWspornikPairIndex] || wspornikDefaultDistances[type];
                }
                updateWspornikSlider(type, newDistance);
            }

            createLadder();
        }

        function updateWspornikDistance(value) {
            var distanceMm = parseInt(value);
            document.getElementById('wspornikDistanceValue').textContent = Math.round(distanceMm / 10);

            if (selectedIsMidRungBracket) {
                // Specjalny uchwyt miƒôdzy 2. a 3. szczeblem
                if (selectedWspornikLadderNum === 1) {
                    midRungBracketDistance1 = distanceMm;
                } else {
                    midRungBracketDistance2 = distanceMm;
                }
            } else if (selectedWspornikIsSciskane) {
                var ladderHandles = (selectedWspornikLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                if (ladderHandles[selectedWspornikHandleIndex]) {
                    ladderHandles[selectedWspornikHandleIndex].wspornikDistance = distanceMm;
                }
            } else {
                var targetDistances = (selectedWspornikLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                targetDistances[selectedWspornikPairIndex] = distanceMm;
            }

            createLadder();
        }

        // Cykliczne prze≈ÇƒÖczanie typu wspornika (nieu≈ºywane, zastƒÖpione panelem)
        function cycleWspornikType(wspornik) {
            var ladderNum = wspornik.userData.ladderNum || 1;

            // Cykl: krotki -> sredni -> dlugi -> krotki
            var types = ['krotki', 'sredni', 'dlugi'];

            // Sprawd≈∫ czy to wspornik od ≈õciskanego czy od zwyk≈Çego uchwytu
            if (wspornik.userData.isSciskaneWspornik) {
                // Wspornik przy uchwycie ≈õciskanym
                var handleIndex = wspornik.userData.sciskaneHandleIndex;
                var ladderHandles = (ladderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;

                if (handleIndex !== undefined && ladderHandles[handleIndex]) {
                    var currentType = ladderHandles[handleIndex].wspornikType || 'krotki';
                    var currentIndex = types.indexOf(currentType);
                    var nextIndex = (currentIndex + 1) % types.length;
                    ladderHandles[handleIndex].wspornikType = types[nextIndex];
                }
            } else {
                // Wspornik przy zwyk≈Çym uchwycie (connector)
                var pairIndex = wspornik.userData.pairIndex;
                var targetWspornikTypes = (ladderNum === 1) ? wspornikTypes1 : wspornikTypes2;

                var currentType = targetWspornikTypes[pairIndex] || 'krotki';
                var currentIndex = types.indexOf(currentType);
                var nextIndex = (currentIndex + 1) % types.length;
                targetWspornikTypes[pairIndex] = types[nextIndex];
            }

            // Od≈õwie≈º drabinƒô
            createLadder();
        }

        // Funkcje miarki
        function toggleMeasureMode() {
            measureMode = !measureMode;
            var btn = document.getElementById('measureBtn');
            if (measureMode) {
                btn.style.background = 'rgba(0, 200, 100, 0.9)';
                btn.style.border = '2px solid lime';
                measurePoint1 = null;
                measurePoint2 = null;
                clearMeasureLine();
                document.getElementById('measureResult').style.display = 'none';
            } else {
                btn.style.background = 'rgba(50, 100, 200, 0.9)';
                btn.style.border = '2px solid white';
                clearMeasureLine();
            }
        }

        function clearMeasureLine() {
            if (measureLine) {
                scene.remove(measureLine);
                measureLine = null;
            }
        }

        function addMeasurePoint(point) {
            if (!measurePoint1) {
                measurePoint1 = point.clone();
                // Dodaj wizualnƒÖ kulkƒô w punkcie 1
            } else {
                measurePoint2 = point.clone();
                // Oblicz odleg≈Ço≈õƒá
                var distance = measurePoint1.distanceTo(measurePoint2);
                var distanceMM = Math.round(distance / SCALE);  // przelicz na mm

                // Narysuj liniƒô miƒôdzy punktami
                var geometry = new THREE.BufferGeometry().setFromPoints([measurePoint1, measurePoint2]);
                var material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
                measureLine = new THREE.Line(geometry, material);
                scene.add(measureLine);

                // Wy≈õwietl wynik
                var resultDiv = document.getElementById('measureResult');
                resultDiv.innerHTML = distanceMM + ' mm<br><span style="font-size: 14px;">(' + (distanceMM/10).toFixed(1) + ' cm)</span><br><button onclick="closeMeasureResult()" style="margin-top: 10px; padding: 5px 15px; cursor: pointer;">OK</button>';
                resultDiv.style.display = 'block';

                // Reset dla nastƒôpnego pomiaru
                measurePoint1 = null;
                measurePoint2 = null;
            }
        }

        function closeMeasureResult() {
            document.getElementById('measureResult').style.display = 'none';
            clearMeasureLine();
        }

        // Funkcje uchwyt√≥w ≈õciskanych
        function toggleSciskaneMode() {
            sciskaneMode = !sciskaneMode;
            var btn = document.getElementById('sciskaneBtn');
            if (sciskaneMode) {
                btn.style.background = 'rgba(0, 200, 100, 0.9)';
                btn.style.border = '2px solid lime';
                // Wy≈ÇƒÖcz tryb miarki je≈õli aktywny
                if (measureMode) {
                    toggleMeasureMode();
                }
                createSciskanePreview();
            } else {
                btn.style.background = 'rgba(50, 100, 200, 0.9)';
                btn.style.border = '2px solid white';
                clearSciskanePreview();
            }
        }

        function getConnectorPositions() {
            // Zwraca listƒô pozycji Y (w mm) gdzie sƒÖ ≈ÇƒÖczniki dla aktualnie edytowanej drabiny
            var positions = [];
            var sections = getLadderSectionsForLadder(currentLadder);
            var ladderTotalHeight = getTotalHeightForLadder(currentLadder);

            // Oblicz maxHeight dla wyr√≥wnania g√≥r
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // G√≥ra drabiny - wyr√≥wnana do maxHeight
            if ((handrailType === 'safety' || handrailType === 'attic') && sections.length > 0) {
                var topY = (maxHeight / 2) - (DIMS.connectorHeight / 2) - 50;
                if (handrailType === 'attic') {
                    topY += 100;  // offset dla attyki
                } else {
                    topY += 50;  // offset dla porƒôczy
                }
                positions.push(topY);
            }

            // Miƒôdzy sekcjami
            var currentOffset = 0;
            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                currentOffset += sectionHeight;

                if (i < sections.length - 1) {
                    var connectionY = (maxHeight / 2) - currentOffset + (DIMS.connectorHeight / 2) - 50;
                    positions.push(connectionY);
                }
            }

            return positions;
        }

        // Funkcja sprawdzajƒÖca kolizje miƒôdzy uchwytami/≈ÇƒÖcznikami a obrƒôczami kosza
        function checkCageCollisions() {
            var collisions = [];
            var collisionThreshold = 100;  // 10cm - odleg≈Ço≈õƒá uznawana za kolizjƒô

            // Oblicz pozycje obrƒôczy
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            var topPosition = maxHeight / 2;
            var firstHoopOffset;
            if (handrailType === 'safety' || handrailType === 'platform') {
                topPosition += DIMS.handrailVertical;
                firstHoopOffset = 25;
            } else if (handrailType === 'attic') {
                topPosition += DIMS.atticRailHeight;
                firstHoopOffset = 25;
            } else {
                firstHoopOffset = 294.3;
            }

            var hoopSpacing = 641.7;

            // Sprawd≈∫ kolizje dla drabiny 1
            if (safetyCageCount1 > 0 && height1 > 0) {
                var hoopPositions1 = [];
                for (var i = 0; i < safetyCageCount1; i++) {
                    hoopPositions1.push(topPosition - firstHoopOffset - (i * hoopSpacing));
                }

                // Pobierz pozycje ≈ÇƒÖcznik√≥w dla drabiny 1
                var savedLadder = currentLadder;
                currentLadder = 1;
                var connPositions1 = getConnectorPositions();
                currentLadder = savedLadder;

                // Sprawd≈∫ kolizje ≈ÇƒÖcznik√≥w
                for (var c = 0; c < connPositions1.length; c++) {
                    for (var h = 0; h < hoopPositions1.length; h++) {
                        if (Math.abs(connPositions1[c] - hoopPositions1[h]) < collisionThreshold) {
                            collisions.push({ ladder: 1, type: 'connector', position: connPositions1[c] });
                            break;
                        }
                    }
                }

                // Sprawd≈∫ kolizje uchwyt√≥w ≈õciskanych
                for (var s = 0; s < sciskaneHandles1.length; s++) {
                    var handleY = (maxHeight / 2) - (height1 - sciskaneHandles1[s].offsetFromBottom);
                    for (var h = 0; h < hoopPositions1.length; h++) {
                        if (Math.abs(handleY - hoopPositions1[h]) < collisionThreshold) {
                            collisions.push({ ladder: 1, type: 'sciskane', position: handleY });
                            break;
                        }
                    }
                }
                // Uwaga: specjalny uchwyt (mid-rung bracket) nie jest sprawdzany - fizycznie niemo≈ºliwa kolizja
            }

            // Sprawd≈∫ kolizje dla drabiny 2 (tylko przy attyce)
            if (handrailType === 'attic' && safetyCageCount2 > 0 && height2 > 0) {
                var hoopPositions2 = [];
                for (var i = 0; i < safetyCageCount2; i++) {
                    hoopPositions2.push(topPosition - firstHoopOffset - (i * hoopSpacing));
                }

                // Pobierz pozycje ≈ÇƒÖcznik√≥w dla drabiny 2
                var savedLadder = currentLadder;
                currentLadder = 2;
                var connPositions2 = getConnectorPositions();
                currentLadder = savedLadder;

                // Sprawd≈∫ kolizje ≈ÇƒÖcznik√≥w
                for (var c = 0; c < connPositions2.length; c++) {
                    for (var h = 0; h < hoopPositions2.length; h++) {
                        if (Math.abs(connPositions2[c] - hoopPositions2[h]) < collisionThreshold) {
                            collisions.push({ ladder: 2, type: 'connector', position: connPositions2[c] });
                            break;
                        }
                    }
                }

                // Sprawd≈∫ kolizje uchwyt√≥w ≈õciskanych
                for (var s = 0; s < sciskaneHandles2.length; s++) {
                    var handleY = (maxHeight / 2) - (height2 - sciskaneHandles2[s].offsetFromBottom);
                    for (var h = 0; h < hoopPositions2.length; h++) {
                        if (Math.abs(handleY - hoopPositions2[h]) < collisionThreshold) {
                            collisions.push({ ladder: 2, type: 'sciskane', position: handleY });
                            break;
                        }
                    }
                }
                // Uwaga: specjalny uchwyt (mid-rung bracket) nie jest sprawdzany - fizycznie niemo≈ºliwa kolizja
            }

            return collisions;
        }

        function showCollisionWarning(collisions) {
            var warningEl = document.getElementById('collisionWarning');
            var textEl = document.getElementById('collisionWarningText');
            if (collisions.length === 0) {
                warningEl.style.display = 'none';
                return;
            }

            // Zbierz typy kolizji (uchwyt specjalny nie jest sprawdzany - fizycznie niemo≈ºliwa kolizja)
            var types = [];
            var hasConnector = false;
            var hasSciskane = false;
            for (var i = 0; i < collisions.length; i++) {
                if (collisions[i].type === 'connector' && !hasConnector) {
                    types.push('uchwyt');
                    hasConnector = true;
                } else if (collisions[i].type === 'sciskane' && !hasSciskane) {
                    types.push('≈õciskany');
                    hasSciskane = true;
                }
            }

            var message = 'Wykryto kolizjƒô z obrƒôczƒÖ kosza: ' + types.join(', ');

            if (handrailType === 'attic') {
                // Poka≈º kt√≥re drabiny majƒÖ kolizje
                var ladders = [];
                for (var i = 0; i < collisions.length; i++) {
                    if (ladders.indexOf(collisions[i].ladder) === -1) {
                        ladders.push(collisions[i].ladder);
                    }
                }
                ladders.sort();
                message += ' (Drabina ' + ladders.join(', ') + ')';
            }

            textEl.textContent = message;
            warningEl.style.display = 'block';
        }

        function hideCollisionWarning() {
            document.getElementById('collisionWarning').style.display = 'none';
        }

        function isPositionValidForSciskane(yPos, ladderNum) {
            // U≈ºyj podanego numeru drabiny lub aktualnie edytowanej
            var targetLadder = ladderNum || currentLadder;
            var ladderTotalHeight = getTotalHeightForLadder(targetLadder);
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            var connectorPositions = getConnectorPositions();
            var currentHandles = (targetLadder === 1) ? sciskaneHandles1 : sciskaneHandles2;
            var minDistance = 150;  // Minimalna odleg≈Ço≈õƒá 15cm od ≈ÇƒÖcznika

            for (var i = 0; i < connectorPositions.length; i++) {
                if (Math.abs(yPos - connectorPositions[i]) < minDistance) {
                    return false;
                }
            }

            // Sprawd≈∫ odleg≈Ço≈õƒá od specjalnego uchwytu miƒôdzy 2. a 3. szczeblem
            var midRungBracketEnabled = (targetLadder === 1) ? midRungBracket1 : midRungBracket2;
            if (midRungBracketEnabled && handrailType !== 'attic') {
                var midRungY = (maxHeight / 2) - 548.5;
                if (Math.abs(yPos - midRungY) < minDistance) {
                    return false;
                }
            }

            // Przelicz yPos na offset od do≈Çu (d√≥≈Ç tej drabiny = maxHeight/2 - ladderTotalHeight)
            var offsetFromBottom = yPos - (maxHeight / 2 - ladderTotalHeight);

            // Sprawd≈∫ czy ju≈º nie ma pary w tym miejscu
            for (var j = 0; j < currentHandles.length; j++) {
                if (Math.abs(currentHandles[j].offsetFromBottom - offsetFromBottom) < 10) {
                    return false;  // Ju≈º jest para w tym miejscu (tolerancja 10mm)
                }
            }

            return true;
        }

        function createSciskanePreview() {
            clearSciskanePreview();

            var railOffset = 265;

            // Oblicz maxHeight dla wyr√≥wnania g√≥r
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Utw√≥rz materia≈Çy podglƒÖdu
            var previewMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                metalness: 0.5,
                roughness: 0.5,
                transparent: true,
                opacity: 0.4
            });

            var sourceModel = loadedModels.sciskany || loadedModels.uchwyt;
            if (!sourceModel) return;

            // Okre≈õl kt√≥re drabiny pokazaƒá - obie przy attyce
            var laddersToPreview = [1];
            if (handrailType === 'attic') {
                laddersToPreview.push(2);
            }

            // Generuj podglƒÖd dla ka≈ºdej drabiny
            for (var ladderIdx = 0; ladderIdx < laddersToPreview.length; ladderIdx++) {
                var ladderNum = laddersToPreview[ladderIdx];
                var sections = getLadderSectionsForLadder(ladderNum);
                if (sections.length === 0) continue;

                var ladderTotalHeight = getTotalHeightForLadder(ladderNum);
                var geoConfig = ladderGeometryConfig[ladderNum];

                // Generuj pozycje podglƒÖdu dla tej drabiny
                var previewPositions = [];
                var currentOffset = 0;

                for (var s = 0; s < sections.length; s++) {
                    var section = sections[s];
                    var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);

                    for (var i = 0; i < section.rungs - 1; i++) {
                        var yPos = (maxHeight / 2) - currentOffset - DIMS.firstRungFromTop - (i * DIMS.rungSpacing) - DIMS.rungSpacing / 2;
                        if (isPositionValidForSciskane(yPos, ladderNum)) {
                            previewPositions.push(yPos);
                        }
                    }

                    currentOffset += sectionHeight;
                }

                // Utw√≥rz obiekty podglƒÖdu dla tej drabiny
                for (var p = 0; p < previewPositions.length; p++) {
                    var yPos = previewPositions[p];

                    // Lewy uchwyt
                    var leftRot = geoConfig.sciskane.left;
                    var leftPreview = sourceModel.clone(true);
                    leftPreview.scale.set(SCALE, SCALE, SCALE);
                    leftPreview.rotation.set(leftRot.x, leftRot.y, leftRot.z);
                    leftPreview.position.x = -railOffset * SCALE;
                    leftPreview.position.y = yPos * SCALE;
                    leftPreview.position.z = (geoConfig.sciskane.leftZOffset + geoConfig.zOffset) * SCALE;
                    leftPreview.traverse(function(child) {
                        if (child.isMesh) {
                            child.material = previewMaterial.clone();
                        }
                    });
                    leftPreview.userData.isSciskanePreview = true;
                    leftPreview.userData.previewY = yPos;
                    leftPreview.userData.previewSide = 'left';
                    leftPreview.userData.ladderNum = ladderNum;
                    ladderContainer.add(leftPreview);
                    sciskanePreviewObjects.push(leftPreview);

                    // Prawy uchwyt
                    var rightRot = geoConfig.sciskane.right;
                    var rightPreview = sourceModel.clone(true);
                    rightPreview.scale.set(SCALE, SCALE, SCALE);
                    rightPreview.rotation.set(rightRot.x, rightRot.y, rightRot.z);
                    rightPreview.position.x = railOffset * SCALE;
                    rightPreview.position.y = yPos * SCALE;
                    rightPreview.position.z = (geoConfig.sciskane.rightZOffset + geoConfig.zOffset) * SCALE;
                    rightPreview.traverse(function(child) {
                        if (child.isMesh) {
                            child.material = previewMaterial.clone();
                        }
                    });
                    rightPreview.userData.isSciskanePreview = true;
                    rightPreview.userData.previewY = yPos;
                    rightPreview.userData.previewSide = 'right';
                    rightPreview.userData.ladderNum = ladderNum;
                    ladderContainer.add(rightPreview);
                    sciskanePreviewObjects.push(rightPreview);
                }
            }
        }

        function clearSciskanePreview() {
            for (var i = 0; i < sciskanePreviewObjects.length; i++) {
                if (sciskanePreviewObjects[i].parent === ladderContainer) {
                    ladderContainer.remove(sciskanePreviewObjects[i]);
                }
            }
            sciskanePreviewObjects = [];
        }

        function addSciskaneHandle(yPos, ladderNum) {
            // U≈ºyj podanego numeru drabiny lub aktualnie edytowanej
            var targetLadder = ladderNum || currentLadder;
            var currentHandles = (targetLadder === 1) ? sciskaneHandles1 : sciskaneHandles2;
            var ladderTotalHeight = getTotalHeightForLadder(targetLadder);

            // Oblicz maxHeight dla wyr√≥wnania
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Przelicz Y na offset od DO≈ÅU drabiny
            // D√≥≈Ç tej drabiny = maxHeight/2 - ladderTotalHeight
            var offsetFromBottom = yPos - (maxHeight / 2 - ladderTotalHeight);

            // Sprawd≈∫ czy ju≈º nie ma pary w tym miejscu
            var existingIndex = -1;
            for (var i = 0; i < currentHandles.length; i++) {
                if (currentHandles[i].offsetFromBottom === offsetFromBottom) {
                    existingIndex = i;
                    break;
                }
            }

            if (existingIndex >= 0) {
                // Ju≈º istnieje - nie usuwamy (toggle wy≈ÇƒÖczony, edycja przez panel)
                return;
            } else {
                // Dodaj nowƒÖ parƒô (zapisujemy offset od do≈Çu z domy≈õlnymi ustawieniami)
                currentHandles.push({
                    offsetFromBottom: offsetFromBottom,
                    connType: 'sciskany',
                    wspornikType: 'krotki',
                    wspornikDistance: 215
                });
            }

            // Zapisz do odpowiedniej drabiny
            if (targetLadder === 1) {
                sciskaneHandles1 = currentHandles;
            } else {
                sciskaneHandles2 = currentHandles;
            }

            // createLadder() automatycznie wywo≈Çuje renderSciskaneHandles() i createSciskanePreview()
            createLadder();
        }

        // Oblicz offsetFromBottom dla ostatniej pozycji sciskane w ko≈Ñcowej
        function getLastSciskaneOffsetForKoncowa(rungs) {
            var koncowaHeight = DIMS.railHeights[rungs];
            var actualRungs = (rungs === '7alt') ? 7 : rungs;
            // Ostatnia pozycja (i = rungs - 2): koncowaHeight - firstRungFromTop - ((rungs-2) * rungSpacing) - rungSpacing/2
            return koncowaHeight - DIMS.firstRungFromTop - ((actualRungs - 2) * DIMS.rungSpacing) - DIMS.rungSpacing / 2;
        }

        // Usu≈Ñ automatycznie dodane uchwyty z listy
        function removeAutoAddedSciskane(handles) {
            for (var i = handles.length - 1; i >= 0; i--) {
                if (handles[i].autoAdded) {
                    handles.splice(i, 1);
                }
            }
        }

        // Automatycznie dodaj uchwyt sciskany dla ko≈Ñcowej x5, x6, x7alt
        function autoAddSciskaneForKoncowa(rungs, ladderNum, handles) {
            // Najpierw usu≈Ñ poprzednie auto-dodane uchwyty
            removeAutoAddedSciskane(handles);

            // Tylko dla x5, x6, x7alt
            if (rungs !== 5 && rungs !== 6 && rungs !== '7alt') return;

            var offset = getLastSciskaneOffsetForKoncowa(rungs);

            // Sprawd≈∫ czy ju≈º nie ma uchwytu w tej pozycji (dodanego przez u≈ºytkownika)
            for (var i = 0; i < handles.length; i++) {
                if (Math.abs(handles[i].offsetFromBottom - offset) < 1) {
                    return; // U≈ºytkownik ju≈º doda≈Ç w tym miejscu
                }
            }

            // Dodaj automatycznie z flagƒÖ i domy≈õlnymi ustawieniami
            handles.push({
                offsetFromBottom: offset,
                autoAdded: true,
                connType: 'sciskany',
                wspornikType: 'krotki',
                wspornikDistance: 215
            });
        }

        function renderSciskaneHandles() {
            // Wyczy≈õƒá poprzednie (ju≈º usuniƒôte przez createLadder, ale czy≈õcimy tablicƒô)
            sciskanePlacedObjects = [];

            var railOffset = 265;

            // Okre≈õl kt√≥re drabiny renderowaƒá
            var laddersToRender = [1];
            if (handrailType === 'attic') {
                laddersToRender.push(2);
            }

            // Oblicz maksymalnƒÖ wysoko≈õƒá dla wyr√≥wnania g√≥r
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Renderuj uchwyty dla ka≈ºdej drabiny osobno
            for (var ladderIdx = 0; ladderIdx < laddersToRender.length; ladderIdx++) {
                var ladderNum = laddersToRender[ladderIdx];
                var geoConfig = ladderGeometryConfig[ladderNum];
                var ladderHandles = (ladderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                var ladderTotalHeight = getTotalHeightForLadder(ladderNum);

                // Filtruj uchwyty - usu≈Ñ te poza zakresem drabiny
                if (ladderNum === 1) {
                    sciskaneHandles1 = sciskaneHandles1.filter(function(handle) {
                        return handle.offsetFromBottom >= 50 && handle.offsetFromBottom <= ladderTotalHeight - 50;
                    });
                    ladderHandles = sciskaneHandles1;
                } else {
                    sciskaneHandles2 = sciskaneHandles2.filter(function(handle) {
                        return handle.offsetFromBottom >= 50 && handle.offsetFromBottom <= ladderTotalHeight - 50;
                    });
                    ladderHandles = sciskaneHandles2;
                }

                for (var i = 0; i < ladderHandles.length; i++) {
                    var handle = ladderHandles[i];
                    // Przelicz offset od do≈Çu na rzeczywistƒÖ pozycjƒô Y (wyr√≥wnane g√≥rƒÖ)
                    var actualY = (maxHeight / 2) - ladderTotalHeight + handle.offsetFromBottom;

                    // Pobierz typ ≈ÇƒÖcznika (sciskany lub uchwyt)
                    var connType = handle.connType || 'sciskany';
                    var sourceModel;
                    var leftRot, rightRot, leftZOffset, rightZOffset;

                    if (connType === 'uchwyt') {
                        sourceModel = loadedModels.uchwyt;
                        // Dla uchwyt u≈ºywamy rotacji z connector, nie sciskane
                        var connectorRot = geoConfig.connector;
                        leftRot = { x: connectorRot.left.x, y: connectorRot.left.y, z: connectorRot.left.z + Math.PI * -0.5 + Math.PI };
                        rightRot = { x: connectorRot.right.x, y: connectorRot.right.y, z: connectorRot.right.z + Math.PI * -0.5 + Math.PI };
                        leftZOffset = -62.5 + geoConfig.zOffset + geoConfig.connector.uchwytZOffset;
                        rightZOffset = -62.5 + geoConfig.zOffset + geoConfig.connector.uchwytZOffset;
                    } else {
                        sourceModel = loadedModels.sciskany || loadedModels.uchwyt;
                        leftRot = geoConfig.sciskane.left;
                        rightRot = geoConfig.sciskane.right;
                        leftZOffset = geoConfig.sciskane.leftZOffset + geoConfig.zOffset;
                        rightZOffset = geoConfig.sciskane.rightZOffset + geoConfig.zOffset;
                    }

                    if (!sourceModel) continue;

                    // Lewy uchwyt
                    var leftModel = sourceModel.clone(true);
                    leftModel.scale.set(SCALE, SCALE, SCALE);
                    leftModel.rotation.set(leftRot.x, leftRot.y, leftRot.z);
                    leftModel.position.x = (connType === 'uchwyt' ? -railOffset + 15 - 15 : -railOffset) * SCALE;
                    leftModel.position.y = actualY * SCALE;
                    leftModel.position.z = leftZOffset * SCALE;
                    leftModel.userData.isSciskanePlaced = true;
                    leftModel.userData.sciskaneOffsetFromBottom = handle.offsetFromBottom;
                    leftModel.userData.ladderNum = ladderNum;
                    ladderContainer.add(leftModel);
                    sciskanePlacedObjects.push(leftModel);

                    // Prawy uchwyt
                    var rightModel = sourceModel.clone(true);
                    rightModel.scale.set(SCALE, SCALE, SCALE);
                    rightModel.rotation.set(rightRot.x, rightRot.y, rightRot.z);
                    rightModel.position.x = (connType === 'uchwyt' ? railOffset - 15 + 15 : railOffset) * SCALE;
                    rightModel.position.y = actualY * SCALE;
                    rightModel.position.z = rightZOffset * SCALE;
                    rightModel.userData.isSciskanePlaced = true;
                    rightModel.userData.sciskaneOffsetFromBottom = handle.offsetFromBottom;
                    rightModel.userData.ladderNum = ladderNum;
                    ladderContainer.add(rightModel);
                    sciskanePlacedObjects.push(rightModel);

                    // Wsporniki dla uchwytu ≈õciskanego
                    var defaultWspornik = (ladderNum === 1) ? defaultWspornik1 : defaultWspornik2;
                    var wspornikType = handle.wspornikType || defaultWspornik;

                    // Zapisz typ wspornika w handle je≈õli nie by≈Ç ustawiony
                    if (!handle.wspornikType && defaultWspornik !== 'none') {
                        handle.wspornikType = defaultWspornik;
                        wspornikType = defaultWspornik;
                    }

                    if (wspornikType && wspornikType !== 'none') {
                        // Oblicz custom distance offset
                        var customDistance = handle.wspornikDistance || wspornikDefaultDistances[wspornikType];
                        var defaultDist = wspornikDefaultDistances[wspornikType];
                        var distanceOffset = customDistance - defaultDist;
                        // Dla drabiny 1: wiƒôcej = bardziej ujemne Z, dla drabiny 2: wiƒôcej = bardziej dodatnie Z
                        var distanceZOffset = (ladderNum === 1) ? -distanceOffset : distanceOffset;

                        var leftWspornik = createWspornik(wspornikType, 'left', ladderNum);
                        if (leftWspornik) {
                            leftWspornik.position.x = (-railOffset + leftWspornik.userData.extraXOffset) * SCALE;
                            leftWspornik.position.y = (actualY + leftWspornik.userData.extraYOffset) * SCALE;
                            leftWspornik.position.z = (geoConfig.wspornik.zOffset + geoConfig.zOffset + leftWspornik.userData.extraZOffset + distanceZOffset) * SCALE;
                            leftWspornik.userData.isSciskaneWspornik = true;
                            leftWspornik.userData.sciskaneHandleIndex = i;
                            leftWspornik.userData.ladderNum = ladderNum;
                            ladderContainer.add(leftWspornik);
                            wspornikObjects.push(leftWspornik);
                        }

                        var rightWspornik = createWspornik(wspornikType, 'right', ladderNum);
                        if (rightWspornik) {
                            rightWspornik.position.x = (railOffset - rightWspornik.userData.extraXOffset) * SCALE;
                            rightWspornik.position.y = (actualY + rightWspornik.userData.extraYOffset) * SCALE;
                            rightWspornik.position.z = (geoConfig.wspornik.zOffset + geoConfig.zOffset + rightWspornik.userData.extraZOffset + distanceZOffset) * SCALE;
                            rightWspornik.userData.isSciskaneWspornik = true;
                            rightWspornik.userData.sciskaneHandleIndex = i;
                            rightWspornik.userData.ladderNum = ladderNum;
                            ladderContainer.add(rightWspornik);
                            wspornikObjects.push(rightWspornik);
                        }
                    }
                }
            }
        }

        // Renderuj kosz ochronny (obrƒôcze)
        // Oblicz maksymalnƒÖ liczbƒô obrƒôczy dla drabiny
        function getMaxHoopsForLadder(ladderNum) {
            var x7Count = (ladderNum === 1) ? numX7Ladders1 : numX7Ladders2;
            var finalRungs = (ladderNum === 1) ? finalLadderRungs1 : finalLadderRungs2;

            var maxHoops = 0;

            // Dla przej≈õcia przez attykƒô: bazowo 3
            if (handrailType === 'attic') {
                maxHoops = 3;
            }

            // Dla porƒôczy asekuracyjnych lub z podestem: bazowo 2
            if (handrailType === 'safety' || handrailType === 'platform') {
                maxHoops = 2;
            }

            // +3 za ka≈ºdƒÖ powielanƒÖ (x7)
            maxHoops += x7Count * 3;

            // Za ko≈ÑcowƒÖ:
            if (finalRungs === 1) {
                // x1: +0
            } else if (finalRungs >= 2 && finalRungs <= 3) {
                // x2-x3: +1
                maxHoops += 1;
            } else if (finalRungs >= 4 && finalRungs <= 6) {
                // x4-x6: +2
                maxHoops += 2;
            } else if (finalRungs === '7alt') {
                // x7alt: +3
                maxHoops += 3;
            }

            return maxHoops;
        }

        // Aktualizuj wy≈õwietlanie limitu obrƒôczy i wymu≈õ limit
        function updateCageCountDisplay() {
            var maxHoops1 = getMaxHoopsForLadder(1);
            var maxHoops2 = getMaxHoopsForLadder(2);

            // Wymu≈õ limity
            if (safetyCageCount1 > maxHoops1) safetyCageCount1 = maxHoops1;
            if (safetyCageCount2 > maxHoops2) safetyCageCount2 = maxHoops2;

            // Aktualizuj wy≈õwietlanie
            var count1El = document.getElementById('cageCount1');
            var count2El = document.getElementById('cageCount2');
            if (count1El) count1El.textContent = safetyCageCount1 + '/' + maxHoops1;
            if (count2El) count2El.textContent = safetyCageCount2 + '/' + maxHoops2;
        }

        function renderSafetyCage() {
            if (!loadedModels.obrecz) return;

            var hoopSpacing = 641.7;  // Odstƒôp miƒôdzy obrƒôczami w mm

            // Oblicz wysoko≈õci drabin
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Oblicz pozycjƒô startowƒÖ (g√≥ra porƒôczy/attyki/drabiny)
            var topPosition = maxHeight / 2;
            var firstHoopOffset;
            if (handrailType === 'safety' || handrailType === 'platform') {
                // G√≥ra porƒôczy asekuracyjnych / z podestem - 25mm
                topPosition += DIMS.handrailVertical;
                firstHoopOffset = 25;
            } else if (handrailType === 'attic') {
                // G√≥ra przej≈õcia przez attykƒô - 25mm
                topPosition += DIMS.atticRailHeight;
                firstHoopOffset = 25;
            } else {
                // Sama drabina - 294.3mm od g√≥ry
                firstHoopOffset = 294.3;
            }

            // Renderuj dla drabiny 1
            // Dla porƒôczy asekuracyjnych/attyki/podestu - renderuj nawet gdy height1=0 (bo sƒÖ porƒôcze na g√≥rze)
            var canRender1 = safetyCageCount1 > 0 && (height1 > 0 || handrailType === 'safety' || handrailType === 'platform' || handrailType === 'attic');
            if (canRender1) {
                var geoConfig1 = ladderGeometryConfig[1];
                for (var i = 0; i < safetyCageCount1; i++) {
                    var yPos = topPosition - firstHoopOffset - (i * hoopSpacing);

                    var hoop = loadedModels.obrecz.clone(true);
                    hoop.scale.set(SCALE, SCALE, SCALE);
                    hoop.rotation.x = Math.PI * 0.5;  // 180 stopni obr√≥t
                    hoop.rotation.z = geoConfig1.rotationZ;
                    hoop.position.x = 0;
                    hoop.position.y = yPos * SCALE;
                    hoop.position.z = (geoConfig1.zOffset + 241) * SCALE;  // 250-9mm
                    hoop.userData.isSafetyCage = true;
                    hoop.userData.ladderNum = 1;
                    ladderContainer.add(hoop);
                }
            }

            // Renderuj dla drabiny 2 (tylko przy attyce)
            // Dla attyki renderuj nawet gdy height2=0 (bo attyka jest na g√≥rze)
            var canRender2 = handrailType === 'attic' && safetyCageCount2 > 0;
            if (canRender2) {
                var geoConfig2 = ladderGeometryConfig[2];
                for (var i = 0; i < safetyCageCount2; i++) {
                    var yPos = topPosition - firstHoopOffset - (i * hoopSpacing);

                    var hoop = loadedModels.obrecz.clone(true);
                    hoop.scale.set(SCALE, SCALE, SCALE);
                    hoop.rotation.x = Math.PI * 0.5;  // 180 stopni obr√≥t
                    hoop.rotation.z = geoConfig2.rotationZ;
                    hoop.position.x = 0;
                    hoop.position.y = yPos * SCALE;
                    hoop.position.z = (geoConfig2.zOffset - 241) * SCALE;  // 250-9mm
                    hoop.userData.isSafetyCage = true;
                    hoop.userData.ladderNum = 2;
                    ladderContainer.add(hoop);
                }
            }

            // Funkcja obliczajƒÖca kƒÖtowniki dla danej ilo≈õci obrƒôczy
            function calculateAngleBrackets(hoopCount) {
                if (hoopCount <= 1) return [];  // 1 lub mniej obrƒôczy - brak kƒÖtownik√≥w
                if (hoopCount === 2) return [{ type: 'x2', startHoop: 0 }];
                if (hoopCount === 3) return [{ type: 'x3', startHoop: 0 }];

                // 4+ obrƒôczy - system zak≈Çadek
                var brackets = [];
                var coveredHoles = 0;
                var currentHoop = 0;
                var isFirst = true;

                while (coveredHoles < hoopCount) {
                    var remaining = hoopCount - coveredHoles;
                    var bracketType, holesAdded;

                    if (isFirst) {
                        // Pierwszy kƒÖtownik - zawsze dodaje pe≈ÇnƒÖ ilo≈õƒá otwor√≥w
                        if (remaining >= 4) {
                            bracketType = 'x4';
                            holesAdded = 4;
                        } else if (remaining === 3) {
                            bracketType = 'x3';
                            holesAdded = 3;
                        } else {
                            bracketType = 'x2';
                            holesAdded = 2;
                        }
                        isFirst = false;
                    } else {
                        // Kolejne kƒÖtowniki na zak≈Çadkƒô - dodajƒÖ o 1 mniej (bo 1 otw√≥r wsp√≥lny)
                        if (remaining >= 3) {
                            bracketType = 'x4';
                            holesAdded = 3;  // x4 na zak≈Çadkƒô = 3 nowe otwory
                        } else if (remaining === 2) {
                            bracketType = 'x3';
                            holesAdded = 2;  // x3 na zak≈Çadkƒô = 2 nowe otwory
                        } else {
                            bracketType = 'x2';
                            holesAdded = 1;  // x2 na zak≈Çadkƒô = 1 nowy otw√≥r
                        }
                    }

                    brackets.push({ type: bracketType, startHoop: currentHoop });
                    coveredHoles += holesAdded;

                    // Nastƒôpny kƒÖtownik startuje na zak≈Çadce
                    if (bracketType === 'x4') {
                        currentHoop += 3;  // x4 ma 4 otwory, zak≈Çadka na 4. otworze
                    } else if (bracketType === 'x3') {
                        currentHoop += 2;
                    } else {
                        currentHoop += 1;
                    }
                }

                return brackets;
            }

            // Funkcja renderujƒÖca kƒÖtowniki dla drabiny
            function renderAngleBrackets(hoopCount, ladderNum, topPos, firstOffset, spacing, geoConfig) {
                var brackets = calculateAngleBrackets(hoopCount);

                // 5 pozycji kƒÖtownik√≥w wok√≥≈Ç obrƒôczy (kƒÖty w stopniach od g√≥ry/otwarcia)
                var bracketAngles = [90, 135, 180, 225, 270];
                var hoopRadius = 332.5;  // promie≈Ñ obrƒôczy w mm

                for (var b = 0; b < brackets.length; b++) {
                    var bracket = brackets[b];

                    // Co drugi kƒÖtownik odsuniƒôty o 3mm od ≈õrodka (≈ºeby siƒô nie nak≈Çada≈Çy)
                    var radiusOffset = (b % 2 === 1) ? 3 : 0;
                    // x3/x4 majƒÖ wiƒôkszy promie≈Ñ o 7mm
                    var typeRadiusOffset = (bracket.type !== 'x2') ? 7 : 0;
                    var currentRadius = hoopRadius + radiusOffset + typeRadiusOffset;

                    // Dla ka≈ºdego kƒÖtownika dodaj 5 kopii wok√≥≈Ç obrƒôczy
                    for (var a = 0; a < bracketAngles.length; a++) {
                        var angle = bracketAngles[a];
                        // Dla drabiny 2 obr√≥ƒá kƒÖtowniki o 180 stopni
                        if (ladderNum === 2) {
                            angle += 180;
                        }
                        var angleRad = angle * Math.PI / 180;

                        var model;
                        if (bracket.type === 'x2' && loadedModels.katownikX2) {
                            model = loadedModels.katownikX2.clone(true);
                        } else if (bracket.type === 'x3' && loadedModels.katownikX3) {
                            model = loadedModels.katownikX3.clone(true);
                        } else if (bracket.type === 'x4' && loadedModels.katownikX4) {
                            model = loadedModels.katownikX4.clone(true);
                        }

                        if (model) {
                            // Pozycja Y: od obrƒôczy startowej w d√≥≈Ç
                            // R√≥≈ºne offsety dla r√≥≈ºnych typ√≥w kƒÖtownik√≥w
                            var bracketYOffset;
                            if (bracket.type === 'x4') {
                                bracketYOffset = 958;
                            } else if (bracket.type === 'x3') {
                                bracketYOffset = 958 - (spacing / 2);  // p√≥≈Ç skoku mniej
                            } else {  // x2
                                bracketYOffset = 958 - spacing;  // jeden skok mniej
                            }
                            var yPos = topPos - firstOffset - (bracket.startHoop * spacing) - bracketYOffset;

                            // Oblicz pozycjƒô X i Z na podstawie kƒÖta (z uwzglƒôdnieniem odsuniƒôcia co drugi)
                            // KƒÖt mierzony od g√≥ry (otwarcia) zgodnie z ruchem wskaz√≥wek zegara
                            var xOffset = -currentRadius * Math.sin(angleRad);
                            var zOffset = -currentRadius * Math.cos(angleRad);

                            model.scale.set(SCALE, SCALE, SCALE);

                            // Dodatkowe rotacje dla ka≈ºdej pozycji (w stopniach, konwertowane na radiany)
                            // Pozycje: 0=lewy(90¬∞), 1=dolny-lewy(135¬∞), 2=d√≥≈Ç(180¬∞), 3=dolny-prawy(225¬∞), 4=prawy(270¬∞)
                            var rotationsX4X3 = [90, 0, 270, 180, 90];  // dla x4 i x3 (1,3,5 +180¬∞)
                            var rotationsX2 = [-45, 225, 135, 45, -45];   // dla x2 (2: +90¬∞, 3: -90¬∞, 4: +90¬∞)

                            var extraRotation;
                            if (bracket.type === 'x2') {
                                extraRotation = rotationsX2[a] * Math.PI / 180;
                            } else {
                                extraRotation = rotationsX4X3[a] * Math.PI / 180;
                            }

                            // Obr√≥t: 90¬∞ w d√≥≈Ç (o≈õ X), potem obr√≥t wok√≥≈Ç Z + dodatkowa rotacja
                            model.rotation.order = 'XZY';
                            model.rotation.x = Math.PI / 2;  // 90¬∞ w d√≥≈Ç
                            model.rotation.z = angleRad + extraRotation;  // obr√≥t wok√≥≈Ç pionowej osi + dodatkowa rotacja

                            model.position.x = xOffset * SCALE;
                            model.position.y = yPos * SCALE;

                            // Pozycja Z: centrum obrƒôczy + offset - 50mm do przodu
                            // Wszystkie kƒÖtowniki przesuniƒôte o 15mm bli≈ºej drabiny
                            var bracketZOffset = 15;
                            if (ladderNum === 1) {
                                model.position.z = (geoConfig.zOffset + 241 - 50 - bracketZOffset + zOffset) * SCALE;
                            } else {
                                model.position.z = (geoConfig.zOffset - 241 + 50 + bracketZOffset + zOffset) * SCALE;
                            }

                            model.userData.isAngleBracket = true;
                            model.userData.ladderNum = ladderNum;
                            ladderContainer.add(model);
                        }
                    }
                }
            }

            // Renderuj kƒÖtowniki dla drabiny 1 (u≈ºywaj tego samego warunku co dla obrƒôczy)
            if (canRender1) {
                renderAngleBrackets(safetyCageCount1, 1, topPosition, firstHoopOffset, hoopSpacing, ladderGeometryConfig[1]);
            }

            // Renderuj kƒÖtowniki dla drabiny 2 (u≈ºywaj tego samego warunku co dla obrƒôczy)
            if (canRender2) {
                renderAngleBrackets(safetyCageCount2, 2, topPosition, firstHoopOffset, hoopSpacing, ladderGeometryConfig[2]);
            }
        }

        try {
            statusDiv.innerHTML = 'Inicjalizacja...';
            
            // Scena
            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Kamera
            var camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                500
            );
            camera.position.z = 50;
            camera.position.y = 0;
            camera.lookAt(0, 0, 0);
            
            // Renderer
            var renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Raycaster do klikania na obiekty
            raycaster = new THREE.Raycaster();

            // Swiatla
            var ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            var light1 = new THREE.DirectionalLight(0xffffff, 0.6);
            light1.position.set(10, 10, 10);
            scene.add(light1);
            
            var light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(-10, -10, -10);
            scene.add(light2);
            
            // Grupa obrotu i kontener na drabinkƒô
            var pivotGroup = new THREE.Group();
            scene.add(pivotGroup);
            var ladderContainer = new THREE.Group();
            pivotGroup.add(ladderContainer);
            
            // Materia≈Çy
            var railMaterial = new THREE.MeshStandardMaterial({
                color: modelColor,  // aktualny kolor
                metalness: 0.3,
                roughness: 0.5
            });

            var rungMaterial = new THREE.MeshStandardMaterial({
                color: modelColor,  // aktualny kolor
                metalness: 0.3,
                roughness: 0.5
            });

            // Materia≈Ç dla ceownik√≥w
            var connectorMaterial = new THREE.MeshStandardMaterial({
                color: modelColor,  // aktualny kolor
                metalness: 0.3,
                roughness: 0.5
            });
            
            // Funkcja tworzƒÖca ≈ÇƒÖcznik z modelu OBJ
            // type: 'uchwyt', 'lacznik' lub 'uchwytPoreczy'
            // side: 'left' lub 'right', ladderNum: 1 lub 2
            // isMidRung: true je≈õli to specjalny uchwyt miƒôdzy 2. a 3. szczeblem
            function createConnector(type, side, ladderNum, isMidRung) {
                type = type || 'uchwyt';
                side = side || 'left';
                ladderNum = ladderNum || 1;
                isMidRung = isMidRung || false;

                var sourceModel = null;
                if (type === 'lacznik' && loadedModels.lacznik) {
                    sourceModel = loadedModels.lacznik;
                } else if (type === 'uchwytPoreczy' && loadedModels.uchwytPoreczy) {
                    sourceModel = loadedModels.uchwytPoreczy;
                } else if (type === 'sciskany' && loadedModels.sciskany) {
                    sourceModel = loadedModels.sciskany;
                } else if (loadedModels.uchwyt) {
                    sourceModel = loadedModels.uchwyt;
                }

                if (sourceModel) {
                    var model = sourceModel.clone(true);
                    model.scale.set(SCALE, SCALE, SCALE);

                    // Pobierz rotacjƒô z centralnej konfiguracji
                    var geoConfig = ladderGeometryConfig[ladderNum];
                    var rot = geoConfig.connector[side];

                    // Dla bryla400 (uchwyt): -90¬∞ + 180¬∞ = 90¬∞ (o≈õ Z po obrocie X)
                    var extraRotZ = 0;
                    if (type === 'uchwyt') {
                        extraRotZ = Math.PI * -0.5 + Math.PI;
                    }
                    model.rotation.set(rot.x, rot.y, rot.z + extraRotZ);

                    // Oznacz jako ≈ÇƒÖcznik (klikalny)
                    model.userData.isConnector = true;
                    model.userData.ladderNum = ladderNum;
                    model.userData.isMidRungBracket = isMidRung;
                    // Ustaw te≈º na wszystkich child'ach
                    model.traverse(function(child) {
                        child.userData.isConnector = true;
                        child.userData.ladderNum = ladderNum;
                        child.userData.isMidRungBracket = isMidRung;
                    });
                    connectorObjects.push(model);
                    return model;
                }

                // Fallback - pusty group je≈õli model nie za≈Çadowany
                // Ale dalej ustawiamy userData ≈ºeby klikniƒôcia dzia≈Ça≈Çy
                var fallbackGroup = new THREE.Group();
                fallbackGroup.userData.isConnector = true;
                fallbackGroup.userData.ladderNum = ladderNum;
                fallbackGroup.userData.isMidRungBracket = isMidRung;
                connectorObjects.push(fallbackGroup);
                return fallbackGroup;
            }

            // Funkcja tworzƒÖca wspornik z modelu OBJ
            // type: 'krotki', 'sredni', 'dlugi'
            // side: 'left' lub 'right', ladderNum: 1 lub 2
            function createWspornik(type, side, ladderNum, isMidRung) {
                type = type || 'krotki';
                side = side || 'left';
                ladderNum = ladderNum || 1;
                isMidRung = isMidRung || false;

                var sourceModel = null;
                if (type === 'krotki' && loadedModels.wspornikKrotki) {
                    sourceModel = loadedModels.wspornikKrotki;
                } else if (type === 'sredni') {
                    // Zamienione miejscami: left u≈ºywa Prawy, right u≈ºywa Lewy
                    if (side === 'left' && loadedModels.wspornikSredniPrawy) {
                        sourceModel = loadedModels.wspornikSredniPrawy;
                    } else if (side === 'right' && loadedModels.wspornikSredniLewy) {
                        sourceModel = loadedModels.wspornikSredniLewy;
                    }
                } else if (type === 'dlugi') {
                    if (side === 'left' && loadedModels.wspornikDlugiLewy) {
                        sourceModel = loadedModels.wspornikDlugiLewy;
                    } else if (side === 'right' && loadedModels.wspornikDlugiPrawy) {
                        sourceModel = loadedModels.wspornikDlugiPrawy;
                    }
                }

                if (sourceModel) {
                    var model = sourceModel.clone(true);
                    model.scale.set(SCALE, SCALE, SCALE);

                    // Pobierz rotacjƒô z centralnej konfiguracji
                    var geoConfig = ladderGeometryConfig[ladderNum];
                    var rot = geoConfig.wspornik[side];

                    // Dla d≈Çugich i ≈õrednich wspornik√≥w dodaj 90¬∞ do przodu (o≈õ X) - ORYGINA≈Å
                    // Dla kr√≥tkiego: -90¬∞ w g√≥rƒô + obr√≥t w Y (prawy w lewo, lewy w prawo)
                    // Dla prawego d≈Çugiego dodatkowo 180¬∞ (o≈õ Y)
                    var extraRotX = 0;
                    var extraRotY = 0;
                    if (type === 'dlugi' || type === 'sredni') {
                        extraRotX = Math.PI * 0.5;   // orygina≈Ç dla ≈õredniego i d≈Çugiego
                        if (type === 'dlugi' && side === 'right') {
                            extraRotY = Math.PI;    // orygina≈Ç dla prawego d≈Çugiego
                        }
                        if (type === 'sredni' && side === 'right') {
                            extraRotY = Math.PI;    // prawy ≈õredni: 180¬∞ w bok
                        }
                    } else if (type === 'krotki') {
                        extraRotX = Math.PI * -0.5;  // -90¬∞ w g√≥rƒô
                    }

                    // Dla kr√≥tkiego: dodatkowy obr√≥t w Z (lewy w prawo, prawy w lewo)
                    var extraRotZ = 0;
                    if (type === 'krotki') {
                        if (side === 'left') {
                            extraRotZ = Math.PI * 0.5 + Math.PI;   // lewy: 90¬∞ + 180¬∞ w bok
                        } else {
                            extraRotZ = Math.PI * -0.5;  // prawy: 90¬∞ w lewo
                        }
                    }
                    model.rotation.set(rot.x + extraRotX, rot.y + extraRotY, rot.z + extraRotZ);

                    // Oznacz jako wspornik (klikalny)
                    model.userData.isWspornik = true;
                    model.userData.wspornikType = type;
                    model.userData.ladderNum = ladderNum;
                    model.userData.isMidRungBracket = isMidRung;
                    // Ustaw te≈º na wszystkich child'ach
                    model.traverse(function(child) {
                        child.userData.isWspornik = true;
                        child.userData.ladderNum = ladderNum;
                        child.userData.isMidRungBracket = isMidRung;
                    });
                    // Dla d≈Çugich wspornik√≥w cofnij o 100mm, dla ≈õrednich o 50mm
                    model.userData.extraZOffset = (type === 'dlugi') ? -100 : ((type === 'sredni') ? -50 : 0);
                    model.userData.extraXOffset = (type === 'dlugi') ? -3 : ((type === 'sredni') ? -4 : ((type === 'krotki') ? -1.5 : 0));
                    model.userData.extraYOffset = (type === 'dlugi') ? (side === 'right' ? -19.5 : -19) : ((type === 'sredni') ? (side === 'right' ? -20 : -20) : ((type === 'krotki') ? (side === 'right' ? 0 : 0) : 0));
                    return model;
                }

                // Fallback - pusty group je≈õli model nie za≈Çadowany
                return null;
            }

            // Tablica do przechowywania obiekt√≥w wspornik√≥w
            var wspornikObjects = [];

            function createLadder() {
                // Wyczy≈õƒá poprzedniƒÖ drabinkƒô
                while(ladderContainer.children.length > 0) {
                    ladderContainer.remove(ladderContainer.children[0]);
                }
                // Wyczy≈õƒá listƒô ≈ÇƒÖcznik√≥w i wspornik√≥w
                connectorObjects = [];
                wspornikObjects = [];

                // Okre≈õl kt√≥re drabiny renderowaƒá
                var laddersToRender = [1];  // Zawsze drabina 1
                if (handrailType === 'attic') {
                    laddersToRender.push(2);  // Dodaj drabinƒô 2 przy attyce
                }

                // Oblicz wysoko≈õci obu drabin i znajd≈∫ najwy≈ºszƒÖ
                var height1 = getTotalHeightForLadder(1);
                var height2 = getTotalHeightForLadder(2);
                var maxHeight = Math.max(height1, height2);

                // Dla kompatybilno≈õci - u≈ºywamy alias√≥w lub drabiny 1
                var sections = getLadderSections();
                var totalHeight = getTotalHeight();

                // Generuj sekcje dla ka≈ºdej drabiny - WYR√ìWNANE G√ìRƒÑ
                for (var ladderIdx = 0; ladderIdx < laddersToRender.length; ladderIdx++) {
                    var ladderNum = laddersToRender[ladderIdx];
                    var geoConfig = ladderGeometryConfig[ladderNum];
                    var ladderSections = getLadderSectionsForLadder(ladderNum);
                    var ladderTotalHeight = getTotalHeightForLadder(ladderNum);

                    var currentHeightOffset = 0;

                    for (var s = 0; s < ladderSections.length; s++) {
                        var section = ladderSections[s];
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        var model = null;

                        var sourceModel = null;
                        if (section.type === 'standard' && loadedModels.powielana) {
                            sourceModel = loadedModels.powielana;
                        } else if (section.type === 'alt' && loadedModels.koncowa[7]) {
                            sourceModel = loadedModels.koncowa[7];
                        } else if (section.type === 'final' && loadedModels.koncowa[section.rungs]) {
                            sourceModel = loadedModels.koncowa[section.rungs];
                        }

                        if (sourceModel) {
                            // G≈Çƒôbokie klonowanie
                            model = sourceModel.clone(true);

                            // Rotacja o 270 stopni (model z Fusion360) + opcjonalny obr√≥t Z dla drabiny 2
                            model.rotation.x = Math.PI * 1.5;
                            model.rotation.z = geoConfig.rotationZ;

                            // Skalowanie: model w mm, Three.js w jednostkach (1 jednostka = 100mm)
                            model.scale.set(SCALE, SCALE, SCALE);

                            // Pozycja Y - obie drabiny zaczynajƒÖ od g√≥ry (maxHeight/2) i rosnƒÖ w d√≥≈Ç
                            // Najd≈Çu≈ºsza drabina definiuje Y=0 (jej ≈õrodek), kr√≥tsza ma g√≥ry na tym samym poziomie
                            var yPos = (maxHeight / 2) - currentHeightOffset - (sectionHeight / 2);
                            model.position.y = yPos * SCALE;
                            model.position.z = geoConfig.zOffset * SCALE;

                            // Oznacz do kt√≥rej drabiny nale≈ºy
                            model.userData.ladderNum = ladderNum;

                            ladderContainer.add(model);
                        }

                        currentHeightOffset += sectionHeight;
                    }
                }

                // U≈ºyj NAJWY≈ªSZEJ drabiny dla attyki i porƒôczy
                var totalHeight = maxHeight;

                var railOffset = 265;  // 265mm odstƒôp od ≈õrodka do wewnƒôtrznej krawƒôdzi profilu
                
                // Dodaj porƒôcze lub przej≈õcie przez attykƒô
                if (handrailType === 'safety') {
                    // PORƒòCZE ASEKURACYJNE - model 3D
                    var topOfLadder = (totalHeight / 2);

                    // Lewa porƒôcz
                    if (loadedModels.porecz) {
                        var leftPorecz = loadedModels.porecz.clone(true);
                        leftPorecz.scale.set(SCALE, SCALE, SCALE);
                        leftPorecz.rotation.set(Math.PI * 1.5, 0, Math.PI);  // +180 stopni w Z
                        leftPorecz.position.x = -railOffset * SCALE;
                        leftPorecz.position.y = (topOfLadder + DIMS.handrailVertical / 2) * SCALE;  // -50mm w d√≥≈Ç
                        leftPorecz.position.z = -245.5 * SCALE;  // 24.55cm do ty≈Çu
                        ladderContainer.add(leftPorecz);
                    }

                    // Prawa porƒôcz
                    if (loadedModels.porecz) {
                        var rightPorecz = loadedModels.porecz.clone(true);
                        rightPorecz.scale.set(SCALE, SCALE, SCALE);
                        rightPorecz.rotation.set(Math.PI * 1.5, 0, Math.PI);  // +180 stopni w Z
                        rightPorecz.position.x = railOffset * SCALE;
                        rightPorecz.position.y = (topOfLadder + DIMS.handrailVertical / 2) * SCALE;  // -50mm w d√≥≈Ç
                        rightPorecz.position.z = -245.5 * SCALE;  // 24.55cm do ty≈Çu
                        ladderContainer.add(rightPorecz);
                    }
                } else if (handrailType === 'platform') {
                    // PORƒòCZE Z PODESTEM - porƒôcze asekuracyjne + podest na g√≥rze
                    var topOfLadder = (totalHeight / 2);

                    // Lewa porƒôcz (tak jak safety)
                    if (loadedModels.porecz) {
                        var leftPorecz = loadedModels.porecz.clone(true);
                        leftPorecz.scale.set(SCALE, SCALE, SCALE);
                        leftPorecz.rotation.set(Math.PI * 1.5, 0, Math.PI);
                        leftPorecz.position.x = -railOffset * SCALE;
                        leftPorecz.position.y = (topOfLadder + DIMS.handrailVertical / 2) * SCALE;
                        leftPorecz.position.z = -245.5 * SCALE;
                        ladderContainer.add(leftPorecz);
                    }

                    // Prawa porƒôcz (tak jak safety)
                    if (loadedModels.porecz) {
                        var rightPorecz = loadedModels.porecz.clone(true);
                        rightPorecz.scale.set(SCALE, SCALE, SCALE);
                        rightPorecz.rotation.set(Math.PI * 1.5, 0, Math.PI);
                        rightPorecz.position.x = railOffset * SCALE;
                        rightPorecz.position.y = (topOfLadder + DIMS.handrailVertical / 2) * SCALE;
                        rightPorecz.position.z = -245.5 * SCALE;
                        ladderContainer.add(rightPorecz);
                    }

                    // Podest na g√≥rze (miƒôdzy porƒôczami)
                    if (loadedModels.podestKrotki) {
                        var podest = loadedModels.podestKrotki.clone(true);
                        podest.scale.set(SCALE, SCALE, SCALE);
                        podest.rotation.set(Math.PI * 1.5, 0, 0);
                        podest.position.x = 0;  // wy≈õrodkowane
                        podest.position.y = (topOfLadder + DIMS.handrailVertical / 2 - 536) * SCALE;  // 536mm w d√≥≈Ç
                        podest.position.z = -245.5 * SCALE;
                        ladderContainer.add(podest);
                    }
                } else if (handrailType === 'attic') {
                    // PRZEJ≈öCIE PRZEZ ATTYKƒò - jeden model 3D
                    var topOfMainRails = (totalHeight / 2);

                    if (loadedModels.attyka) {
                        var attyka = loadedModels.attyka.clone(true);
                        attyka.scale.set(SCALE, SCALE, SCALE);
                        attyka.rotation.set(Math.PI * 1.5, 0, 0);
                        attyka.position.x = 0;  // wy≈õrodkowane
                        attyka.position.y = (topOfMainRails + DIMS.atticRailHeight / 2) * SCALE;
                        attyka.position.z = -535 * SCALE;  // 53.5cm do ty≈Çu (+5mm do przodu)
                        ladderContainer.add(attyka);
                    }

                    // Krata WEMA
                    if (loadedModels.krataWema) {
                        var krata = loadedModels.krataWema.clone(true);
                        krata.scale.set(SCALE, SCALE, SCALE);
                        krata.rotation.set(Math.PI * 1.5, 0, 0);
                        krata.position.x = 0;
                        krata.position.y = (topOfMainRails + DIMS.atticRailHeight / 2 - 430) * SCALE;  // 43cm w d√≥≈Ç
                        krata.position.z = -535 * SCALE;  // 53.5cm do ty≈Çu (+5mm do przodu)
                        ladderContainer.add(krata);
                    }
                }
                
                // Dodaj ceowniki na wszystkich po≈ÇƒÖczeniach
                var railOffset = 265;  // 265mm odstƒôp od ≈õrodka

                // Generuj ≈ÇƒÖczniki dla ka≈ºdej drabiny osobno
                for (var connLadderIdx = 0; connLadderIdx < laddersToRender.length; connLadderIdx++) {
                    var connLadderNum = laddersToRender[connLadderIdx];
                    var connSections = getLadderSectionsForLadder(connLadderNum);
                    var connTotalHeight = getTotalHeightForLadder(connLadderNum);
                    var connConnectorTypes = getConnectorTypesForLadder(connLadderNum);
                    var connWspornikTypes = getWspornikTypesForLadder(connLadderNum);
                    var defaultWspornik = getDefaultWspornikForLadder(connLadderNum);

                    // Oblicz ile par ≈ÇƒÖcznik√≥w potrzebujemy dla tej drabiny
                    var numConnectorPairs = 0;
                    // G√≥rne ≈ÇƒÖczniki dla porƒôczy asekuracyjnych lub attyki (NIE dla podestu - podest je zastƒôpuje)
                    if ((handrailType === 'safety' || handrailType === 'attic') && connSections.length > 0) {
                        numConnectorPairs++;  // Para na g√≥rze
                    }
                    numConnectorPairs += Math.max(0, connSections.length - 1);  // Pary miƒôdzy sekcjami

                    // Inicjalizuj tablicƒô connectorTypes dla tej drabiny je≈õli trzeba
                    while (connConnectorTypes.length < numConnectorPairs) {
                        connConnectorTypes.push('uchwyt');
                    }
                    while (connConnectorTypes.length > numConnectorPairs) {
                        connConnectorTypes.pop();
                    }

                    // Inicjalizuj tablicƒô wspornikTypes dla tej drabiny
                    var globalDistance = (connLadderNum === 1) ? globalWspornikDistance1 : globalWspornikDistance2;
                    var connWspornikDistances = (connLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                    while (connWspornikTypes.length < numConnectorPairs) {
                        connWspornikTypes.push(defaultWspornik);
                    }
                    while (connWspornikTypes.length > numConnectorPairs) {
                        connWspornikTypes.pop();
                    }
                    // Inicjalizuj tablicƒô wspornikDistances dla tej drabiny
                    while (connWspornikDistances.length < numConnectorPairs) {
                        connWspornikDistances.push(globalDistance);
                    }
                    while (connWspornikDistances.length > numConnectorPairs) {
                        connWspornikDistances.pop();
                    }

                    var pairIndex = 0;

                    // 1. Ceownik na g√≥rze (je≈õli sƒÖ porƒôcze lub attyka, NIE dla podestu - podest zastƒôpuje ≈ÇƒÖczniki)
                    if ((handrailType === 'safety' || handrailType === 'attic') && connSections.length > 0) {
                        // G√≥ra jest wyr√≥wnana do maxHeight/2
                        var topY = (maxHeight / 2) - (DIMS.connectorHeight / 2) - 50;

                        // Przy porƒôczach u≈ºywamy uchwyt poreczy z innymi koordynatami
                        // Przy attyce u≈ºywamy zwyk≈Çe uchwyty z normalnymi koordynatami
                        var topConnectorType = (handrailType === 'safety') ? 'uchwytPoreczy' : connConnectorTypes[pairIndex];

                        var topConnectorZ, topConnectorYOffset;
                        if (handrailType === 'safety') {
                            topConnectorZ = 0;  // uchwyt porƒôczy
                            topConnectorYOffset = 100;  // 10cm do g√≥ry (55cm - 45cm)
                        } else {
                            // Attyka - takie same pozycje jak inne uchwyty, ale 10cm wy≈ºej
                            topConnectorZ = (topConnectorType === 'lacznik' ? 0 : -62.5);
                            topConnectorYOffset = 100;  // 10cm do g√≥ry (6cm + 4cm)
                        }

                        var geoConfig = ladderGeometryConfig[connLadderNum];
                        var topTypeZOffset = (topConnectorType === 'lacznik') ? geoConfig.connector.zOffset : geoConfig.connector.uchwytZOffset;
                        var leftConnectorTop = createConnector(topConnectorType, 'left', connLadderNum);
                        leftConnectorTop.position.x = (-railOffset + 15 - 15) * SCALE;
                        leftConnectorTop.position.y = (topY + topConnectorYOffset) * SCALE;
                        leftConnectorTop.position.z = (topConnectorZ + geoConfig.zOffset + topTypeZOffset) * SCALE;
                        leftConnectorTop.userData.pairIndex = pairIndex;
                        leftConnectorTop.userData.ladderNum = connLadderNum;
                        ladderContainer.add(leftConnectorTop);

                        var rightConnectorTop = createConnector(topConnectorType, 'right', connLadderNum);
                        rightConnectorTop.position.x = (railOffset - 15 + 15) * SCALE;
                        rightConnectorTop.position.y = (topY + topConnectorYOffset) * SCALE;
                        rightConnectorTop.position.z = (topConnectorZ + geoConfig.zOffset + topTypeZOffset) * SCALE;
                        rightConnectorTop.userData.pairIndex = pairIndex;
                        rightConnectorTop.userData.ladderNum = connLadderNum;
                        ladderContainer.add(rightConnectorTop);

                        // Wsporniki dla g√≥rnego uchwytu (tylko gdy to uchwyt, nie ≈ÇƒÖcznik ani uchwyt porƒôczy)
                        if (topConnectorType === 'uchwyt') {
                            var wspornikType = connWspornikTypes[pairIndex] || defaultWspornik;
                            if (wspornikType !== 'none') {
                                // Oblicz custom distance offset
                                var connWspornikDistances = (connLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                                var customDistance = connWspornikDistances[pairIndex] || wspornikDefaultDistances[wspornikType];
                                var defaultDist = wspornikDefaultDistances[wspornikType];
                                var distanceOffset = customDistance - defaultDist;
                                var distanceZOffset = (connLadderNum === 1) ? -distanceOffset : distanceOffset;

                                var leftWspornikTop = createWspornik(wspornikType, 'left', connLadderNum);
                                if (leftWspornikTop) {
                                    leftWspornikTop.position.x = (-railOffset + leftWspornikTop.userData.extraXOffset) * SCALE;
                                    leftWspornikTop.position.y = (topY + topConnectorYOffset + leftWspornikTop.userData.extraYOffset) * SCALE;
                                    leftWspornikTop.position.z = (geoConfig.wspornik.zOffset + geoConfig.zOffset + leftWspornikTop.userData.extraZOffset + distanceZOffset) * SCALE;
                                    leftWspornikTop.userData.pairIndex = pairIndex;
                                    leftWspornikTop.userData.ladderNum = connLadderNum;
                                    ladderContainer.add(leftWspornikTop);
                                    wspornikObjects.push(leftWspornikTop);
                                }

                                var rightWspornikTop = createWspornik(wspornikType, 'right', connLadderNum);
                                if (rightWspornikTop) {
                                    rightWspornikTop.position.x = (railOffset - rightWspornikTop.userData.extraXOffset) * SCALE;
                                    rightWspornikTop.position.y = (topY + topConnectorYOffset + rightWspornikTop.userData.extraYOffset) * SCALE;
                                    rightWspornikTop.position.z = (geoConfig.wspornik.zOffset + geoConfig.zOffset + rightWspornikTop.userData.extraZOffset + distanceZOffset) * SCALE;
                                    rightWspornikTop.userData.pairIndex = pairIndex;
                                    rightWspornikTop.userData.ladderNum = connLadderNum;
                                    ladderContainer.add(rightWspornikTop);
                                    wspornikObjects.push(rightWspornikTop);
                                }
                            }
                        }

                        pairIndex++;
                    }

                    // 2. Ceowniki miƒôdzy sekcjami drabin
                    var currentOffset = 0;
                    for (var i = 0; i < connSections.length; i++) {
                        var section = connSections[i];
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        currentOffset += sectionHeight;

                        if (i < connSections.length - 1) {
                            // Pozycja Y - ≈ÇƒÖczniki miƒôdzy sekcjami, liczone od g√≥ry
                            var connectionY = (maxHeight / 2) - currentOffset + (DIMS.connectorHeight / 2) - 50;
                            var connType = connConnectorTypes[pairIndex] || 'uchwyt';

                            var connGeoConfig = ladderGeometryConfig[connLadderNum];
                            var connTypeZOffset = (connType === 'lacznik') ? connGeoConfig.connector.zOffset : connGeoConfig.connector.uchwytZOffset;
                            var leftConn = createConnector(connType, 'left', connLadderNum);
                            leftConn.position.x = (-railOffset + 15 - 15) * SCALE;
                            leftConn.position.y = connectionY * SCALE;
                            leftConn.position.z = ((connType === 'lacznik' ? 0 : -62.5) + connGeoConfig.zOffset + connTypeZOffset) * SCALE;
                            leftConn.userData.pairIndex = pairIndex;
                            leftConn.userData.ladderNum = connLadderNum;
                            ladderContainer.add(leftConn);

                            var rightConn = createConnector(connType, 'right', connLadderNum);
                            rightConn.position.x = (railOffset - 15 + 15) * SCALE;
                            rightConn.position.y = connectionY * SCALE;
                            rightConn.position.z = ((connType === 'lacznik' ? 0 : -62.5) + connGeoConfig.zOffset + connTypeZOffset) * SCALE;
                            rightConn.userData.pairIndex = pairIndex;
                            rightConn.userData.ladderNum = connLadderNum;
                            ladderContainer.add(rightConn);

                            // Wsporniki dla uchwytu miƒôdzy sekcjami (tylko gdy to uchwyt, nie ≈ÇƒÖcznik)
                            if (connType === 'uchwyt') {
                                var wspornikType = connWspornikTypes[pairIndex] || defaultWspornik;
                                if (wspornikType !== 'none') {
                                    // Oblicz custom distance offset
                                    var midWspornikDistances = (connLadderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                                    var customDistance = midWspornikDistances[pairIndex] || wspornikDefaultDistances[wspornikType];
                                    var defaultDist = wspornikDefaultDistances[wspornikType];
                                    var distanceOffset = customDistance - defaultDist;
                                    var distanceZOffset = (connLadderNum === 1) ? -distanceOffset : distanceOffset;

                                    var leftWspornik = createWspornik(wspornikType, 'left', connLadderNum);
                                    if (leftWspornik) {
                                        leftWspornik.position.x = (-railOffset + leftWspornik.userData.extraXOffset) * SCALE;
                                        leftWspornik.position.y = (connectionY + leftWspornik.userData.extraYOffset) * SCALE;
                                        leftWspornik.position.z = (connGeoConfig.wspornik.zOffset + connGeoConfig.zOffset + leftWspornik.userData.extraZOffset + distanceZOffset) * SCALE;
                                        leftWspornik.userData.pairIndex = pairIndex;
                                        leftWspornik.userData.ladderNum = connLadderNum;
                                        ladderContainer.add(leftWspornik);
                                        wspornikObjects.push(leftWspornik);
                                    }

                                    var rightWspornik = createWspornik(wspornikType, 'right', connLadderNum);
                                    if (rightWspornik) {
                                        rightWspornik.position.x = (railOffset - rightWspornik.userData.extraXOffset) * SCALE;
                                        rightWspornik.position.y = (connectionY + rightWspornik.userData.extraYOffset) * SCALE;
                                        rightWspornik.position.z = (connGeoConfig.wspornik.zOffset + connGeoConfig.zOffset + rightWspornik.userData.extraZOffset + distanceZOffset) * SCALE;
                                        rightWspornik.userData.pairIndex = pairIndex;
                                        rightWspornik.userData.ladderNum = connLadderNum;
                                        ladderContainer.add(rightWspornik);
                                        wspornikObjects.push(rightWspornik);
                                    }
                                }
                            }

                            pairIndex++;
                        }
                    }
                }

                // 3. Specjalny uchwyt miƒôdzy 2. a 3. szczeblem (tylko dla none, safety, platform - NIE attic)
                if (handrailType !== 'attic') {
                    for (var bracketLadderIdx = 0; bracketLadderIdx < laddersToRender.length; bracketLadderIdx++) {
                        var bracketLadderNum = laddersToRender[bracketLadderIdx];
                        var bracketSections = getLadderSectionsForLadder(bracketLadderNum);

                        // Sprawd≈∫ czy uchwyt jest w≈ÇƒÖczony dla tej drabiny
                        var midRungBracketEnabled = (bracketLadderNum === 1) ? midRungBracket1 : midRungBracket2;

                        if (midRungBracketEnabled && bracketSections.length > 0) {
                            var bracketGeoConfig = ladderGeometryConfig[bracketLadderNum];

                            // Pozycja Y: miƒôdzy 2. a 3. szczeblem od g√≥ry
                            // 2. szczebel: 136 + 275 = 411mm od g√≥ry
                            // 3. szczebel: 136 + 550 = 686mm od g√≥ry
                            // ≈örodek: 548.5mm od g√≥ry drabiny
                            var midRungY = (maxHeight / 2) - 548.5;

                            // Pobierz typ ≈ÇƒÖcznika dla tej drabiny (uchwyt lub sciskany)
                            var midRungConnType = (bracketLadderNum === 1) ? midRungBracketConnType1 : midRungBracketConnType2;

                            // Renderuj lewy i prawy uchwyt/sciskany (isMidRung = true)
                            var leftMidConn = createConnector(midRungConnType, 'left', bracketLadderNum, true);
                            leftMidConn.position.x = (-railOffset + 15 - 15) * SCALE;
                            leftMidConn.position.y = midRungY * SCALE;
                            leftMidConn.position.z = (-62.5 + bracketGeoConfig.zOffset + bracketGeoConfig.connector.uchwytZOffset) * SCALE;
                            ladderContainer.add(leftMidConn);

                            var rightMidConn = createConnector(midRungConnType, 'right', bracketLadderNum, true);
                            rightMidConn.position.x = (railOffset - 15 + 15) * SCALE;
                            rightMidConn.position.y = midRungY * SCALE;
                            rightMidConn.position.z = (-62.5 + bracketGeoConfig.zOffset + bracketGeoConfig.connector.uchwytZOffset) * SCALE;
                            ladderContainer.add(rightMidConn);

                            // Wsporniki dla tego uchwytu
                            var midWspornikType = (bracketLadderNum === 1) ? midRungBracketWspornikType1 : midRungBracketWspornikType2;
                            var midWspornikDistance = (bracketLadderNum === 1) ? midRungBracketDistance1 : midRungBracketDistance2;

                            if (midWspornikType !== 'none') {
                                var defaultDist = wspornikDefaultDistances[midWspornikType];
                                var distanceOffset = midWspornikDistance - defaultDist;
                                var distanceZOffset = (bracketLadderNum === 1) ? -distanceOffset : distanceOffset;

                                var leftMidWspornik = createWspornik(midWspornikType, 'left', bracketLadderNum, true);
                                if (leftMidWspornik) {
                                    leftMidWspornik.position.x = (-railOffset + leftMidWspornik.userData.extraXOffset) * SCALE;
                                    leftMidWspornik.position.y = (midRungY + leftMidWspornik.userData.extraYOffset) * SCALE;
                                    leftMidWspornik.position.z = (bracketGeoConfig.wspornik.zOffset + bracketGeoConfig.zOffset + leftMidWspornik.userData.extraZOffset + distanceZOffset) * SCALE;
                                    ladderContainer.add(leftMidWspornik);
                                    wspornikObjects.push(leftMidWspornik);
                                }

                                var rightMidWspornik = createWspornik(midWspornikType, 'right', bracketLadderNum, true);
                                if (rightMidWspornik) {
                                    rightMidWspornik.position.x = (railOffset - rightMidWspornik.userData.extraXOffset) * SCALE;
                                    rightMidWspornik.position.y = (midRungY + rightMidWspornik.userData.extraYOffset) * SCALE;
                                    rightMidWspornik.position.z = (bracketGeoConfig.wspornik.zOffset + bracketGeoConfig.zOffset + rightMidWspornik.userData.extraZOffset + distanceZOffset) * SCALE;
                                    ladderContainer.add(rightMidWspornik);
                                    wspornikObjects.push(rightMidWspornik);
                                }
                            }
                        }
                    }
                }

                // Aktualizuj listƒô ≈ÇƒÖcznik√≥w w UI
                updateConnectorList();

                // Renderuj umieszczone uchwyty ≈õciskane
                renderSciskaneHandles();

                // Aktualizuj limity i wy≈õwietlanie obrƒôczy
                updateCageCountDisplay();

                // Renderuj kosz ochronny (obrƒôcze)
                if (safetyCageCount1 > 0 || safetyCageCount2 > 0) {
                    renderSafetyCage();
                    // Sprawd≈∫ kolizje z obrƒôczami
                    var collisions = checkCageCollisions();
                    showCollisionWarning(collisions);
                } else {
                    // Ukryj ostrze≈ºenie je≈õli nie ma kosza
                    document.getElementById('collisionWarning').style.display = 'none';
                }

                // Odtw√≥rz podglƒÖd uchwyt√≥w ≈õciskanych je≈õli tryb aktywny
                if (sciskaneMode) {
                    createSciskanePreview();
                }

                ladderContainer.position.y = 0;
                updateStatus();
            }
            
            function updateStatus() {
                // U≈ºyj danych aktualnie edytowanej drabiny
                syncLadderAliases();
                var totalHeight = getTotalHeightForLadder(currentLadder);
                var statusText = '';

                // Poka≈º kt√≥ra drabina jest edytowana przy attyce
                if (handrailType === 'attic') {
                    statusText = '[Drabina ' + currentLadder + '] ';
                }

                if (numX7Ladders === 0 && finalLadderRungs === 0) {
                    statusText += 'Brak drabin';
                } else if (numX7Ladders === 0 && finalLadderRungs === '7alt') {
                    statusText += 'Drabinka x7 ALT (1825mm)';
                } else if (numX7Ladders === 0) {
                    statusText += 'Drabinka x' + finalLadderRungs;
                } else if (numX7Ladders === 1 && finalLadderRungs === 0) {
                    statusText += 'Drabinka x7';
                } else if (numX7Ladders > 1 && finalLadderRungs === 0) {
                    statusText += numX7Ladders + 'x drabinka x7';
                } else if (numX7Ladders === 1 && finalLadderRungs === '7alt') {
                    statusText += 'Drabinka x7 + x7 ALT';
                } else if (numX7Ladders === 1) {
                    statusText += 'Drabinka x7 + x' + finalLadderRungs;
                } else if (finalLadderRungs === '7alt') {
                    statusText += numX7Ladders + 'x drabinka x7 + x7 ALT';
                } else {
                    statusText += numX7Ladders + 'x drabinka x7 + x' + finalLadderRungs;
                }

                if (totalHeight > 0) {
                    statusText += ' (' + totalHeight + 'mm)';
                }

                statusDiv.innerHTML = statusText;
            }

            // Funkcja aktualizujƒÖca listƒô ≈ÇƒÖcznik√≥w w UI
            function updateConnectorList() {
                // Standardowa lista (tylko dla trybu BEZ attyki)
                if (handrailType !== 'attic') {
                    var listContainer = document.getElementById('connectorList');
                    if (listContainer) {
                        var currentConnectorTypes = getConnectorTypesForLadder(currentLadder);
                        var html = '';
                        for (var i = 0; i < currentConnectorTypes.length; i++) {
                            var label = (i === 0 && handrailType === 'safety') ? 'G√≥rna para' : '≈ÅƒÖczenie ' + (i + 1);
                            if (handrailType === 'safety' && i === 0) {
                                html += '<div class="connector-item"><span>' + label + ':</span> <span>Uchwyt porƒôczy</span></div>';
                            } else {
                                html += '<div class="connector-item">';
                                html += '<span>' + label + ':</span> ';
                                html += '<select onchange="changeConnectorType(' + i + ', this.value, ' + currentLadder + ')">';
                                html += '<option value="uchwyt"' + (currentConnectorTypes[i] === 'uchwyt' ? ' selected' : '') + '>Uchwyt</option>';
                                html += '<option value="lacznik"' + (currentConnectorTypes[i] === 'lacznik' ? ' selected' : '') + '>≈ÅƒÖcznik</option>';
                                html += '</select>';
                                html += '</div>';
                            }
                        }
                        listContainer.innerHTML = html;
                    }
                }

                // Listy dla trybu attyki (tylko gdy attyka w≈ÇƒÖczona)
                if (handrailType === 'attic') {
                    // Lista dla Drabiny 1 (u≈ºywa tego samego elementu co tryb standardowy)
                    var list1 = document.getElementById('connectorList');
                    if (list1) {
                        var types1 = getConnectorTypesForLadder(1);
                        var html1 = '';
                        for (var i = 0; i < types1.length; i++) {
                            var label = (i === 0) ? 'G√≥ra' : '≈ÅƒÖcz. ' + i;
                            html1 += '<div style="margin: 3px 0; display: flex; justify-content: space-between; align-items: center;">';
                            html1 += '<span style="color: #4CAF50;">' + label + ':</span> ';
                            html1 += '<select onchange="changeConnectorType(' + i + ', this.value, 1)" style="padding: 2px; background: #333; color: white; border: 1px solid #4CAF50; border-radius: 3px; font-size: 11px;">';
                            html1 += '<option value="uchwyt"' + (types1[i] === 'uchwyt' ? ' selected' : '') + '>Uchwyt</option>';
                            html1 += '<option value="lacznik"' + (types1[i] === 'lacznik' ? ' selected' : '') + '>≈ÅƒÖcznik</option>';
                            html1 += '</select>';
                            html1 += '</div>';
                        }
                        list1.innerHTML = html1;
                    }

                    // Lista dla Drabiny 2
                    var list2 = document.getElementById('connectorList2');
                    if (list2) {
                        var types2 = getConnectorTypesForLadder(2);
                        var html2 = '';
                        for (var i = 0; i < types2.length; i++) {
                            var label = (i === 0) ? 'G√≥ra' : '≈ÅƒÖcz. ' + i;
                            html2 += '<div style="margin: 3px 0; display: flex; justify-content: space-between; align-items: center;">';
                            html2 += '<span style="color: #2196F3;">' + label + ':</span> ';
                            html2 += '<select onchange="changeConnectorType(' + i + ', this.value, 2)" style="padding: 2px; background: #333; color: white; border: 1px solid #2196F3; border-radius: 3px; font-size: 11px;">';
                            html2 += '<option value="uchwyt"' + (types2[i] === 'uchwyt' ? ' selected' : '') + '>Uchwyt</option>';
                            html2 += '<option value="lacznik"' + (types2[i] === 'lacznik' ? ' selected' : '') + '>≈ÅƒÖcznik</option>';
                            html2 += '</select>';
                            html2 += '</div>';
                        }
                        list2.innerHTML = html2;
                    }
                }

                // Aktualizuj pozycjƒô przycisku oczka
                setTimeout(function() {
                    window.dispatchEvent(new Event('resize'));
                }, 50);
            }

            // Funkcja zmieniajƒÖca typ ≈ÇƒÖcznika
            function changeConnectorType(index, type, ladderNum) {
                // Zapisz do wskazanej drabiny
                ladderNum = ladderNum || currentLadder;
                if (ladderNum === 1) {
                    connectorTypes1[index] = type;
                } else {
                    connectorTypes2[index] = type;
                }
                createLadder();
            }

            // Inicjalizacja - ≈Çadujemy modele, potem tworzymy drabinkƒô
            statusDiv.innerHTML = '≈Åadowanie modeli 3D...';
            loadAllModels(function() {
                statusDiv.innerHTML = 'Modele za≈Çadowane!';
                createLadder();
            });
            
            // Funkcje dodawania/usuwania drabin
            function add7Ladder() {
                var x7Height = getLadderHeight(7);  // 1922mm
                // Przesu≈Ñ uchwyty ≈õciskane w d√≥≈Ç o wysoko≈õƒá nowej x7
                for (var i = 0; i < sciskaneHandles.length; i++) {
                    sciskaneHandles[i].offsetFromBottom += x7Height;
                }
                numX7Ladders++;
                saveLadderAliases();  // Zapisz zmiany do aktualnej drabiny
                createLadder();
            }

            function remove7Ladder() {
                if (numX7Ladders <= 0) {
                    statusDiv.innerHTML = 'Brak drabin x7 do usuniƒôcia!';
                    statusDiv.style.color = 'red';
                    setTimeout(function() {
                        statusDiv.style.color = 'lime';
                        updateStatus();
                    }, 1000);
                    return;
                }
                var x7Height = getLadderHeight(7);  // 1922mm
                // Przesu≈Ñ uchwyty ≈õciskane w g√≥rƒô o wysoko≈õƒá usuwanej x7
                for (var i = 0; i < sciskaneHandles.length; i++) {
                    sciskaneHandles[i].offsetFromBottom -= x7Height;
                }
                numX7Ladders--;
                saveLadderAliases();  // Zapisz zmiany do aktualnej drabiny
                createLadder();
            }
            
            // Zmiana ko≈Ñcowej drabinki (panel Drabina 1)
            document.getElementById('ladderSelect').addEventListener('change', function(e) {
                var value = e.target.value;
                var newValue = value === '0' ? 0 : (value === '7alt' ? '7alt' : parseInt(value));

                // Aktualizuj odpowiedniƒÖ zmiennƒÖ zale≈ºnie od trybu
                if (handrailType === 'attic') {
                    finalLadderRungs1 = newValue;
                    // Auto-dodaj uchwyt dla x5, x6, x7alt
                    autoAddSciskaneForKoncowa(newValue, 1, sciskaneHandles1);
                } else {
                    var hadKoncowa = (finalLadderRungs !== 0);
                    var oldKoncowaHeight = getKoncowaHeight();

                    finalLadderRungs = newValue;

                    var hasKoncowa = (finalLadderRungs !== 0);
                    var newKoncowaHeight = getKoncowaHeight();

                    // Korekta uchwyt√≥w ≈õciskanych
                    if (!hadKoncowa && hasKoncowa) {
                        for (var i = 0; i < sciskaneHandles.length; i++) {
                            sciskaneHandles[i].offsetFromBottom += newKoncowaHeight;
                        }
                    } else if (hadKoncowa && !hasKoncowa) {
                        for (var i = 0; i < sciskaneHandles.length; i++) {
                            sciskaneHandles[i].offsetFromBottom -= oldKoncowaHeight;
                        }
                    } else if (hadKoncowa && hasKoncowa) {
                        var heightDiff = newKoncowaHeight - oldKoncowaHeight;
                        for (var i = 0; i < sciskaneHandles.length; i++) {
                            sciskaneHandles[i].offsetFromBottom += heightDiff;
                        }
                    }
                    // Auto-dodaj uchwyt dla x5, x6, x7alt
                    autoAddSciskaneForKoncowa(newValue, 1, sciskaneHandles);
                    saveLadderAliases();
                }
                createLadder();
            });

            // Funkcja prze≈ÇƒÖczania miƒôdzy standardowymi kontrolkami a attykƒÖ
            function toggleAtticUI(isAttic) {
                var standardControls = document.getElementById('controls');
                var atticControlsTop = document.getElementById('atticControlsTop');
                var ladder1Title = document.getElementById('ladder1Title');
                var ladder2Panel = document.getElementById('ladder2Panel');
                var safetyCage2 = document.getElementById('safetyCage2');

                if (isAttic) {
                    // Ukryj standardowe przyciski, poka≈º attykowe
                    standardControls.style.display = 'none';
                    atticControlsTop.style.display = 'block';
                    // Poka≈º tytu≈Ç "Drabina 1" i panel drabiny 2
                    ladder1Title.style.display = 'block';
                    ladder2Panel.style.display = 'block';
                    safetyCage2.style.display = 'block';
                    // Synchronizuj warto≈õci dropdown√≥w
                    document.getElementById('ladderSelect').value = finalLadderRungs1 || '0';
                    document.getElementById('ladderSelect2').value = finalLadderRungs2 || '0';
                } else {
                    // Poka≈º standardowe przyciski, ukryj attykowe
                    standardControls.style.display = 'block';
                    atticControlsTop.style.display = 'none';
                    // Ukryj tytu≈Ç i panel drabiny 2
                    ladder1Title.style.display = 'none';
                    ladder2Panel.style.display = 'none';
                    safetyCage2.style.display = 'none';
                }
            }

            // Zmiana typu porƒôczy
            document.getElementById('handrailSelect').addEventListener('change', function(e) {
                handrailType = e.target.value;
                toggleAtticUI(handrailType === 'attic');
                // Aktualizuj pozycjƒô przycisku oczka po zmianie UI
                setTimeout(function() { window.dispatchEvent(new Event('resize')); }, 50);
                if (handrailType !== 'attic') {
                    switchToLadder(1);
                }
                createLadder();
            });

            // Przyciski kosz ochronny - Drabina 1
            document.getElementById('addCage1').addEventListener('click', function() {
                var maxHoops = getMaxHoopsForLadder(1);
                if (safetyCageCount1 < maxHoops) {
                    safetyCageCount1++;
                    document.getElementById('cageCount1').textContent = safetyCageCount1 + '/' + maxHoops;
                    createLadder();
                }
            });
            document.getElementById('removeCage1').addEventListener('click', function() {
                if (safetyCageCount1 > 0) {
                    safetyCageCount1--;
                    var maxHoops = getMaxHoopsForLadder(1);
                    document.getElementById('cageCount1').textContent = safetyCageCount1 + '/' + maxHoops;
                    createLadder();
                }
            });

            // Przyciski kosz ochronny - Drabina 2
            document.getElementById('addCage2').addEventListener('click', function() {
                var maxHoops = getMaxHoopsForLadder(2);
                if (safetyCageCount2 < maxHoops) {
                    safetyCageCount2++;
                    document.getElementById('cageCount2').textContent = safetyCageCount2 + '/' + maxHoops;
                    createLadder();
                }
            });
            document.getElementById('removeCage2').addEventListener('click', function() {
                if (safetyCageCount2 > 0) {
                    safetyCageCount2--;
                    var maxHoops = getMaxHoopsForLadder(2);
                    document.getElementById('cageCount2').textContent = safetyCageCount2 + '/' + maxHoops;
                    createLadder();
                }
            });

            // Zmiana koloru modeli
            document.getElementById('modelColorPicker').addEventListener('input', function() {
                var newColor = new THREE.Color(this.value);
                modelColor = newColor;
                if (!useGalvanizedTexture) {
                    scene.traverse(function(child) {
                        if (child.isMesh && child.material) {
                            child.material.color = newColor;
                        }
                    });
                }
            });

            // Prze≈ÇƒÖczanie tekstury ocynku
            document.getElementById('textureToggle').addEventListener('change', function() {
                useGalvanizedTexture = this.checked;
                var colorPicker = document.getElementById('modelColorPicker');
                colorPicker.disabled = useGalvanizedTexture;
                colorPicker.style.opacity = useGalvanizedTexture ? '0.5' : '1';

                // Pobierz aktualny kolor z pickera
                var pickerColor = new THREE.Color(colorPicker.value);

                scene.traverse(function(child) {
                    if (child.isMesh && child.material) {
                        if (useGalvanizedTexture) {
                            child.material.map = galvanizedTexture;
                            child.material.color = new THREE.Color(0xffffff);
                            child.material.metalness = 0.1;
                            child.material.roughness = 0.9;
                        } else {
                            child.material.map = null;
                            child.material.color = pickerColor;
                            child.material.metalness = 0.3;
                            child.material.roughness = 0.5;
                        }
                        child.material.needsUpdate = true;
                    }
                });
            });

            // Na start wy≈ÇƒÖcz color picker bo tekstura jest w≈ÇƒÖczona
            document.getElementById('modelColorPicker').disabled = true;
            document.getElementById('modelColorPicker').style.opacity = '0.5';

            // Przyciski dla Drabiny 1
            document.getElementById('add7Btn1').addEventListener('click', function() {
                numX7Ladders1++;
                createLadder();
            });
            document.getElementById('remove7Btn1').addEventListener('click', function() {
                if (numX7Ladders1 > 0) {
                    numX7Ladders1--;
                    createLadder();
                }
            });

            // Przyciski dla Drabiny 2
            document.getElementById('add7Btn2').addEventListener('click', function() {
                numX7Ladders2++;
                createLadder();
            });
            document.getElementById('remove7Btn2').addEventListener('click', function() {
                if (numX7Ladders2 > 0) {
                    numX7Ladders2--;
                    createLadder();
                }
            });
            document.getElementById('ladderSelect2').addEventListener('change', function(e) {
                var newValue = e.target.value === '0' ? 0 : (e.target.value === '7alt' ? '7alt' : parseInt(e.target.value));
                finalLadderRungs2 = newValue;
                // Auto-dodaj uchwyt dla x5, x6, x7alt
                autoAddSciskaneForKoncowa(newValue, 2, sciskaneHandles2);
                createLadder();
            });

            // Globalny slider odleg≈Ço≈õci wspornik√≥w dla drabiny 1
            document.getElementById('wspornikGlobalSlider1').addEventListener('input', function(e) {
                var distanceMm = parseInt(e.target.value);
                var type = getWspornikTypeFromDistance(distanceMm);
                var typeNames = { 'krotki': 'kr√≥tki', 'sredni': '≈õredni', 'dlugi': 'd≈Çugi' };
                document.getElementById('wspornikGlobalValue1').textContent = Math.round(distanceMm / 10);
                document.getElementById('wspornikGlobalType1').textContent = typeNames[type];
                updateGlobalWspornikDistance(1, distanceMm);
                createLadder();
            });

            // Checkbox wy≈ÇƒÖczenia wspornik√≥w dla drabiny 1
            document.getElementById('wspornikDisable1').addEventListener('change', function(e) {
                var disabled = e.target.checked;
                document.getElementById('wspornikSliderContainer1').style.opacity = disabled ? '0.3' : '1';
                document.getElementById('wspornikGlobalSlider1').disabled = disabled;
                toggleAllWsporniki(1, disabled);
                createLadder();
            });

            // Globalny slider odleg≈Ço≈õci wspornik√≥w dla drabiny 2
            document.getElementById('wspornikGlobalSlider2').addEventListener('input', function(e) {
                var distanceMm = parseInt(e.target.value);
                var type = getWspornikTypeFromDistance(distanceMm);
                var typeNames = { 'krotki': 'kr√≥tki', 'sredni': '≈õredni', 'dlugi': 'd≈Çugi' };
                document.getElementById('wspornikGlobalValue2').textContent = Math.round(distanceMm / 10);
                document.getElementById('wspornikGlobalType2').textContent = typeNames[type];
                updateGlobalWspornikDistance(2, distanceMm);
                createLadder();
            });

            // Checkbox wy≈ÇƒÖczenia wspornik√≥w dla drabiny 2
            document.getElementById('wspornikDisable2').addEventListener('change', function(e) {
                var disabled = e.target.checked;
                document.getElementById('wspornikSliderContainer2').style.opacity = disabled ? '0.3' : '1';
                document.getElementById('wspornikGlobalSlider2').disabled = disabled;
                toggleAllWsporniki(2, disabled);
                createLadder();
            });

            // Funkcja aktualizujƒÖca typy wspornik√≥w dla drabiny
            function updateWspornikTypesForLadder(ladderNum, newType) {
                var types = (ladderNum === 1) ? wspornikTypes1 : wspornikTypes2;
                var distances = (ladderNum === 1) ? wspornikDistances1 : wspornikDistances2;
                var connTypes = (ladderNum === 1) ? connectorTypes1 : connectorTypes2;
                var globalDistance = (ladderNum === 1) ? globalWspornikDistance1 : globalWspornikDistance2;
                // Aktualizuj tylko pozycje z uchwytami (nie ≈ÇƒÖcznikami)
                for (var i = 0; i < connTypes.length; i++) {
                    if (connTypes[i] === 'uchwyt') {
                        types[i] = newType;
                        distances[i] = globalDistance;
                    }
                }
                if (ladderNum === 1) {
                    wspornikTypes1 = types;
                    wspornikDistances1 = distances;
                } else {
                    wspornikTypes2 = types;
                    wspornikDistances2 = distances;
                }
            }

            // Wsp√≥lne przyciski w trybie attyki
            document.getElementById('techBtn2').addEventListener('click', function() {
                document.getElementById('techBtn').click();
            });
            document.getElementById('measureBtn2').addEventListener('click', function() {
                document.getElementById('measureBtn').click();
            });
            document.getElementById('sciskaneBtn2').addEventListener('click', function() {
                document.getElementById('sciskaneBtn').click();
            });

            // Stare przyciski prze≈ÇƒÖczania - usuniƒôte z UI

            function updateLadderSwitcherUI() {
                // Stara funkcja - ju≈º nieu≈ºywana, ale zostawiam dla kompatybilno≈õci
                var btn1 = document.getElementById('ladder1Btn');
                var btn2 = document.getElementById('ladder2Btn');
                if (btn1 && btn2) {
                    if (currentLadder === 1) {
                        btn1.style.background = '#4CAF50';
                        btn2.style.background = '#666';
                    } else {
                        btn1.style.background = '#666';
                        btn2.style.background = '#4CAF50';
                    }
                }
            }

            function updateUIFromCurrentLadder() {
                // Zaktualizuj UI ≈ºeby odzwierciedla≈Ço aktualnƒÖ drabinƒô
                document.getElementById('ladderSelect').value = finalLadderRungs || '0';
                updateConnectorList();
            }

            // Zmiana typu ≈ÇƒÖcznika
            // Przyciski +7 / -7 standardowe
            document.getElementById('add7Btn').addEventListener('click', function(e) {
                e.preventDefault();
                add7Ladder();
            });
            
            document.getElementById('add7Btn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                add7Ladder();
            });
            
            document.getElementById('remove7Btn').addEventListener('click', function(e) {
                e.preventDefault();
                remove7Ladder();
            });
            
            document.getElementById('remove7Btn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                remove7Ladder();
            });

            // Zamykanie tutoriala
            document.getElementById('closeInfo').addEventListener('click', function() {
                document.getElementById('info').style.display = 'none';
            });

            // Zamykanie ostrze≈ºenia o kolizji
            document.getElementById('collisionWarningClose').addEventListener('click', function() {
                hideCollisionWarning();
            });

            // Przycisk oczka - chowanie/pokazywanie paneli
            var panelsVisible = true;
            var toggleBtn = document.getElementById('togglePanelsBtn');
            var ladderSelector = document.getElementById('ladderSelector');

            function updateToggleBtnPosition() {
                if (panelsVisible) {
                    // Pozycjonuj nad panelami
                    var rect = ladderSelector.getBoundingClientRect();
                    var bottomFromViewport = window.innerHeight - rect.top;
                    toggleBtn.style.bottom = (bottomFromViewport + 5) + 'px';
                } else {
                    // Gdy ukryte - na dole
                    toggleBtn.style.bottom = '10px';
                }
            }

            toggleBtn.addEventListener('click', function() {
                panelsVisible = !panelsVisible;

                if (panelsVisible) {
                    ladderSelector.style.display = 'block';
                    toggleBtn.textContent = 'üëÅ‚Äçüó®';
                } else {
                    ladderSelector.style.display = 'none';
                    toggleBtn.textContent = 'üëÅ';
                }
                // Aktualizuj pozycjƒô po kr√≥tkim op√≥≈∫nieniu (≈ºeby DOM siƒô od≈õwie≈ºy≈Ç)
                setTimeout(updateToggleBtnPosition, 10);
            });

            // Aktualizuj pozycjƒô przy starcie i przy zmianie rozmiaru okna
            setTimeout(updateToggleBtnPosition, 100);
            window.addEventListener('resize', updateToggleBtnPosition);

            // Kontrolki
            var isDragging = false;
            var isPanning = false;
            var previousPosition = { x: 0, y: 0 };
            var targetRotation = { x: 0, y: 0.3 };
            var currentRotation = { x: 0, y: 0.3 };
            var cameraOffset = { x: 0, y: 0, z: 0 };
            var initialPinchDistance = null;
            var lastZoom = 50;
            var lastPanCenter = { x: 0, y: 0 };
            var clickStartPosition = { x: 0, y: 0 }; // Pozycja mousedown dla detekcji klikniƒôcia
            var CLICK_THRESHOLD = 5; // Max dystans w pikselach dla klikniƒôcia

            function onPointerStart(x, y) {
                isDragging = true;
                previousPosition = { x: x, y: y };
                clickStartPosition = { x: x, y: y }; // Zapamiƒôtaj pozycjƒô startu dla detekcji klikniƒôcia
            }
            
            function onPointerMove(x, y) {
                if (!isDragging) return;
                
                var deltaX = x - previousPosition.x;
                var deltaY = y - previousPosition.y;
                
                targetRotation.y += deltaX * 0.005;
                targetRotation.x += deltaY * 0.005;
                
                previousPosition = { x: x, y: y };
            }
            
            function onPointerEnd() {
                isDragging = false;
            }

            // Klikanie na ≈ÇƒÖczniki lub miarka lub uchwyty ≈õciskane
            renderer.domElement.addEventListener('click', function(e) {
                // Sprawd≈∫ czy to prawdziwe klikniƒôcie (nie przeciƒÖganie)
                var clickDist = Math.sqrt(
                    Math.pow(e.clientX - clickStartPosition.x, 2) +
                    Math.pow(e.clientY - clickStartPosition.y, 2)
                );
                if (clickDist > CLICK_THRESHOLD) {
                    return; // To by≈Ço przeciƒÖganie, nie klikniƒôcie
                }

                // Oblicz pozycjƒô myszy w uk≈Çadzie normalized device coordinates
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Tryb miarki
                if (measureMode) {
                    var intersects = raycaster.intersectObjects(ladderContainer.children, true);
                    if (intersects.length > 0) {
                        addMeasurePoint(intersects[0].point);
                    }
                    return;
                }

                // Tryb uchwyt√≥w ≈õciskanych
                if (sciskaneMode) {
                    // NAJPIERW sprawd≈∫ czy klikniƒôto na uchwyt miƒôdzy 2. a 3. szczeblem
                    var midRungWspornikIntersects = raycaster.intersectObjects(wspornikObjects, true);
                    for (var i = 0; i < midRungWspornikIntersects.length; i++) {
                        var obj = midRungWspornikIntersects[i].object;
                        while (obj.parent && !obj.userData.isWspornik) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isWspornik && obj.userData.isMidRungBracket) {
                            openConnectionPanel(null, obj);
                            return;
                        }
                    }

                    var midRungConnectorIntersects = raycaster.intersectObjects(connectorObjects, true);
                    for (var i = 0; i < midRungConnectorIntersects.length; i++) {
                        var obj = midRungConnectorIntersects[i].object;
                        while (obj.parent && !obj.userData.isConnector) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isConnector && obj.userData.isMidRungBracket) {
                            openConnectionPanel(obj, null);
                            return;
                        }
                    }

                    // Sprawd≈∫ klikniƒôcie na ju≈º umieszczone uchwyty ≈õciskane (otw√≥rz panel edycji)
                    var placedIntersects = raycaster.intersectObjects(sciskanePlacedObjects, true);
                    if (placedIntersects.length > 0) {
                        var obj = placedIntersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w sciskanePlacedObjects (bo tam jest sciskaneOffsetFromBottom)
                        while (obj && sciskanePlacedObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isSciskanePlaced) {
                            // Otw√≥rz panel edycji uchwytu ≈õciskanego
                            var offsetFromBottom = obj.userData.sciskaneOffsetFromBottom;
                            var clickedLadderNum = obj.userData.ladderNum || 1;
                            openSciskaneEditPanel(offsetFromBottom, clickedLadderNum);
                            return;
                        }
                    }

                    // Sprawd≈∫ przeciƒôcia z wspornikami (zwyk≈Çymi, nie mid-rung) - PRZED podglƒÖdem
                    var wspornikIntersects = raycaster.intersectObjects(wspornikObjects, true);
                    if (wspornikIntersects.length > 0) {
                        var obj = wspornikIntersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w wspornikObjects (bo tam jest pairIndex)
                        while (obj && wspornikObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isWspornik && !obj.userData.isMidRungBracket) {
                            openConnectionPanel(null, obj);
                            return;
                        }
                    }

                    // Sprawd≈∫ przeciƒôcia z ≈ÇƒÖcznikami (zwyk≈Çymi, nie mid-rung) - PRZED podglƒÖdem
                    var connIntersects = raycaster.intersectObjects(connectorObjects, true);
                    if (connIntersects.length > 0) {
                        var obj = connIntersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w connectorObjects (bo tam jest pairIndex)
                        while (obj && connectorObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isConnector && !obj.userData.isMidRungBracket) {
                            openConnectionPanel(obj, null);
                            return;
                        }
                    }

                    // Sprawd≈∫ klikniƒôcie na podglƒÖd (dodanie pary) - NA KO≈ÉCU, najni≈ºszy priorytet
                    var intersects = raycaster.intersectObjects(sciskanePreviewObjects, true);
                    if (intersects.length > 0) {
                        var obj = intersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w sciskanePreviewObjects (bo tam jest previewY)
                        while (obj && sciskanePreviewObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isSciskanePreview) {
                            addSciskaneHandle(obj.userData.previewY, obj.userData.ladderNum);
                            return;
                        }
                    }

                    return;
                }
            });

            // Eventy myszy
            renderer.domElement.addEventListener('mousedown', function(e) {
                if (e.shiftKey || e.button === 1) {
                    // Shift lub ≈õrodkowy przycisk myszy = przesuwanie
                    isPanning = true;
                    previousPosition = { x: e.clientX, y: e.clientY };
                    e.preventDefault();
                } else {
                    onPointerStart(e.clientX, e.clientY);
                }
            });
            
            renderer.domElement.addEventListener('mousemove', function(e) {
                if (isPanning) {
                    var deltaX = e.clientX - previousPosition.x;
                    var deltaY = e.clientY - previousPosition.y;
                    
                    // Przesuwanie proporcjonalne do odleg≈Ço≈õci (jak w CAD)
                    var panScale = camera.position.z * 0.00075;
                    cameraOffset.x -= deltaX * panScale;
                    cameraOffset.y += deltaY * panScale;
                    
                    previousPosition = { x: e.clientX, y: e.clientY };
                } else {
                    onPointerMove(e.clientX, e.clientY);
                }
            });
            
            renderer.domElement.addEventListener('mouseup', function() {
                isPanning = false;
                onPointerEnd();
            });
            
            renderer.domElement.addEventListener('mouseleave', function() {
                isPanning = false;
                onPointerEnd();
            });
            
            // Eventy dotyku
            var touchStartPos = { x: 0, y: 0 };
            var touchMoved = false;

            renderer.domElement.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchMoved = false;
                    onPointerStart(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                    isDragging = false;
                    
                    var centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    var centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    lastPanCenter = { x: centerX, y: centerY };
                    
                    var dx = e.touches[0].clientX - e.touches[1].clientX;
                    var dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                    lastZoom = camera.position.z;
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', function(e) {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    var dx = e.touches[0].clientX - touchStartPos.x;
                    var dy = e.touches[0].clientY - touchStartPos.y;
                    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                        touchMoved = true;
                    }
                    onPointerMove(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                    
                    var centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    var centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    
                    var panDeltaX = centerX - lastPanCenter.x;
                    var panDeltaY = centerY - lastPanCenter.y;
                    
                    // Przesuwanie proporcjonalne do odleg≈Ço≈õci (jak w CAD)
                    var touchPanScale = camera.position.z * 0.0015;
                    cameraOffset.x -= panDeltaX * touchPanScale;
                    cameraOffset.y += panDeltaY * touchPanScale;
                    
                    lastPanCenter = { x: centerX, y: centerY };
                    
                    var dx = e.touches[0].clientX - e.touches[1].clientX;
                    var dy = e.touches[0].clientY - e.touches[1].clientY;
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (initialPinchDistance) {
                        var delta = initialPinchDistance - distance;
                        // Zoom proporcjonalny do odleg≈Ço≈õci (jak w CAD)
                        camera.position.z = lastZoom * (1 + delta * 0.005);
                        camera.position.z = Math.max(3, Math.min(300, camera.position.z));
                    }
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', function(e) {
                e.preventDefault();
                onPointerEnd();
                if (e.touches.length < 2) {
                    initialPinchDistance = null;
                }
                // Je≈õli nie przesunƒôli≈õmy palca - traktuj jako tap/klikniƒôcie
                if (!touchMoved && e.changedTouches.length > 0) {
                    var touch = e.changedTouches[0];
                    handleTap(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            // Funkcja obs≈ÇugujƒÖca tap (dotkniƒôcie bez przesuniƒôcia) - ta sama logika co click
            function handleTap(clientX, clientY) {
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Tryb miarki
                if (measureMode) {
                    var intersects = raycaster.intersectObjects(ladderContainer.children, true);
                    if (intersects.length > 0) {
                        addMeasurePoint(intersects[0].point);
                    }
                    return;
                }

                // Tryb uchwyt√≥w ≈õciskanych
                if (sciskaneMode) {
                    // NAJPIERW sprawd≈∫ czy klikniƒôto na uchwyt miƒôdzy 2. a 3. szczeblem
                    var midRungWspornikIntersects = raycaster.intersectObjects(wspornikObjects, true);
                    for (var i = 0; i < midRungWspornikIntersects.length; i++) {
                        var obj = midRungWspornikIntersects[i].object;
                        while (obj.parent && !obj.userData.isWspornik) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isWspornik && obj.userData.isMidRungBracket) {
                            openConnectionPanel(null, obj);
                            return;
                        }
                    }

                    var midRungConnectorIntersects = raycaster.intersectObjects(connectorObjects, true);
                    for (var i = 0; i < midRungConnectorIntersects.length; i++) {
                        var obj = midRungConnectorIntersects[i].object;
                        while (obj.parent && !obj.userData.isConnector) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isConnector && obj.userData.isMidRungBracket) {
                            openConnectionPanel(obj, null);
                            return;
                        }
                    }

                    // Sprawd≈∫ klikniƒôcie na ju≈º umieszczone uchwyty ≈õciskane (otw√≥rz panel edycji)
                    var placedIntersects = raycaster.intersectObjects(sciskanePlacedObjects, true);
                    if (placedIntersects.length > 0) {
                        var obj = placedIntersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w sciskanePlacedObjects (bo tam jest sciskaneOffsetFromBottom)
                        while (obj && sciskanePlacedObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isSciskanePlaced) {
                            // Otw√≥rz panel edycji uchwytu ≈õciskanego
                            var offsetFromBottom = obj.userData.sciskaneOffsetFromBottom;
                            var clickedLadderNum = obj.userData.ladderNum || 1;
                            openSciskaneEditPanel(offsetFromBottom, clickedLadderNum);
                            return;
                        }
                    }

                    // Sprawd≈∫ przeciƒôcia z wspornikami (zwyk≈Çymi, nie mid-rung) - PRZED podglƒÖdem
                    var wspornikIntersects = raycaster.intersectObjects(wspornikObjects, true);
                    if (wspornikIntersects.length > 0) {
                        var obj = wspornikIntersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w wspornikObjects (bo tam jest pairIndex)
                        while (obj && wspornikObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isWspornik && !obj.userData.isMidRungBracket) {
                            openConnectionPanel(null, obj);
                            return;
                        }
                    }

                    // Sprawd≈∫ przeciƒôcia z ≈ÇƒÖcznikami (zwyk≈Çymi, nie mid-rung) - PRZED podglƒÖdem
                    var connIntersects = raycaster.intersectObjects(connectorObjects, true);
                    if (connIntersects.length > 0) {
                        var obj = connIntersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w connectorObjects (bo tam jest pairIndex)
                        while (obj && connectorObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isConnector && !obj.userData.isMidRungBracket) {
                            openConnectionPanel(obj, null);
                            return;
                        }
                    }

                    // Sprawd≈∫ klikniƒôcie na podglƒÖd (dodanie pary) - NA KO≈ÉCU, najni≈ºszy priorytet
                    var intersects = raycaster.intersectObjects(sciskanePreviewObjects, true);
                    if (intersects.length > 0) {
                        var obj = intersects[0].object;
                        // Znajd≈∫ root model kt√≥ry jest w sciskanePreviewObjects (bo tam jest previewY)
                        while (obj && sciskanePreviewObjects.indexOf(obj) === -1) {
                            obj = obj.parent;
                        }
                        if (obj && obj.userData.isSciskanePreview) {
                            addSciskaneHandle(obj.userData.previewY, obj.userData.ladderNum);
                            return;
                        }
                    }

                    return;
                }
            }

            // Scroll zoomuje
            renderer.domElement.addEventListener('wheel', function(e) {
                e.preventDefault();
                // Zoom proporcjonalny do odleg≈Ço≈õci (jak w CAD)
                camera.position.z *= (1 + e.deltaY * 0.001);
                camera.position.z = Math.max(3, Math.min(300, camera.position.z));
            }, { passive: false });

            // Blokuj domy≈õlne zachowanie ≈õrodkowego przycisku (auto-scroll)
            renderer.domElement.addEventListener('auxclick', function(e) {
                if (e.button === 1) e.preventDefault();
            });
            
            // Animacja
            function animate() {
                requestAnimationFrame(animate);
                
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;

                // Drabina przesuniƒôta wewnƒÖtrz pivota - punkt obrotu podƒÖ≈ºa za kamerƒÖ
                ladderContainer.position.y = -cameraOffset.y;
                // Przy attyce cofnij pivot o 51cm (510mm) do ty≈Çu
                var atticZOffset = (handrailType === 'attic') ? 510 * SCALE : 0;
                ladderContainer.position.z = -cameraOffset.z + atticZOffset;

                // Obr√≥t nastƒôpuje na pivotGroup (wok√≥≈Ç y=0, z=0)
                pivotGroup.rotation.x = currentRotation.x;
                pivotGroup.rotation.y = currentRotation.y;

                camera.position.x = cameraOffset.x;
                camera.position.y = 0;
                camera.lookAt(cameraOffset.x, 0, 0);
                
                renderer.render(scene, camera);
            }
            
            // Responsywnosc
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
            
            // ============ RYSUNEK TECHNICZNY ============
            
            var techCanvas = document.getElementById('techDrawing');
            var techCtx = techCanvas.getContext('2d');
            var closeBtn = document.getElementById('closeDrawing');
            var switchBtn = document.getElementById('switchView');
            var currentView = 'front'; // 'front' lub 'side'
            
            function drawDimension(x1, y1, x2, y2, text, orientation, offset) {
                offset = offset || 0;
                
                techCtx.strokeStyle = '#000';
                techCtx.fillStyle = '#000';
                techCtx.lineWidth = 1;
                techCtx.setLineDash([]);
                
                if (orientation === 'vertical') {
                    var x = x1 + offset;
                    
                    // Linie pomocnicze
                    techCtx.setLineDash([3, 3]);
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y1);
                    techCtx.lineTo(x, y1);
                    techCtx.stroke();
                    techCtx.beginPath();
                    techCtx.moveTo(x2, y2);
                    techCtx.lineTo(x, y2);
                    techCtx.stroke();
                    techCtx.setLineDash([]);
                    
                    // Linia wymiaru
                    techCtx.beginPath();
                    techCtx.moveTo(x, y1);
                    techCtx.lineTo(x, y2);
                    techCtx.stroke();
                    
                    // Strza≈Çki
                    var arrowSize = 8;
                    techCtx.beginPath();
                    techCtx.moveTo(x, y1);
                    techCtx.lineTo(x - arrowSize / 2, y1 + arrowSize);
                    techCtx.lineTo(x + arrowSize / 2, y1 + arrowSize);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    techCtx.beginPath();
                    techCtx.moveTo(x, y2);
                    techCtx.lineTo(x - arrowSize / 2, y2 - arrowSize);
                    techCtx.lineTo(x + arrowSize / 2, y2 - arrowSize);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    // Tekst
                    techCtx.save();
                    techCtx.translate(x + 20, (y1 + y2) / 2);
                    techCtx.rotate(-Math.PI / 2);
                    techCtx.font = 'bold 12px Arial';
                    techCtx.textAlign = 'center';
                    techCtx.fillText(text, 0, 0);
                    techCtx.restore();
                } else {
                    var y = y1 + offset;
                    
                    // Linie pomocnicze
                    techCtx.setLineDash([3, 3]);
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y1);
                    techCtx.lineTo(x1, y);
                    techCtx.stroke();
                    techCtx.beginPath();
                    techCtx.moveTo(x2, y2);
                    techCtx.lineTo(x2, y);
                    techCtx.stroke();
                    techCtx.setLineDash([]);
                    
                    // Linia wymiaru
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y);
                    techCtx.lineTo(x2, y);
                    techCtx.stroke();
                    
                    // Strza≈Çki
                    var arrowSize = 8;
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y);
                    techCtx.lineTo(x1 + arrowSize, y - arrowSize / 2);
                    techCtx.lineTo(x1 + arrowSize, y + arrowSize / 2);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    techCtx.beginPath();
                    techCtx.moveTo(x2, y);
                    techCtx.lineTo(x2 - arrowSize, y - arrowSize / 2);
                    techCtx.lineTo(x2 - arrowSize, y + arrowSize / 2);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    // Tekst
                    techCtx.font = 'bold 12px Arial';
                    techCtx.textAlign = 'center';
                    techCtx.fillText(text, (x1 + x2) / 2, y - 15);
                }
            }
            
            function drawTechnicalDrawing() {
                techCanvas.width = window.innerWidth;
                techCanvas.height = window.innerHeight;
                
                techCtx.fillStyle = '#ffffff';
                techCtx.fillRect(0, 0, techCanvas.width, techCanvas.height);
                
                var sections = getLadderSections();
                var totalHeight = getTotalHeight();
                
                var totalHeightWithHandrails = totalHeight;
                if (handrailType === 'safety' || handrailType === 'platform') {
                    totalHeightWithHandrails += DIMS.handrailVertical;
                } else if (handrailType === 'attic') {
                    totalHeightWithHandrails += DIMS.atticRailHeight;
                }
                
                var availableHeight = techCanvas.height - 250;
                var availableWidth = techCanvas.width - 200;
                var scaleByHeight = availableHeight / totalHeightWithHandrails;
                var scaleByWidth = availableWidth / (DIMS.rungLength * 2.5);
                var scale = Math.min(scaleByHeight, scaleByWidth, 0.5);
                
                // Ramka tytu≈Çowa
                techCtx.strokeStyle = '#000';
                techCtx.lineWidth = 2;
                techCtx.strokeRect(10, 10, techCanvas.width - 20, techCanvas.height - 20);
                
                techCtx.font = 'bold 16px Arial';
                techCtx.fillStyle = '#000';
                techCtx.textAlign = 'center';
                techCtx.fillText('RYSUNEK TECHNICZNY', techCanvas.width / 2, 30);
                
                var titleText = '';
                if (numX7Ladders === 0 && finalLadderRungs === 0) {
                    titleText = 'BRAK DRABIN';
                } else if (numX7Ladders === 0 && finalLadderRungs === '7alt') {
                    titleText = 'DRABINKA x7 ALT';
                } else if (numX7Ladders === 0) {
                    titleText = 'DRABINKA x' + finalLadderRungs;
                } else if (numX7Ladders === 1 && finalLadderRungs === 0) {
                    titleText = 'DRABINKA x7';
                } else if (numX7Ladders > 1 && finalLadderRungs === 0) {
                    titleText = numX7Ladders + 'x DRABINKA x7';
                } else if (numX7Ladders === 1 && finalLadderRungs === '7alt') {
                    titleText = 'DRABINKA x7 + x7 ALT';
                } else if (numX7Ladders === 1) {
                    titleText = 'DRABINKA x7 + x' + finalLadderRungs;
                } else if (finalLadderRungs === '7alt') {
                    titleText = numX7Ladders + 'x DRABINKA x7 + x7 ALT';
                } else {
                    titleText = numX7Ladders + 'x DRABINKA x7 + x' + finalLadderRungs;
                }
                
                if (totalHeight > 0) {
                    if (handrailType !== "none") {
                        titleText += ' - ' + totalHeight + 'mm + porƒôcze ' + DIMS.handrailVertical + 'mm';
                    } else {
                        titleText += ' - ' + totalHeight + 'mm';
                    }
                }
                
                techCtx.font = 'bold 14px Arial';
                techCtx.fillText(titleText, techCanvas.width / 2, 50);
                
                // Pozycje widoku - wy≈õrodkowany
                var viewY = 40;
                var viewPos = {
                    x: techCanvas.width / 2,
                    y: techCanvas.height / 2
                };
                
                if (currentView === 'front') {
                    // ====== WIDOK Z PRZODU ======
                techCtx.save();
                techCtx.translate(viewPos.x, viewPos.y);
                
                techCtx.font = 'bold 14px Arial';
                techCtx.fillStyle = '#000';
                techCtx.textAlign = 'center';
                var titleOffset = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 - 30 : -totalHeight * scale / 2 - 30;
                techCtx.fillText('WIDOK Z PRZODU', 0, titleOffset);
                
                var halfHeight = totalHeight * scale / 2;
                var halfRungLength = DIMS.rungLength * scale / 2;
                var railW = DIMS.railDepth * scale;
                var railOffset = 265 * scale;
                
                var ladderYOffset = 0;
                if (handrailType === 'safety' || handrailType === 'platform') {
                    ladderYOffset = DIMS.handrailVertical * scale;
                } else if (handrailType === 'attic') {
                    ladderYOffset = DIMS.atticRailHeight * scale;
                }

                // Rysuj porƒôcze asekuracyjne, podest lub przej≈õcie przez attykƒô
                if (handrailType === 'safety' || handrailType === 'platform') {
                    // PORƒòCZE ASEKURACYJNE / Z PODESTEM - widok z przodu
                    var handrailVertH = DIMS.handrailVertical * scale;
                    var handrailHorH = DIMS.handrailHorizontal * scale;
                    var handrailW = DIMS.handrailWidth * scale;

                    techCtx.fillStyle = handrailType === 'platform' ? '#b0d0b0' : '#d0d0d0';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;

                    // Lewa i prawa porƒôcz - pionowe przed≈Çu≈ºenia
                    techCtx.fillRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);
                    techCtx.strokeRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);

                    techCtx.fillRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);
                    techCtx.strokeRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);

                    // Dla podestu: narysuj poziomƒÖ belkƒô ≈ÇƒÖczƒÖcƒÖ obie strony
                    if (handrailType === 'platform') {
                        var podestTopY = -totalHeightWithHandrails * scale / 2;
                        techCtx.fillStyle = '#90c090';
                        techCtx.fillRect(-railOffset - railW/2, podestTopY, (railOffset * 2) + railW, handrailW);
                        techCtx.strokeRect(-railOffset - railW/2, podestTopY, (railOffset * 2) + railW, handrailW);
                    }
                } else if (handrailType === 'attic') {
                    // PRZEJ≈öCIE PRZEZ ATTYKƒò - widok z przodu
                    var atticRailH = DIMS.atticRailHeight * scale;
                    
                    techCtx.fillStyle = '#c0c0c0';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    
                    // Lewa i prawa pod≈Çu≈ºnica attyki
                    techCtx.fillRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    techCtx.strokeRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    
                    techCtx.fillRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    techCtx.strokeRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    
                    // 2 szczeble attyki - liczone od DO≈ÅU pod≈Çu≈ºnic
                    var rungH = DIMS.rungHeight * scale;
                    var halfRungLength = DIMS.rungLength * scale / 2;
                    techCtx.fillStyle = '#a0a0a0';
                    
                    // Pierwszy szczebel: 135mm od do≈Çu pod≈Çu≈ºnic attyki
                    var rung1Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 135 * scale;
                    techCtx.fillRect(-halfRungLength, rung1Y - rungH/2, DIMS.rungLength * scale, rungH);
                    techCtx.strokeRect(-halfRungLength, rung1Y - rungH/2, DIMS.rungLength * scale, rungH);
                    
                    // Drugi szczebel: 410mm od do≈Çu pod≈Çu≈ºnic attyki
                    var rung2Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 410 * scale;
                    techCtx.fillRect(-halfRungLength, rung2Y - rungH/2, DIMS.rungLength * scale, rungH);
                    techCtx.strokeRect(-halfRungLength, rung2Y - rungH/2, DIMS.rungLength * scale, rungH);
                }
                
                techCtx.strokeStyle = '#000';
                techCtx.lineWidth = 2;
                techCtx.fillStyle = '#e0e0e0';
                
                var ladderStartY = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 + ladderYOffset : -halfHeight;
                
                techCtx.fillRect(-railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                techCtx.strokeRect(-railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                
                techCtx.fillRect(railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                techCtx.strokeRect(railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                
                // Szczeble
                var rungH = DIMS.rungHeight * scale;
                var currentHeightOffset = 0;
                var firstRungY = ladderStartY + DIMS.firstRungFromTop * scale;
                
                for (var s = 0; s < sections.length; s++) {
                    var section = sections[s];
                    var numRungs = section.rungs;
                    var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(numRungs);
                    
                    if (section.type === 'standard') {
                        techCtx.fillStyle = '#a0a0a0';
                    } else if (section.type === 'alt') {
                        techCtx.fillStyle = '#d8a060';
                    } else {
                        techCtx.fillStyle = '#b8b8b8';
                    }
                    
                    for (var i = 0; i < numRungs; i++) {
                        var yPos = ladderStartY + currentHeightOffset * scale + DIMS.firstRungFromTop * scale + (i * DIMS.rungSpacing * scale);
                        
                        techCtx.fillRect(-halfRungLength, yPos - rungH/2, DIMS.rungLength * scale, rungH);
                        techCtx.strokeRect(-halfRungLength, yPos - rungH/2, DIMS.rungLength * scale, rungH);
                    }
                    
                    // Wymiary sekcji
                    var labelText = section.type === 'alt' ? 
                        'x7 ALT (' + sectionHeight + 'mm)' : 
                        'x' + numRungs + ' (' + sectionHeight + 'mm)';
                    
                    if (s === 0) {
                        var sectionEndY = ladderStartY + (currentHeightOffset + sectionHeight) * scale;
                        var firstSectionHeight = sectionHeight - DIMS.firstRungFromTop;
                        
                        drawDimension(
                            halfRungLength + 100,
                            firstRungY,
                            halfRungLength + 100,
                            sectionEndY,
                            labelText,
                            'vertical',
                            0
                        );
                    } else if (s < sections.length - 1) {
                        var sectionEndY = ladderStartY + (currentHeightOffset + sectionHeight) * scale;
                        
                        drawDimension(
                            halfRungLength + 100,
                            ladderStartY + currentHeightOffset * scale,
                            halfRungLength + 100,
                            sectionEndY,
                            labelText,
                            'vertical',
                            0
                        );
                    } else {
                        var sectionStartY = ladderStartY + currentHeightOffset * scale;
                        var sectionEndY = ladderStartY + (currentHeightOffset + sectionHeight) * scale;
                        
                        drawDimension(
                            halfRungLength + 100,
                            sectionStartY,
                            halfRungLength + 100,
                            sectionEndY,
                            labelText,
                            'vertical',
                            0
                        );
                    }
                    
                    currentHeightOffset += sectionHeight;
                }
                
                if (handrailType !== "none") {
                    var handrailWithTopHeight = DIMS.handrailVertical + DIMS.firstRungFromTop;
                    
                    drawDimension(
                        halfRungLength + 100,
                        -totalHeightWithHandrails * scale / 2,
                        halfRungLength + 100,
                        firstRungY,
                        handrailWithTopHeight + 'mm (porƒôcz)',
                        'vertical',
                        0
                    );
                }
                
                techCtx.setLineDash([]);
                techCtx.fillStyle = '#000';
                
                drawDimension(
                    -halfRungLength - 80,
                    ladderStartY,
                    -halfRungLength - 80,
                    ladderStartY + totalHeight * scale,
                    totalHeight + 'mm (ca≈Çkowita)',
                    'vertical',
                    0
                );
                
                drawDimension(
                    -halfRungLength,
                    ladderStartY + totalHeight * scale,
                    halfRungLength,
                    ladderStartY + totalHeight * scale,
                    DIMS.rungLength + 'mm',
                    'horizontal',
                    35
                );
                
                // Rysuj ceowniki na wszystkich po≈ÇƒÖczeniach (obr√≥cone - widaƒá ramiona 30mm)
                techCtx.fillStyle = '#606060';
                techCtx.strokeStyle = '#000';
                techCtx.lineWidth = 2;
                
                var connectorH = DIMS.connectorHeight * scale;
                var connectorArmD = DIMS.connectorArmDepth * scale;  // 30mm ramiona (teraz widoczne z przodu)
                var connectorOffset = 15 * scale;  // 15mm przesuniƒôcie do ≈õrodka
                var connectorDownShift = 50 * scale;  // 50mm przesuniƒôcie w d√≥≈Ç
                
                // 1. Ceownik na g√≥rze (je≈õli sƒÖ porƒôcze)
                if (handrailType !== "none" && sections.length > 0) {
                    var topY = ladderStartY - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                    
                    // Lewy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                    techCtx.fillRect(-railOffset + connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                    techCtx.strokeRect(-railOffset + connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                    
                    // Prawy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                    techCtx.fillRect(railOffset - connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                    techCtx.strokeRect(railOffset - connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                }
                
                // 2. Ceowniki miƒôdzy sekcjami
                var currentOffset = 0;
                for (var s = 0; s < sections.length; s++) {
                    var section = sections[s];
                    var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                    currentOffset += sectionHeight;
                    
                    if (s < sections.length - 1) {
                        var connY = ladderStartY + currentOffset * scale - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                        
                        // Lewy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                        techCtx.fillRect(-railOffset + connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                        techCtx.strokeRect(-railOffset + connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                        
                        // Prawy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                        techCtx.fillRect(railOffset - connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                        techCtx.strokeRect(railOffset - connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                    }
                }
                
                techCtx.restore();
                
                } else {
                // ====== WIDOK Z BOKU ======
                    techCtx.save();
                    techCtx.translate(viewPos.x, viewPos.y);
                    
                    techCtx.font = 'bold 14px Arial';
                    techCtx.fillStyle = '#000';
                    techCtx.textAlign = 'center';
                    var sideTitleOffset = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 - 30 : -totalHeight * scale / 2 - 30;
                    techCtx.fillText('WIDOK Z BOKU', 0, sideTitleOffset);
                    
                    var halfHeight = totalHeight * scale / 2;
                    var rungH = DIMS.rungHeight * scale;
                    var railD = DIMS.railDepth * scale;
                    var rungW = DIMS.rungWidth * scale;
                    
                    // Rysuj porƒôcze asekuracyjne, podest lub przej≈õcie przez attykƒô
                    if (handrailType === 'safety' || handrailType === 'platform') {
                        // PORƒòCZE ASEKURACYJNE / Z PODESTEM - widok z boku
                        var handrailVertH = DIMS.handrailVertical * scale;
                        var handrailHorH = DIMS.handrailHorizontal * scale;
                        var handrailW = DIMS.handrailWidth * scale;

                        techCtx.fillStyle = handrailType === 'platform' ? '#b0d0b0' : '#d0d0d0';
                        techCtx.strokeStyle = '#000';
                        techCtx.lineWidth = 2;

                        // Pionowe przed≈Çu≈ºenie
                        techCtx.fillRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, handrailVertH);
                        techCtx.strokeRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, handrailVertH);

                        // Ramiƒô poziome (lub podest)
                        techCtx.fillRect(-railD/2, -totalHeightWithHandrails * scale / 2 - handrailW/2, handrailHorH, handrailW);
                        techCtx.strokeRect(-railD/2, -totalHeightWithHandrails * scale / 2 - handrailW/2, handrailHorH, handrailW);

                        var dimLabel = handrailType === 'platform' ? 'podest' : DIMS.handrailHorizontal + 'mm';
                        drawDimension(
                            -railD/2,
                            -totalHeightWithHandrails * scale / 2 - handrailW/2 - 20,
                            -railD/2 + handrailHorH,
                            -totalHeightWithHandrails * scale / 2 - handrailW/2 - 20,
                            dimLabel,
                            'horizontal',
                            0
                        );
                    } else if (handrailType === 'attic') {
                        // PRZEJ≈öCIE PRZEZ ATTYKƒò - widok z boku
                        var atticRailH = DIMS.atticRailHeight * scale;
                        
                        techCtx.fillStyle = '#c0c0c0';
                        techCtx.strokeStyle = '#000';
                        techCtx.lineWidth = 2;
                        
                        // Pod≈Çu≈ºnica attyki
                        techCtx.fillRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, atticRailH);
                        techCtx.strokeRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, atticRailH);
                        
                        // 2 szczeble attyki - liczone od DO≈ÅU pod≈Çu≈ºnic
                        techCtx.fillStyle = '#a0a0a0';
                        
                        // Pierwszy szczebel: 135mm od do≈Çu pod≈Çu≈ºnic attyki
                        var rung1Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 135 * scale;
                        techCtx.fillRect(-rungW/2, rung1Y - rungH/2, rungW, rungH);
                        techCtx.strokeRect(-rungW/2, rung1Y - rungH/2, rungW, rungH);
                        
                        // Drugi szczebel: 410mm od do≈Çu pod≈Çu≈ºnic attyki
                        var rung2Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 410 * scale;
                        techCtx.fillRect(-rungW/2, rung2Y - rungH/2, rungW, rungH);
                        techCtx.strokeRect(-rungW/2, rung2Y - rungH/2, rungW, rungH);
                    }
                    
                    var ladderYOffset = 0;
                    if (handrailType === 'safety' || handrailType === 'platform') {
                        ladderYOffset = DIMS.handrailVertical * scale;
                    } else if (handrailType === 'attic') {
                        ladderYOffset = DIMS.atticRailHeight * scale;
                    }
                    var ladderStartY = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 + ladderYOffset : -halfHeight;

                    techCtx.fillStyle = '#e0e0e0';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    techCtx.fillRect(-railD/2, ladderStartY, railD, totalHeight * scale);
                    techCtx.strokeRect(-railD/2, ladderStartY, railD, totalHeight * scale);

                    var currentHeightOffset = 0;
                    for (var s = 0; s < sections.length; s++) {
                        var section = sections[s];
                        var numRungs = section.rungs;
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(numRungs);
                        
                        if (section.type === 'standard') {
                            techCtx.fillStyle = '#a0a0a0';
                        } else if (section.type === 'alt') {
                            techCtx.fillStyle = '#d8a060';
                        } else {
                            techCtx.fillStyle = '#b8b8b8';
                        }
                        
                        for (var i = 0; i < numRungs; i++) {
                            var yPos = ladderStartY + currentHeightOffset * scale + DIMS.firstRungFromTop * scale + (i * DIMS.rungSpacing * scale);
                            
                            techCtx.fillRect(-rungW/2, yPos - rungH/2, rungW, rungH);
                            techCtx.strokeRect(-rungW/2, yPos - rungH/2, rungW, rungH);
                        }
                        
                        currentHeightOffset += sectionHeight;
                    }
                    
                    // Rysuj ceowniki na wszystkich po≈ÇƒÖczeniach - widok z boku pokazuje kszta≈Çt [
                    techCtx.fillStyle = '#606060';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    
                    var connectorH = DIMS.connectorHeight * scale;
                    var connectorBackW = DIMS.connectorBackWidth * scale;  // 56mm tylna ≈õcianka (50mm + 6mm)
                    var connectorArmD = (DIMS.connectorArmDepth + 3) * scale;    // 33mm ramiona (30mm + 3mm przesuniƒôcie tylnej ≈õcianki)
                    var connectorT = DIMS.connectorThickness * scale;  // 3mm grubo≈õƒá
                    var connectorDownShift = 50 * scale;  // 50mm przesuniƒôcie w d√≥≈Ç
                    
                    // 1. Ceownik na g√≥rze (je≈õli sƒÖ porƒôcze)
                    if (handrailType !== "none" && sections.length > 0) {
                        var topY = ladderStartY - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                        
                        // Tylna ≈õcianka (pionowa) - od strony zewnƒôtrznej
                        techCtx.fillRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorT, connectorH);
                        techCtx.strokeRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorT, connectorH);
                        
                        // G√≥rne ramiƒô (poziome) - skierowane do ≈õrodka
                        techCtx.fillRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorArmD, connectorT);
                        techCtx.strokeRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorArmD, connectorT);
                        
                        // Dolne ramiƒô (poziome) - skierowane do ≈õrodka
                        techCtx.fillRect(-connectorArmD + connectorT/2, topY + connectorH/2 - connectorT, connectorArmD, connectorT);
                        techCtx.strokeRect(-connectorArmD + connectorT/2, topY + connectorH/2 - connectorT, connectorArmD, connectorT);
                    }
                    
                    // 2. Ceowniki miƒôdzy sekcjami
                    var currentOffset = 0;
                    for (var s = 0; s < sections.length; s++) {
                        var section = sections[s];
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        currentOffset += sectionHeight;
                        
                        if (s < sections.length - 1) {
                            var connY = ladderStartY + currentOffset * scale - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                            
                            // Ceownik - kszta≈Çt [ skierowany do ≈õrodka
                            techCtx.fillRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorT, connectorH);
                            techCtx.strokeRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorT, connectorH);
                            
                            techCtx.fillRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorArmD, connectorT);
                            techCtx.strokeRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorArmD, connectorT);
                            
                            techCtx.fillRect(-connectorArmD + connectorT/2, connY + connectorH/2 - connectorT, connectorArmD, connectorT);
                            techCtx.strokeRect(-connectorArmD + connectorT/2, connY + connectorH/2 - connectorT, connectorArmD, connectorT);
                        }
                    }
                    
                    techCtx.font = 'bold 11px Arial';
                    techCtx.fillStyle = '#000';
                    techCtx.textAlign = 'left';
                    var textX = railD/2 + 20;
                    var textYStart = ladderStartY + 20;
                    techCtx.fillText('Pod≈Çu≈ºnica:', textX, textYStart);
                    techCtx.fillText('30√ó50mm', textX, textYStart + 15);
                    techCtx.fillText('Szczebel:', textX, textYStart + 35);
                    techCtx.fillText('30√ó30mm', textX, textYStart + 50);
                    
                    techCtx.restore();
                }
                
                // Specyfikacja na dole (zawsze widoczna)
                techCtx.font = '11px Arial';
                techCtx.fillStyle = '#000';
                techCtx.textAlign = 'center';
                var specY = techCanvas.height - 60;
                
                techCtx.font = 'bold 12px Arial';
                techCtx.fillText('SPECYFIKACJA', techCanvas.width / 2, specY);
                techCtx.font = '10px Arial';
                
                var specText = '';
                if (sections.length === 0) {
                    specText = 'Brak drabin';
                } else {
                    for (var s = 0; s < sections.length; s++) {
                        var section = sections[s];
                        if (s > 0) specText += ' + ';
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        var label = section.type === 'alt' ? 'x7 ALT' : 'x' + section.rungs;
                        specText += label + ' (' + sectionHeight + 'mm)';
                    }
                    specText += ' = ' + totalHeight + 'mm';
                }
                
                techCtx.fillText(specText, techCanvas.width / 2, specY + 15);
                techCtx.fillText('Rozstaw szczebli: ' + DIMS.rungSpacing + 'mm | Pierwszy szczebel: ' + DIMS.firstRungFromTop + 'mm | D≈Çugo≈õƒá: ' + DIMS.rungLength + 'mm', 
                    techCanvas.width / 2, specY + 30);
                
                if (handrailType === 'safety') {
                    techCtx.fillText('Porƒôcze asekuracyjne: ' + DIMS.handrailVertical + 'mm (pion) + ' + DIMS.handrailHorizontal + 'mm (poziom)',
                        techCanvas.width / 2, specY + 45);
                } else if (handrailType === 'platform') {
                    techCtx.fillText('Porƒôcze z podestem: ' + DIMS.handrailVertical + 'mm (pion) + podest',
                        techCanvas.width / 2, specY + 45);
                } else if (handrailType === 'attic') {
                    techCtx.fillText('Przej≈õcie przez attykƒô: ' + DIMS.atticRailHeight + 'mm (pod≈Çu≈ºnice) + ' + DIMS.atticRungs + ' szczeble',
                        techCanvas.width / 2, specY + 45);
                }
                
                techCanvas.classList.add('active');
                closeBtn.classList.add('active');
                switchBtn.classList.add('active');
            }
            
            document.getElementById('techBtn').addEventListener('click', function(e) {
                e.preventDefault();
                drawTechnicalDrawing();
            });
            
            document.getElementById('techBtn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                drawTechnicalDrawing();
            });

            // Przycisk miarki
            document.getElementById('measureBtn').addEventListener('click', function(e) {
                e.preventDefault();
                toggleMeasureMode();
            });

            document.getElementById('measureBtn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleMeasureMode();
            });

            // Przycisk uchwyt√≥w ≈õciskanych
            document.getElementById('sciskaneBtn').addEventListener('click', function(e) {
                e.preventDefault();
                toggleSciskaneMode();
            });

            document.getElementById('sciskaneBtn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleSciskaneMode();
            });

            function closeTechnicalDrawing() {
                techCanvas.classList.remove('active');
                closeBtn.classList.remove('active');
                switchBtn.classList.remove('active');
                currentView = 'front'; // Reset do widoku z przodu
            }
            
            closeBtn.addEventListener('click', closeTechnicalDrawing);
            closeBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                closeTechnicalDrawing();
            });
            
            // Prze≈ÇƒÖczanie widok√≥w
            function switchView() {
                if (currentView === 'front') {
                    currentView = 'side';
                    switchBtn.innerHTML = 'Widok z przodu';
                } else {
                    currentView = 'front';
                    switchBtn.innerHTML = 'Widok z boku';
                }
                drawTechnicalDrawing();
            }
            
            switchBtn.addEventListener('click', function(e) {
                e.preventDefault();
                switchView();
            });
            
            switchBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                switchView();
            });
            
        } catch (error) {
            statusDiv.innerHTML = 'BLAD: ' + error.message;
            statusDiv.style.color = 'red';
            console.error('Blad 3D:', error);
        }
    </script>
</body>
</html>
