<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drabinki Przemys≈Çowe - Wizualizacja 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
        }
        #container {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 100;
            max-width: 250px;
        }
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
        }
        .btn {
            display: block;
            width: 50px;
            height: 50px;
            margin-bottom: 10px;
            background: rgba(0, 200, 100, 0.9);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active {
            transform: scale(0.95);
            background: rgba(0, 255, 120, 1);
        }
        .btn-remove {
            background: rgba(200, 50, 50, 0.9);
        }
        .btn-remove:active {
            background: rgba(255, 70, 70, 1);
        }
        .btn-tech {
            background: rgba(50, 100, 200, 0.9);
            font-size: 18px;
        }
        .btn-tech:active {
            background: rgba(70, 120, 255, 1);
        }
        #ladderSelector {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 100;
        }
        #ladderSelector select {
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }
        #techDrawing {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 200;
            display: none;
        }
        #rotationPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid white;
            z-index: 300;
            display: none;
            color: white;
            font-size: 14px;
        }
        #rotationPanel.active {
            display: block;
        }
        #rotationPanel h3 {
            margin: 0 0 15px 0;
            text-align: center;
        }
        .rotation-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        .rotation-row label {
            width: 50px;
        }
        .rotation-btn {
            width: 40px;
            height: 40px;
            background: rgba(50, 100, 200, 0.9);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
        }
        .rotation-btn:hover {
            background: rgba(70, 120, 255, 1);
        }
        #closeRotation {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            background: rgba(200, 50, 50, 0.9);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #techDrawing.active {
            display: block;
        }
        #closeDrawing {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: rgba(200, 50, 50, 0.9);
            color: white;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 201;
            display: none;
        }
        #closeDrawing.active {
            display: block;
        }
        #switchView {
            position: fixed;
            top: 70px;
            right: 10px;
            width: 120px;
            height: 50px;
            background: rgba(50, 100, 200, 0.9);
            color: white;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            z-index: 201;
            display: none;
        }
        #switchView.active {
            display: block;
        }
        #status {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: lime;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            z-index: 100;
            font-weight: bold;
        }
        .connector-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        .connector-item:last-child {
            border-bottom: none;
        }
        .connector-item select {
            padding: 5px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid white;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        /* Responsive styles for mobile */
        @media (max-width: 480px) {
            #ladderSelector {
                left: 10px !important;
                max-width: calc(100vw - 20px);
            }
            #laddersContainer {
                flex-direction: column !important;
            }
            #ladder1Panel, #ladder2Panel {
                min-width: 100% !important;
                max-width: 100% !important;
            }
            #controls {
                flex-direction: row !important;
                flex-wrap: wrap !important;
                justify-content: center !important;
                gap: 5px !important;
            }
            #controls .btn {
                margin-bottom: 3px !important;
            }
            #atticControlsTop {
                right: 5px !important;
                top: 5px !important;
            }
            #atticControlsTop .btn {
                padding: 6px !important;
                font-size: 11px !important;
            }
            #togglePanelsBtn {
                padding: 6px 10px !important;
                font-size: 14px !important;
            }
            #info {
                max-width: 200px !important;
                font-size: 11px !important;
                padding: 8px !important;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <button id="closeInfo" style="position: absolute; top: 3px; right: 5px; background: none; border: none; color: white; font-size: 14px; cursor: pointer; opacity: 0.7;">&times;</button>
        <strong>Drabinka przemys≈Çowa</strong><br>
        Telefon:<br>
        - 1 palec: obrot<br>
        - 2 palce: zoom + przesuwanie<br>
        Komputer:<br>
        - mysz: obrot<br>
        - Shift+mysz: przesuwanie<br>
        - scroll: zoom
    </div>
    <!-- Standardowe kontrolki (bez attyki) -->
    <div id="controls">
        <button class="btn" id="add7Btn" title="Dodaj drabinƒô x7 (1922mm)">+7</button>
        <button class="btn btn-remove" id="remove7Btn" title="Usu≈Ñ drabinƒô x7 (1922mm)">-7</button>
        <button class="btn btn-tech" id="techBtn" title="Rysunek techniczny">üìê</button>
        <button class="btn btn-tech" id="measureBtn" title="Miarka - kliknij 2 punkty">üìè</button>
        <button class="btn btn-tech" id="sciskaneBtn" title="Uchwyty ≈õciskane - kliknij aby dodaƒá">üîß</button>
    </div>
    <div id="measureResult" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: lime; padding: 20px; border-radius: 10px; border: 2px solid lime; font-size: 24px; font-weight: bold; display: none; z-index: 300;"></div>
    <!-- Przycisk oczka do chowania/pokazywania paneli -->
    <button id="togglePanelsBtn" title="Poka≈º/ukryj panele" style="position: fixed; bottom: 10px; left: 10px; z-index: 101; background: rgba(0,0,0,0.85); border: 2px solid white; border-radius: 8px; padding: 8px 12px; color: white; font-size: 16px; cursor: pointer;">üëÅ‚Äçüó®</button>

    <!-- Zunifikowany panel dolny lewy -->
    <div id="ladderSelector">
        <div id="laddersContainer" style="display: flex; flex-wrap: wrap; gap: 8px;">
            <!-- Panel Drabiny 1 (zawsze widoczny) -->
            <div id="ladder1Panel" style="background: rgba(0,0,0,0.85); padding: 10px; border-radius: 8px; border: 2px solid #4CAF50; min-width: 130px;">
                <div id="ladder1Title" style="color: #4CAF50; font-weight: bold; text-align: center; margin-bottom: 5px; font-size: 12px; display: none;">Drabina 1</div>
                <select id="ladderSelect" style="width: 100%; padding: 6px; background: #222; color: white; border: 1px solid #4CAF50; border-radius: 4px; font-size: 12px; margin-bottom: 5px;">
                    <option value="0">Brak ko≈Ñcowej</option>
                    <option value="1">x1 (175mm)</option>
                    <option value="2">x2 (450mm)</option>
                    <option value="3">x3 (725mm)</option>
                    <option value="4">x4 (1000mm)</option>
                    <option value="5">x5 (1275mm)</option>
                    <option value="6">x6 (1550mm)</option>
                    <option value="7alt">x7 ALT (1825mm)</option>
                </select>
                <div id="connectorList" style="max-height: 150px; overflow-y: auto; font-size: 11px;"></div>
            </div>
            <!-- Panel Drabiny 2 (widoczny tylko w trybie attyki) -->
            <div id="ladder2Panel" style="display: none; background: rgba(0,0,0,0.85); padding: 10px; border-radius: 8px; border: 2px solid #2196F3; min-width: 130px;">
                <div style="color: #2196F3; font-weight: bold; text-align: center; margin-bottom: 5px; font-size: 12px;">Drabina 2</div>
                <select id="ladderSelect2" style="width: 100%; padding: 6px; background: #222; color: white; border: 1px solid #2196F3; border-radius: 4px; font-size: 12px; margin-bottom: 5px;">
                    <option value="0">Brak ko≈Ñcowej</option>
                    <option value="1">x1 (175mm)</option>
                    <option value="2">x2 (450mm)</option>
                    <option value="3">x3 (725mm)</option>
                    <option value="4">x4 (1000mm)</option>
                    <option value="5">x5 (1275mm)</option>
                    <option value="6">x6 (1550mm)</option>
                    <option value="7alt">x7 ALT (1825mm)</option>
                </select>
                <div id="connectorList2" style="max-height: 150px; overflow-y: auto; font-size: 11px;"></div>
            </div>
        </div>
        <!-- Wyb√≥r porƒôczy - zawsze na dole -->
        <div style="margin-top: 8px;">
            <select id="handrailSelect" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.85); color: white; border: 2px solid white; border-radius: 6px; font-size: 13px; font-weight: bold; cursor: pointer;">
                <option value="none">Brak porƒôczy</option>
                <option value="safety">Porƒôcze asekuracyjne</option>
                <option value="attic">Przej≈õcie przez attykƒô</option>
            </select>
        </div>
    </div>

    <!-- Kontrolki dla attyki - przyciski u g√≥ry (prawy g√≥rny r√≥g) -->
    <div id="atticControlsTop" style="display: none; position: fixed; top: 10px; right: 10px; z-index: 100;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px;">
            <button class="btn" id="add7Btn2" title="Dodaj x7 (Drabina 2)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">+7 <span style="font-size:9px;">D2</span></button>
            <button class="btn" id="add7Btn1" title="Dodaj x7 (Drabina 1)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">+7 <span style="font-size:9px;">D1</span></button>
            <button class="btn btn-remove" id="remove7Btn2" title="Usu≈Ñ x7 (Drabina 2)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">-7 <span style="font-size:9px;">D2</span></button>
            <button class="btn btn-remove" id="remove7Btn1" title="Usu≈Ñ x7 (Drabina 1)" style="margin-bottom: 0; font-size: 12px; padding: 8px;">-7 <span style="font-size:9px;">D1</span></button>
            <div></div>
            <button class="btn btn-tech" id="techBtn2" title="Rysunek techniczny" style="margin-bottom: 0;">üìê</button>
            <div></div>
            <button class="btn btn-tech" id="measureBtn2" title="Miarka" style="margin-bottom: 0;">üìè</button>
            <div></div>
            <button class="btn btn-tech" id="sciskaneBtn2" title="Uchwyty ≈õciskane" style="margin-bottom: 0;">üîß</button>
        </div>
    </div>
    <div id="status">Ladowanie...</div>
    
    <canvas id="techDrawing"></canvas>
    <button id="closeDrawing">‚úï</button>
    <button id="switchView">Widok z boku</button>

    <div id="rotationPanel">
        <h3>Zmie≈Ñ typ ≈ÇƒÖcznika</h3>
        <div class="rotation-row">
            <button class="rotation-btn" style="width: auto; padding: 10px 20px;" onclick="setConnectorTypeFromPanel('uchwyt')">Uchwyt</button>
            <button class="rotation-btn" style="width: auto; padding: 10px 20px;" onclick="setConnectorTypeFromPanel('lacznik')">≈ÅƒÖcznik</button>
        </div>
        <button id="closeRotation" onclick="closeRotationPanel()">Zamknij</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script>
        var statusDiv = document.getElementById('status');
        
        // Wymiary w mm (dla ≈Çatwiejszych oblicze≈Ñ, skalujemy p√≥≈∫niej do m)
        var DIMS = {
            rungWidth: 30,        // 30mm x 30mm
            rungHeight: 30,
            rungLength: 500,      // 500mm d≈Çugo≈õƒá szczebla
            railWidth: 50,        // 50mm profil pod≈Çu≈ºnicy (szeroko≈õƒá)
            railDepth: 30,        // 30mm profil pod≈Çu≈ºnicy (g≈Çƒôboko≈õƒá)
            firstRungFromTop: 130, // 130mm (13cm) od g√≥ry do pierwszego szczebla
            rungSpacing: 275,     // 275mm rozstaw miƒôdzy szczebami (g√≥ra do g√≥ra)
            
            // Porƒôcze asekuracyjne (odwr√≥cona litera L)
            handrailVertical: 1011,   // 1011mm przed≈Çu≈ºenie pionowe
            handrailHorizontal: 540,  // 540mm ramiƒô poziome
            handrailWidth: 30,        // 30mm szeroko≈õƒá profilu
            
            // Przej≈õcie przez attykƒô
            atticRailHeight: 1650,    // 1650mm wysoko≈õƒá pod≈Çu≈ºnic od ≈ÇƒÖczenia do g√≥ry
            atticRungs: 2,            // 2 dodatkowe szczeble
            
            // Ceownik ≈ÇƒÖczƒÖcy drabiny x7 (kszta≈Çt [)
            connectorHeight: 100,     // 100mm (10cm) wysoko≈õƒá ceownika
            connectorBackWidth: 56,   // 56mm tylna ≈õcianka (50mm + 6mm rozszerzenie)
            connectorArmDepth: 30,    // 30mm ramiona boczne (wƒÖskie)
            connectorThickness: 3,    // 3mm grubo≈õƒá ≈õcian ceownika
            
            // Wymiary ca≈Çkowite pod≈Çu≈ºnic dla r√≥≈ºnych ilo≈õci szczebli
            railHeights: {
                1: 175,
                2: 450,
                3: 725,
                4: 1000,
                5: 1275,
                6: 1550,
                7: 1922,
                '7alt': 1825  // Alternatywna drabina x7
            }
        };
        
        // Przelicz mm na jednostki Three.js (1 jednostka = 100mm dla lepszej skali)
        var SCALE = 0.01; // 1mm = 0.01 jednostek
        
        // Konfiguracja drabin - osobna dla ka≈ºdej drabiny przy przej≈õciu przez attykƒô
        var currentLadder = 1;  // Aktualnie edytowana drabina (1 lub 2)

        // Drabina 1 (przednia)
        var numX7Ladders1 = 0;
        var finalLadderRungs1 = 0;
        var connectorTypes1 = [];
        var sciskaneHandles1 = [];

        // Drabina 2 (tylna, 107cm do ty≈Çu, obr√≥cona 180¬∞)
        var numX7Ladders2 = 0;
        var finalLadderRungs2 = 0;
        var connectorTypes2 = [];
        var sciskaneHandles2 = [];

        // Centralna konfiguracja geometrii dla ka≈ºdej drabiny
        var ladderGeometryConfig = {
            1: {
                zOffset: 0,
                rotationZ: 0,  // Obr√≥t ca≈Çej drabiny w osi Z
                // ≈ÅƒÖczniki/Uchwyty (uchwyt.obj)
                connector: {
                    left: { x: Math.PI * 0.5, y: Math.PI, z: 0 },   // X=90¬∞, Y=180¬∞
                    right: { x: Math.PI * 0.5, y: 0, z: 0 },        // X=90¬∞
                    zOffset: 0,           // ≈ÅƒÖczniki (lacznik)
                    uchwytZOffset: 0      // Uchwyty (uchwyt)
                },
                // Uchwyty ≈õciskane (sciskany.obj)
                sciskane: {
                    left: { x: Math.PI * 0.5, y: Math.PI, z: 0 },   // Do g√≥ry nogami
                    right: { x: Math.PI * 0.5, y: 0, z: 0 },
                    leftZOffset: -55,   // Offset Z lewego
                    rightZOffset: -55   // Offset Z prawego
                }
            },
            2: {
                zOffset: -1070,
                rotationZ: Math.PI,  // Obr√≥t 180¬∞ w osi Z
                // ≈ÅƒÖczniki/Uchwyty - osobne dla drabiny 2
                connector: {
                    left: { x: Math.PI * 1.5, y: Math.PI, z: 0 },   // 180¬∞ w d√≥≈Ç + 180¬∞ w bok
                    right: { x: Math.PI * 1.5, y: 0, z: 0 },        // 180¬∞ w d√≥≈Ç + 180¬∞ w bok
                    zOffset: 0,           // ≈ÅƒÖczniki (lacznik) na 0
                    uchwytZOffset: 124    // Uchwyty (uchwyt) +124mm
                },
                // Uchwyty ≈õciskane - osobne dla drabiny 2
                sciskane: {
                    left: { x: Math.PI * 0.5, y: 0, z: Math.PI },
                    right: { x: Math.PI * 0.5, y: Math.PI, z: Math.PI },  // Odbicie lustrzane + 180¬∞ w bok
                    leftZOffset: 54,    // -55 + 109 = 54mm (109mm do przodu)
                    rightZOffset: 54    // -55 + 109 = 54mm (109mm do przodu)
                }
            }
        };

        // Aliasy do aktualnie edytowanej drabiny (dla kompatybilno≈õci)
        var numX7Ladders = 0;
        var finalLadderRungs = 0;
        var connectorTypes = [];
        var sciskaneHandles = [];

        var handrailType = 'none';  // Typ porƒôczy: 'none', 'safety', 'attic'
        var sciskaneMode = false;  // Tryb dodawania uchwyt√≥w ≈õciskanych
        var sciskanePreviewObjects = [];  // Obiekty podglƒÖdu
        var sciskanePlacedObjects = [];  // Umieszczone uchwyty ≈õciskane

        // Za≈Çadowane modele OBJ
        var loadedModels = {
            powielana: null,  // drabinapowielana.obj (x7 standardowa)
            koncowa: {},      // koncowa-x1.obj do koncowa-x7.obj
            uchwyt: null,     // uchwyt.obj
            lacznik: null,    // lacznik.obj
            porecz: null,     // porecz.obj
            uchwytPoreczy: null,  // uchwyt poreczy.obj
            attyka: null,     // przejscieprzezattyke.obj
            krataWema: null,  // krata wema.obj
            sciskany: null    // uchwyt sciskany.obj
        };
        var modelsLoaded = false;

        // Typ ≈ÇƒÖcznika dla ka≈ºdego po≈ÇƒÖczenia (tablica: 'uchwyt' lub 'lacznik')
        var connectorTypes = [];

        // Funkcja ≈Çadowania wszystkich modeli OBJ
        function loadAllModels(callback) {
            var loader = new THREE.OBJLoader();
            var modelsToLoad = 15; // 1 powielana + 7 ko≈Ñcowych + uchwyt + lacznik + porecz + uchwyt poreczy + attyka + krata wema + sciskany
            var modelsLoadedCount = 0;

            // Materia≈Ç dla modeli
            var modelMaterial = new THREE.MeshStandardMaterial({
                color: 0xF8F8FC,  // kolor ocynku (bia≈Çy)
                metalness: 0.8,
                roughness: 0.3
            });

            function onModelLoaded() {
                modelsLoadedCount++;
                statusDiv.innerHTML = '≈Åadowanie modeli: ' + modelsLoadedCount + '/' + modelsToLoad;
                if (modelsLoadedCount === modelsToLoad) {
                    modelsLoaded = true;
                    callback();
                }
            }

            function applyMaterial(obj) {
                // Oblicz bounding box
                var box = new THREE.Box3().setFromObject(obj);
                var center = box.getCenter(new THREE.Vector3());
                var size = box.getSize(new THREE.Vector3());

                // Utw√≥rz kontener i przesu≈Ñ model do ≈õrodka
                var container = new THREE.Group();
                obj.position.set(-center.x, -center.y, -center.z);
                container.add(obj);

                // Zastosuj materia≈Ç
                obj.traverse(function(child) {
                    if (child.isMesh) {
                        child.material = modelMaterial.clone();
                    }
                });

                // Zapisz wymiary modelu
                container.userData.originalHeight = size.y;
                container.userData.originalWidth = size.x;
                container.userData.originalDepth = size.z;

                console.log('Model za≈Çadowany, wymiary (mm):', size.x.toFixed(0), 'x', size.y.toFixed(0), 'x', size.z.toFixed(0));

                return container;
            }

            // ≈Åaduj drabinapowielana.obj
            loader.load('drabinapowielana.obj', function(obj) {
                loadedModels.powielana = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania drabinapowielana.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj koncowa-x1.obj do koncowa-x7.obj
            for (var i = 1; i <= 7; i++) {
                (function(index) {
                    loader.load('koncowa-x' + index + '.obj', function(obj) {
                        loadedModels.koncowa[index] = applyMaterial(obj);
                        onModelLoaded();
                    }, undefined, function(err) {
                        console.error('B≈ÇƒÖd ≈Çadowania koncowa-x' + index + '.obj:', err);
                        onModelLoaded();
                    });
                })(i);
            }

            // ≈Åaduj uchwyt.obj
            loader.load('uchwyt.obj', function(obj) {
                loadedModels.uchwyt = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania uchwyt.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj lacznik.obj
            loader.load('lacznik.obj', function(obj) {
                loadedModels.lacznik = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania lacznik.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj porecz.obj
            loader.load('porecz.obj', function(obj) {
                loadedModels.porecz = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania porecz.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj uchwyt poreczy.obj
            loader.load('uchwyt poreczy.obj', function(obj) {
                loadedModels.uchwytPoreczy = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania uchwyt poreczy.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj przejscieprzezattyke.obj
            loader.load('przejscieprzezattyke.obj', function(obj) {
                loadedModels.attyka = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania przejscieprzezattyke.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj krata wema.obj
            loader.load('krata wema.obj', function(obj) {
                loadedModels.krataWema = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania krata wema.obj:', err);
                onModelLoaded();
            });

            // ≈Åaduj uchwyt sciskany.obj
            loader.load('uchwyt sciskany.obj', function(obj) {
                loadedModels.sciskany = applyMaterial(obj);
                onModelLoaded();
            }, undefined, function(err) {
                console.error('B≈ÇƒÖd ≈Çadowania uchwyt sciskany.obj:', err);
                // Fallback - u≈ºyj zwyk≈Çego uchwytu je≈õli nie ma modelu ≈õciskanego
                onModelLoaded();
            });
        }

        // Synchronizuj aliasy z aktualnƒÖ drabinƒÖ
        function syncLadderAliases() {
            if (currentLadder === 1) {
                numX7Ladders = numX7Ladders1;
                finalLadderRungs = finalLadderRungs1;
                connectorTypes = connectorTypes1;
                sciskaneHandles = sciskaneHandles1;
            } else {
                numX7Ladders = numX7Ladders2;
                finalLadderRungs = finalLadderRungs2;
                connectorTypes = connectorTypes2;
                sciskaneHandles = sciskaneHandles2;
            }
        }

        // Zapisz aliasy do aktualnej drabiny
        function saveLadderAliases() {
            if (currentLadder === 1) {
                numX7Ladders1 = numX7Ladders;
                finalLadderRungs1 = finalLadderRungs;
                connectorTypes1 = connectorTypes;
                sciskaneHandles1 = sciskaneHandles;
            } else {
                numX7Ladders2 = numX7Ladders;
                finalLadderRungs2 = finalLadderRungs;
                connectorTypes2 = connectorTypes;
                sciskaneHandles2 = sciskaneHandles;
            }
        }

        // Prze≈ÇƒÖcz na wybranƒÖ drabinƒô
        function switchToLadder(ladderNum) {
            saveLadderAliases();  // Zapisz obecne ustawienia
            currentLadder = ladderNum;
            syncLadderAliases();  // Wczytaj ustawienia nowej drabiny
        }

        function getLadderHeight(rungs) {
            return DIMS.railHeights[rungs];
        }

        // Oblicz wysoko≈õƒá dla konkretnej drabiny (1 lub 2)
        function getTotalHeightForLadder(ladderNum) {
            var x7Count = (ladderNum === 1) ? numX7Ladders1 : numX7Ladders2;
            var finalRungs = (ladderNum === 1) ? finalLadderRungs1 : finalLadderRungs2;

            var total = x7Count * getLadderHeight(7);
            if (finalRungs === '7alt') {
                total += getLadderHeight('7alt');
            } else if (finalRungs > 0) {
                total += getLadderHeight(finalRungs);
            }
            return total;
        }

        function getTotalHeight() {
            var total = numX7Ladders * getLadderHeight(7);
            if (finalLadderRungs === '7alt') {
                total += getLadderHeight('7alt');
            } else if (finalLadderRungs > 0) {
                total += getLadderHeight(finalLadderRungs);
            }

            // Attyka NIE dodaje do wysoko≈õci - jest na g√≥rze

            return total;
        }

        // Wysoko≈õƒá ko≈Ñcowej drabiny (koncowa)
        function getKoncowaHeight() {
            if (finalLadderRungs === '7alt') {
                return getLadderHeight('7alt');
            } else if (finalLadderRungs > 0) {
                return getLadderHeight(finalLadderRungs);
            }
            return 0;
        }
        
        function getLadderSections() {
            var sections = [];

            // Dodaj wszystkie drabiny x7 standardowe
            for (var i = 0; i < numX7Ladders; i++) {
                sections.push({rungs: 7, type: 'standard'});
            }

            // Dodaj ko≈ÑcowƒÖ drabinƒô (je≈õli jest)
            if (finalLadderRungs === '7alt') {
                sections.push({rungs: 7, type: 'alt'});
            } else if (finalLadderRungs > 0) {
                sections.push({rungs: finalLadderRungs, type: 'final'});
            }

            return sections;
        }

        // Pobierz sekcje dla konkretnej drabiny (1 lub 2)
        function getLadderSectionsForLadder(ladderNum) {
            var x7Count = (ladderNum === 1) ? numX7Ladders1 : numX7Ladders2;
            var finalRungs = (ladderNum === 1) ? finalLadderRungs1 : finalLadderRungs2;
            var sections = [];

            for (var i = 0; i < x7Count; i++) {
                sections.push({rungs: 7, type: 'standard'});
            }

            if (finalRungs === '7alt') {
                sections.push({rungs: 7, type: 'alt'});
            } else if (finalRungs > 0) {
                sections.push({rungs: finalRungs, type: 'final'});
            }

            return sections;
        }

        // Pobierz typ ≈ÇƒÖcznik√≥w dla konkretnej drabiny
        function getConnectorTypesForLadder(ladderNum) {
            return (ladderNum === 1) ? connectorTypes1 : connectorTypes2;
        }

        // Obs≈Çuga klikania na ≈ÇƒÖczniki
        var selectedConnector = null;
        var connectorObjects = [];  // Lista wszystkich ≈ÇƒÖcznik√≥w w scenie
        var raycaster = null;
        var mouse = new THREE.Vector2();

        var selectedPairIndex = null;

        // Miarka
        var measureMode = false;
        var measurePoint1 = null;
        var measurePoint2 = null;
        var measureLine = null;
        var measureLabel = null;

        function closeRotationPanel() {
            document.getElementById('rotationPanel').classList.remove('active');
            selectedConnector = null;
            selectedPairIndex = null;
        }

        function openRotationPanel(connector) {
            selectedConnector = connector;
            selectedPairIndex = connector.userData.pairIndex;

            // Sprawd≈∫ czy to uchwyt porƒôczy (nie mo≈ºna zmieniƒá)
            if (handrailType === 'safety' && selectedPairIndex === 0) {
                return; // Nie otwieraj panelu dla uchwytu porƒôczy
            }

            document.getElementById('rotationPanel').classList.add('active');
        }

        function setConnectorTypeFromPanel(type) {
            if (selectedPairIndex === null || !selectedConnector) return;

            // U≈ºyj ladderNum z klikniƒôtego ≈ÇƒÖcznika, nie aktualnie zaznaczonej drabiny
            var clickedLadderNum = selectedConnector.userData.ladderNum || 1;
            var targetConnectorTypes = (clickedLadderNum === 1) ? connectorTypes1 : connectorTypes2;
            targetConnectorTypes[selectedPairIndex] = type;

            closeRotationPanel();
            createLadder();
        }

        // Funkcje miarki
        function toggleMeasureMode() {
            measureMode = !measureMode;
            var btn = document.getElementById('measureBtn');
            if (measureMode) {
                btn.style.background = 'rgba(0, 200, 100, 0.9)';
                btn.style.border = '2px solid lime';
                measurePoint1 = null;
                measurePoint2 = null;
                clearMeasureLine();
                document.getElementById('measureResult').style.display = 'none';
            } else {
                btn.style.background = 'rgba(50, 100, 200, 0.9)';
                btn.style.border = '2px solid white';
                clearMeasureLine();
            }
        }

        function clearMeasureLine() {
            if (measureLine) {
                scene.remove(measureLine);
                measureLine = null;
            }
        }

        function addMeasurePoint(point) {
            if (!measurePoint1) {
                measurePoint1 = point.clone();
                // Dodaj wizualnƒÖ kulkƒô w punkcie 1
            } else {
                measurePoint2 = point.clone();
                // Oblicz odleg≈Ço≈õƒá
                var distance = measurePoint1.distanceTo(measurePoint2);
                var distanceMM = Math.round(distance / SCALE);  // przelicz na mm

                // Narysuj liniƒô miƒôdzy punktami
                var geometry = new THREE.BufferGeometry().setFromPoints([measurePoint1, measurePoint2]);
                var material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
                measureLine = new THREE.Line(geometry, material);
                scene.add(measureLine);

                // Wy≈õwietl wynik
                var resultDiv = document.getElementById('measureResult');
                resultDiv.innerHTML = distanceMM + ' mm<br><span style="font-size: 14px;">(' + (distanceMM/10).toFixed(1) + ' cm)</span><br><button onclick="closeMeasureResult()" style="margin-top: 10px; padding: 5px 15px; cursor: pointer;">OK</button>';
                resultDiv.style.display = 'block';

                // Reset dla nastƒôpnego pomiaru
                measurePoint1 = null;
                measurePoint2 = null;
            }
        }

        function closeMeasureResult() {
            document.getElementById('measureResult').style.display = 'none';
            clearMeasureLine();
        }

        // Funkcje uchwyt√≥w ≈õciskanych
        function toggleSciskaneMode() {
            sciskaneMode = !sciskaneMode;
            var btn = document.getElementById('sciskaneBtn');
            if (sciskaneMode) {
                btn.style.background = 'rgba(0, 200, 100, 0.9)';
                btn.style.border = '2px solid lime';
                // Wy≈ÇƒÖcz tryb miarki je≈õli aktywny
                if (measureMode) {
                    toggleMeasureMode();
                }
                createSciskanePreview();
            } else {
                btn.style.background = 'rgba(50, 100, 200, 0.9)';
                btn.style.border = '2px solid white';
                clearSciskanePreview();
            }
        }

        function getConnectorPositions() {
            // Zwraca listƒô pozycji Y (w mm) gdzie sƒÖ ≈ÇƒÖczniki dla aktualnie edytowanej drabiny
            var positions = [];
            var sections = getLadderSectionsForLadder(currentLadder);
            var ladderTotalHeight = getTotalHeightForLadder(currentLadder);

            // Oblicz maxHeight dla wyr√≥wnania g√≥r
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // G√≥ra drabiny - wyr√≥wnana do maxHeight
            if ((handrailType === 'safety' || handrailType === 'attic') && sections.length > 0) {
                var topY = (maxHeight / 2) - (DIMS.connectorHeight / 2) - 50;
                if (handrailType === 'attic') {
                    topY += 100;  // offset dla attyki
                } else {
                    topY += 50;  // offset dla porƒôczy
                }
                positions.push(topY);
            }

            // Miƒôdzy sekcjami
            var currentOffset = 0;
            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                currentOffset += sectionHeight;

                if (i < sections.length - 1) {
                    var connectionY = (maxHeight / 2) - currentOffset + (DIMS.connectorHeight / 2) - 50;
                    positions.push(connectionY);
                }
            }

            return positions;
        }

        function isPositionValidForSciskane(yPos, ladderNum) {
            // U≈ºyj podanego numeru drabiny lub aktualnie edytowanej
            var targetLadder = ladderNum || currentLadder;
            var ladderTotalHeight = getTotalHeightForLadder(targetLadder);
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            var connectorPositions = getConnectorPositions();
            var currentHandles = (targetLadder === 1) ? sciskaneHandles1 : sciskaneHandles2;
            var minDistance = 150;  // Minimalna odleg≈Ço≈õƒá 15cm od ≈ÇƒÖcznika

            for (var i = 0; i < connectorPositions.length; i++) {
                if (Math.abs(yPos - connectorPositions[i]) < minDistance) {
                    return false;
                }
            }

            // Przelicz yPos na offset od do≈Çu (d√≥≈Ç tej drabiny = maxHeight/2 - ladderTotalHeight)
            var offsetFromBottom = yPos - (maxHeight / 2 - ladderTotalHeight);

            // Sprawd≈∫ czy ju≈º nie ma pary w tym miejscu
            for (var j = 0; j < currentHandles.length; j++) {
                if (Math.abs(currentHandles[j].offsetFromBottom - offsetFromBottom) < 10) {
                    return false;  // Ju≈º jest para w tym miejscu (tolerancja 10mm)
                }
            }

            return true;
        }

        function createSciskanePreview() {
            clearSciskanePreview();

            var railOffset = 265;

            // Oblicz maxHeight dla wyr√≥wnania g√≥r
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Utw√≥rz materia≈Çy podglƒÖdu
            var previewMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                metalness: 0.5,
                roughness: 0.5,
                transparent: true,
                opacity: 0.4
            });

            var sourceModel = loadedModels.sciskany || loadedModels.uchwyt;
            if (!sourceModel) return;

            // Okre≈õl kt√≥re drabiny pokazaƒá - obie przy attyce
            var laddersToPreview = [1];
            if (handrailType === 'attic') {
                laddersToPreview.push(2);
            }

            // Generuj podglƒÖd dla ka≈ºdej drabiny
            for (var ladderIdx = 0; ladderIdx < laddersToPreview.length; ladderIdx++) {
                var ladderNum = laddersToPreview[ladderIdx];
                var sections = getLadderSectionsForLadder(ladderNum);
                if (sections.length === 0) continue;

                var ladderTotalHeight = getTotalHeightForLadder(ladderNum);
                var geoConfig = ladderGeometryConfig[ladderNum];

                // Generuj pozycje podglƒÖdu dla tej drabiny
                var previewPositions = [];
                var currentOffset = 0;

                for (var s = 0; s < sections.length; s++) {
                    var section = sections[s];
                    var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);

                    for (var i = 0; i < section.rungs - 1; i++) {
                        var yPos = (maxHeight / 2) - currentOffset - DIMS.firstRungFromTop - (i * DIMS.rungSpacing) - DIMS.rungSpacing / 2;
                        if (isPositionValidForSciskane(yPos, ladderNum)) {
                            previewPositions.push(yPos);
                        }
                    }

                    currentOffset += sectionHeight;
                }

                // Utw√≥rz obiekty podglƒÖdu dla tej drabiny
                for (var p = 0; p < previewPositions.length; p++) {
                    var yPos = previewPositions[p];

                    // Lewy uchwyt
                    var leftRot = geoConfig.sciskane.left;
                    var leftPreview = sourceModel.clone(true);
                    leftPreview.scale.set(SCALE, SCALE, SCALE);
                    leftPreview.rotation.set(leftRot.x, leftRot.y, leftRot.z);
                    leftPreview.position.x = -railOffset * SCALE;
                    leftPreview.position.y = yPos * SCALE;
                    leftPreview.position.z = (geoConfig.sciskane.leftZOffset + geoConfig.zOffset) * SCALE;
                    leftPreview.traverse(function(child) {
                        if (child.isMesh) {
                            child.material = previewMaterial.clone();
                        }
                    });
                    leftPreview.userData.isSciskanePreview = true;
                    leftPreview.userData.previewY = yPos;
                    leftPreview.userData.previewSide = 'left';
                    leftPreview.userData.ladderNum = ladderNum;
                    ladderContainer.add(leftPreview);
                    sciskanePreviewObjects.push(leftPreview);

                    // Prawy uchwyt
                    var rightRot = geoConfig.sciskane.right;
                    var rightPreview = sourceModel.clone(true);
                    rightPreview.scale.set(SCALE, SCALE, SCALE);
                    rightPreview.rotation.set(rightRot.x, rightRot.y, rightRot.z);
                    rightPreview.position.x = railOffset * SCALE;
                    rightPreview.position.y = yPos * SCALE;
                    rightPreview.position.z = (geoConfig.sciskane.rightZOffset + geoConfig.zOffset) * SCALE;
                    rightPreview.traverse(function(child) {
                        if (child.isMesh) {
                            child.material = previewMaterial.clone();
                        }
                    });
                    rightPreview.userData.isSciskanePreview = true;
                    rightPreview.userData.previewY = yPos;
                    rightPreview.userData.previewSide = 'right';
                    rightPreview.userData.ladderNum = ladderNum;
                    ladderContainer.add(rightPreview);
                    sciskanePreviewObjects.push(rightPreview);
                }
            }
        }

        function clearSciskanePreview() {
            for (var i = 0; i < sciskanePreviewObjects.length; i++) {
                if (sciskanePreviewObjects[i].parent === ladderContainer) {
                    ladderContainer.remove(sciskanePreviewObjects[i]);
                }
            }
            sciskanePreviewObjects = [];
        }

        function addSciskaneHandle(yPos, ladderNum) {
            // U≈ºyj podanego numeru drabiny lub aktualnie edytowanej
            var targetLadder = ladderNum || currentLadder;
            var currentHandles = (targetLadder === 1) ? sciskaneHandles1 : sciskaneHandles2;
            var ladderTotalHeight = getTotalHeightForLadder(targetLadder);

            // Oblicz maxHeight dla wyr√≥wnania
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Przelicz Y na offset od DO≈ÅU drabiny
            // D√≥≈Ç tej drabiny = maxHeight/2 - ladderTotalHeight
            var offsetFromBottom = yPos - (maxHeight / 2 - ladderTotalHeight);

            // Sprawd≈∫ czy ju≈º nie ma pary w tym miejscu
            var existingIndex = -1;
            for (var i = 0; i < currentHandles.length; i++) {
                if (currentHandles[i].offsetFromBottom === offsetFromBottom) {
                    existingIndex = i;
                    break;
                }
            }

            if (existingIndex >= 0) {
                // Usu≈Ñ parƒô je≈õli ju≈º istnieje (toggle)
                currentHandles.splice(existingIndex, 1);
            } else {
                // Dodaj nowƒÖ parƒô (zapisujemy offset od do≈Çu)
                currentHandles.push({ offsetFromBottom: offsetFromBottom });
            }

            // Zapisz do odpowiedniej drabiny
            if (targetLadder === 1) {
                sciskaneHandles1 = currentHandles;
            } else {
                sciskaneHandles2 = currentHandles;
            }

            // createLadder() automatycznie wywo≈Çuje renderSciskaneHandles() i createSciskanePreview()
            createLadder();
        }

        function renderSciskaneHandles() {
            // Wyczy≈õƒá poprzednie (ju≈º usuniƒôte przez createLadder, ale czy≈õcimy tablicƒô)
            sciskanePlacedObjects = [];

            var sourceModel = loadedModels.sciskany || loadedModels.uchwyt;
            if (!sourceModel) return;

            var railOffset = 265;

            // Okre≈õl kt√≥re drabiny renderowaƒá
            var laddersToRender = [1];
            if (handrailType === 'attic') {
                laddersToRender.push(2);
            }

            // Oblicz maksymalnƒÖ wysoko≈õƒá dla wyr√≥wnania g√≥r
            var height1 = getTotalHeightForLadder(1);
            var height2 = getTotalHeightForLadder(2);
            var maxHeight = Math.max(height1, height2);

            // Renderuj uchwyty dla ka≈ºdej drabiny osobno
            for (var ladderIdx = 0; ladderIdx < laddersToRender.length; ladderIdx++) {
                var ladderNum = laddersToRender[ladderIdx];
                var geoConfig = ladderGeometryConfig[ladderNum];
                var ladderHandles = (ladderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                var ladderTotalHeight = getTotalHeightForLadder(ladderNum);

                // Filtruj uchwyty - usu≈Ñ te poza zakresem drabiny
                if (ladderNum === 1) {
                    sciskaneHandles1 = sciskaneHandles1.filter(function(handle) {
                        return handle.offsetFromBottom >= 50 && handle.offsetFromBottom <= ladderTotalHeight - 50;
                    });
                    ladderHandles = sciskaneHandles1;
                } else {
                    sciskaneHandles2 = sciskaneHandles2.filter(function(handle) {
                        return handle.offsetFromBottom >= 50 && handle.offsetFromBottom <= ladderTotalHeight - 50;
                    });
                    ladderHandles = sciskaneHandles2;
                }

                for (var i = 0; i < ladderHandles.length; i++) {
                    var handle = ladderHandles[i];
                    // Przelicz offset od do≈Çu na rzeczywistƒÖ pozycjƒô Y (wyr√≥wnane g√≥rƒÖ)
                    var actualY = (maxHeight / 2) - ladderTotalHeight + handle.offsetFromBottom;

                    // Lewy uchwyt - u≈ºywa centralnej konfiguracji
                    var leftRot = geoConfig.sciskane.left;
                    var leftModel = sourceModel.clone(true);
                    leftModel.scale.set(SCALE, SCALE, SCALE);
                    leftModel.rotation.set(leftRot.x, leftRot.y, leftRot.z);
                    leftModel.position.x = -railOffset * SCALE;
                    leftModel.position.y = actualY * SCALE;
                    leftModel.position.z = (geoConfig.sciskane.leftZOffset + geoConfig.zOffset) * SCALE;
                    leftModel.userData.isSciskanePlaced = true;
                    leftModel.userData.sciskaneOffsetFromBottom = handle.offsetFromBottom;
                    leftModel.userData.ladderNum = ladderNum;
                    ladderContainer.add(leftModel);
                    sciskanePlacedObjects.push(leftModel);

                    // Prawy uchwyt - u≈ºywa centralnej konfiguracji
                    var rightRot = geoConfig.sciskane.right;
                    var rightModel = sourceModel.clone(true);
                    rightModel.scale.set(SCALE, SCALE, SCALE);
                    rightModel.rotation.set(rightRot.x, rightRot.y, rightRot.z);
                    rightModel.position.x = railOffset * SCALE;
                    rightModel.position.y = actualY * SCALE;
                    rightModel.position.z = (geoConfig.sciskane.rightZOffset + geoConfig.zOffset) * SCALE;
                    rightModel.userData.isSciskanePlaced = true;
                    rightModel.userData.sciskaneOffsetFromBottom = handle.offsetFromBottom;
                    rightModel.userData.ladderNum = ladderNum;
                    ladderContainer.add(rightModel);
                    sciskanePlacedObjects.push(rightModel);
                }
            }
        }

        try {
            statusDiv.innerHTML = 'Inicjalizacja...';
            
            // Scena
            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Kamera
            var camera = new THREE.PerspectiveCamera(
                60, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                200
            );
            camera.position.z = 50;
            camera.position.y = 0;
            camera.lookAt(0, 0, 0);
            
            // Renderer
            var renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Raycaster do klikania na obiekty
            raycaster = new THREE.Raycaster();

            // Swiatla
            var ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            var light1 = new THREE.DirectionalLight(0xffffff, 0.6);
            light1.position.set(10, 10, 10);
            scene.add(light1);
            
            var light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(-10, -10, -10);
            scene.add(light2);
            
            // Kontener na drabinkƒô
            var ladderContainer = new THREE.Group();
            scene.add(ladderContainer);
            
            // Materia≈Çy
            var railMaterial = new THREE.MeshStandardMaterial({
                color: 0xF8F8FC,  // kolor ocynku (bia≈Çy)
                metalness: 0.8,
                roughness: 0.3
            });

            var rungMaterial = new THREE.MeshStandardMaterial({
                color: 0xF8F8FC,  // kolor ocynku (bia≈Çy)
                metalness: 0.8,
                roughness: 0.3
            });

            // Materia≈Ç dla ceownik√≥w
            var connectorMaterial = new THREE.MeshStandardMaterial({
                color: 0xF8F8FC,  // kolor ocynku (bia≈Çy)
                metalness: 0.8,
                roughness: 0.3
            });
            
            // Funkcja tworzƒÖca ≈ÇƒÖcznik z modelu OBJ
            // type: 'uchwyt', 'lacznik' lub 'uchwytPoreczy'
            // side: 'left' lub 'right', ladderNum: 1 lub 2
            function createConnector(type, side, ladderNum) {
                type = type || 'uchwyt';
                side = side || 'left';
                ladderNum = ladderNum || 1;

                var sourceModel = null;
                if (type === 'lacznik' && loadedModels.lacznik) {
                    sourceModel = loadedModels.lacznik;
                } else if (type === 'uchwytPoreczy' && loadedModels.uchwytPoreczy) {
                    sourceModel = loadedModels.uchwytPoreczy;
                } else if (loadedModels.uchwyt) {
                    sourceModel = loadedModels.uchwyt;
                }

                if (sourceModel) {
                    var model = sourceModel.clone(true);
                    model.scale.set(SCALE, SCALE, SCALE);

                    // Pobierz rotacjƒô z centralnej konfiguracji
                    var geoConfig = ladderGeometryConfig[ladderNum];
                    var rot = geoConfig.connector[side];
                    model.rotation.set(rot.x, rot.y, rot.z);

                    // Oznacz jako ≈ÇƒÖcznik (klikalny)
                    model.userData.isConnector = true;
                    model.userData.ladderNum = ladderNum;
                    connectorObjects.push(model);
                    return model;
                }

                // Fallback - pusty group je≈õli model nie za≈Çadowany
                return new THREE.Group();
            }
            
            function createLadder() {
                // Wyczy≈õƒá poprzedniƒÖ drabinkƒô
                while(ladderContainer.children.length > 0) {
                    ladderContainer.remove(ladderContainer.children[0]);
                }
                // Wyczy≈õƒá listƒô ≈ÇƒÖcznik√≥w
                connectorObjects = [];

                // Okre≈õl kt√≥re drabiny renderowaƒá
                var laddersToRender = [1];  // Zawsze drabina 1
                if (handrailType === 'attic') {
                    laddersToRender.push(2);  // Dodaj drabinƒô 2 przy attyce
                }

                // Oblicz wysoko≈õci obu drabin i znajd≈∫ najwy≈ºszƒÖ
                var height1 = getTotalHeightForLadder(1);
                var height2 = getTotalHeightForLadder(2);
                var maxHeight = Math.max(height1, height2);

                // Dla kompatybilno≈õci - u≈ºywamy alias√≥w lub drabiny 1
                var sections = getLadderSections();
                var totalHeight = getTotalHeight();

                // Generuj sekcje dla ka≈ºdej drabiny - WYR√ìWNANE G√ìRƒÑ
                for (var ladderIdx = 0; ladderIdx < laddersToRender.length; ladderIdx++) {
                    var ladderNum = laddersToRender[ladderIdx];
                    var geoConfig = ladderGeometryConfig[ladderNum];
                    var ladderSections = getLadderSectionsForLadder(ladderNum);
                    var ladderTotalHeight = getTotalHeightForLadder(ladderNum);

                    var currentHeightOffset = 0;

                    for (var s = 0; s < ladderSections.length; s++) {
                        var section = ladderSections[s];
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        var model = null;

                        var sourceModel = null;
                        if (section.type === 'standard' && loadedModels.powielana) {
                            sourceModel = loadedModels.powielana;
                        } else if (section.type === 'alt' && loadedModels.koncowa[7]) {
                            sourceModel = loadedModels.koncowa[7];
                        } else if (section.type === 'final' && loadedModels.koncowa[section.rungs]) {
                            sourceModel = loadedModels.koncowa[section.rungs];
                        }

                        if (sourceModel) {
                            // G≈Çƒôbokie klonowanie
                            model = sourceModel.clone(true);

                            // Rotacja o 270 stopni (model z Fusion360) + opcjonalny obr√≥t Z dla drabiny 2
                            model.rotation.x = Math.PI * 1.5;
                            model.rotation.z = geoConfig.rotationZ;

                            // Skalowanie: model w mm, Three.js w jednostkach (1 jednostka = 100mm)
                            model.scale.set(SCALE, SCALE, SCALE);

                            // Pozycja Y - obie drabiny zaczynajƒÖ od g√≥ry (maxHeight/2) i rosnƒÖ w d√≥≈Ç
                            // Najd≈Çu≈ºsza drabina definiuje Y=0 (jej ≈õrodek), kr√≥tsza ma g√≥ry na tym samym poziomie
                            var yPos = (maxHeight / 2) - currentHeightOffset - (sectionHeight / 2);
                            model.position.y = yPos * SCALE;
                            model.position.z = geoConfig.zOffset * SCALE;

                            // Oznacz do kt√≥rej drabiny nale≈ºy
                            model.userData.ladderNum = ladderNum;

                            ladderContainer.add(model);
                        }

                        currentHeightOffset += sectionHeight;
                    }
                }

                // U≈ºyj NAJWY≈ªSZEJ drabiny dla attyki i porƒôczy
                var totalHeight = maxHeight;

                var railOffset = 265;  // 265mm odstƒôp od ≈õrodka do wewnƒôtrznej krawƒôdzi profilu
                
                // Dodaj porƒôcze lub przej≈õcie przez attykƒô
                if (handrailType === 'safety') {
                    // PORƒòCZE ASEKURACYJNE - model 3D
                    var topOfLadder = (totalHeight / 2);

                    // Lewa porƒôcz
                    if (loadedModels.porecz) {
                        var leftPorecz = loadedModels.porecz.clone(true);
                        leftPorecz.scale.set(SCALE, SCALE, SCALE);
                        leftPorecz.rotation.set(Math.PI * 1.5, 0, Math.PI);  // +180 stopni w Z
                        leftPorecz.position.x = -railOffset * SCALE;
                        leftPorecz.position.y = (topOfLadder + DIMS.handrailVertical / 2 + 50) * SCALE;  // +5cm do g√≥ry
                        leftPorecz.position.z = -245.5 * SCALE;  // 24.55cm do ty≈Çu
                        ladderContainer.add(leftPorecz);
                    }

                    // Prawa porƒôcz
                    if (loadedModels.porecz) {
                        var rightPorecz = loadedModels.porecz.clone(true);
                        rightPorecz.scale.set(SCALE, SCALE, SCALE);
                        rightPorecz.rotation.set(Math.PI * 1.5, 0, Math.PI);  // +180 stopni w Z
                        rightPorecz.position.x = railOffset * SCALE;
                        rightPorecz.position.y = (topOfLadder + DIMS.handrailVertical / 2 + 50) * SCALE;  // +5cm do g√≥ry
                        rightPorecz.position.z = -245.5 * SCALE;  // 24.55cm do ty≈Çu
                        ladderContainer.add(rightPorecz);
                    }
                } else if (handrailType === 'attic') {
                    // PRZEJ≈öCIE PRZEZ ATTYKƒò - jeden model 3D
                    var topOfMainRails = (totalHeight / 2);

                    if (loadedModels.attyka) {
                        var attyka = loadedModels.attyka.clone(true);
                        attyka.scale.set(SCALE, SCALE, SCALE);
                        attyka.rotation.set(Math.PI * 1.5, 0, 0);
                        attyka.position.x = 0;  // wy≈õrodkowane
                        attyka.position.y = (topOfMainRails + DIMS.atticRailHeight / 2) * SCALE;
                        attyka.position.z = -535 * SCALE;  // 53.5cm do ty≈Çu (+5mm do przodu)
                        ladderContainer.add(attyka);
                    }

                    // Krata WEMA
                    if (loadedModels.krataWema) {
                        var krata = loadedModels.krataWema.clone(true);
                        krata.scale.set(SCALE, SCALE, SCALE);
                        krata.rotation.set(Math.PI * 1.5, 0, 0);
                        krata.position.x = 0;
                        krata.position.y = (topOfMainRails + DIMS.atticRailHeight / 2 - 430) * SCALE;  // 43cm w d√≥≈Ç
                        krata.position.z = -535 * SCALE;  // 53.5cm do ty≈Çu (+5mm do przodu)
                        ladderContainer.add(krata);
                    }
                }
                
                // Dodaj ceowniki na wszystkich po≈ÇƒÖczeniach
                var railOffset = 265;  // 265mm odstƒôp od ≈õrodka

                // Generuj ≈ÇƒÖczniki dla ka≈ºdej drabiny osobno
                for (var connLadderIdx = 0; connLadderIdx < laddersToRender.length; connLadderIdx++) {
                    var connLadderNum = laddersToRender[connLadderIdx];
                    var connSections = getLadderSectionsForLadder(connLadderNum);
                    var connTotalHeight = getTotalHeightForLadder(connLadderNum);
                    var connConnectorTypes = getConnectorTypesForLadder(connLadderNum);

                    // Oblicz ile par ≈ÇƒÖcznik√≥w potrzebujemy dla tej drabiny
                    var numConnectorPairs = 0;
                    if ((handrailType === 'safety' || handrailType === 'attic') && connSections.length > 0) {
                        numConnectorPairs++;  // Para na g√≥rze
                    }
                    numConnectorPairs += Math.max(0, connSections.length - 1);  // Pary miƒôdzy sekcjami

                    // Inicjalizuj tablicƒô connectorTypes dla tej drabiny je≈õli trzeba
                    while (connConnectorTypes.length < numConnectorPairs) {
                        connConnectorTypes.push('uchwyt');
                    }
                    while (connConnectorTypes.length > numConnectorPairs) {
                        connConnectorTypes.pop();
                    }

                    var pairIndex = 0;

                    // 1. Ceownik na g√≥rze (je≈õli sƒÖ porƒôcze lub attyka)
                    if ((handrailType === 'safety' || handrailType === 'attic') && connSections.length > 0) {
                        // G√≥ra jest wyr√≥wnana do maxHeight/2
                        var topY = (maxHeight / 2) - (DIMS.connectorHeight / 2) - 50;

                        // Przy porƒôczach u≈ºywamy uchwyt poreczy z innymi koordynatami
                        // Przy attyce u≈ºywamy zwyk≈Çe uchwyty z normalnymi koordynatami
                        var topConnectorType = (handrailType === 'safety') ? 'uchwytPoreczy' : connConnectorTypes[pairIndex];

                        var topConnectorZ, topConnectorYOffset;
                        if (handrailType === 'safety') {
                            topConnectorZ = 0;  // uchwyt porƒôczy
                            topConnectorYOffset = 50;  // 5cm do g√≥ry
                        } else {
                            // Attyka - takie same pozycje jak inne uchwyty, ale 10cm wy≈ºej
                            topConnectorZ = (topConnectorType === 'lacznik' ? 0 : -62.5);
                            topConnectorYOffset = 100;  // 10cm do g√≥ry (6cm + 4cm)
                        }

                        var geoConfig = ladderGeometryConfig[connLadderNum];
                        var topTypeZOffset = (topConnectorType === 'lacznik') ? geoConfig.connector.zOffset : geoConfig.connector.uchwytZOffset;
                        var leftConnectorTop = createConnector(topConnectorType, 'left', connLadderNum);
                        leftConnectorTop.position.x = (-railOffset + 15 - 15) * SCALE;
                        leftConnectorTop.position.y = (topY + topConnectorYOffset) * SCALE;
                        leftConnectorTop.position.z = (topConnectorZ + geoConfig.zOffset + topTypeZOffset) * SCALE;
                        leftConnectorTop.userData.pairIndex = pairIndex;
                        leftConnectorTop.userData.ladderNum = connLadderNum;
                        ladderContainer.add(leftConnectorTop);

                        var rightConnectorTop = createConnector(topConnectorType, 'right', connLadderNum);
                        rightConnectorTop.position.x = (railOffset - 15 + 15) * SCALE;
                        rightConnectorTop.position.y = (topY + topConnectorYOffset) * SCALE;
                        rightConnectorTop.position.z = (topConnectorZ + geoConfig.zOffset + topTypeZOffset) * SCALE;
                        rightConnectorTop.userData.pairIndex = pairIndex;
                        rightConnectorTop.userData.ladderNum = connLadderNum;
                        ladderContainer.add(rightConnectorTop);

                        pairIndex++;
                    }

                    // 2. Ceowniki miƒôdzy sekcjami drabin
                    var currentOffset = 0;
                    for (var i = 0; i < connSections.length; i++) {
                        var section = connSections[i];
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        currentOffset += sectionHeight;

                        if (i < connSections.length - 1) {
                            // Pozycja Y - ≈ÇƒÖczniki miƒôdzy sekcjami, liczone od g√≥ry
                            var connectionY = (maxHeight / 2) - currentOffset + (DIMS.connectorHeight / 2) - 50;
                            var connType = connConnectorTypes[pairIndex] || 'uchwyt';

                            var connGeoConfig = ladderGeometryConfig[connLadderNum];
                            var connTypeZOffset = (connType === 'lacznik') ? connGeoConfig.connector.zOffset : connGeoConfig.connector.uchwytZOffset;
                            var leftConn = createConnector(connType, 'left', connLadderNum);
                            leftConn.position.x = (-railOffset + 15 - 15) * SCALE;
                            leftConn.position.y = connectionY * SCALE;
                            leftConn.position.z = ((connType === 'lacznik' ? 0 : -62.5) + connGeoConfig.zOffset + connTypeZOffset) * SCALE;
                            leftConn.userData.pairIndex = pairIndex;
                            leftConn.userData.ladderNum = connLadderNum;
                            ladderContainer.add(leftConn);

                            var rightConn = createConnector(connType, 'right', connLadderNum);
                            rightConn.position.x = (railOffset - 15 + 15) * SCALE;
                            rightConn.position.y = connectionY * SCALE;
                            rightConn.position.z = ((connType === 'lacznik' ? 0 : -62.5) + connGeoConfig.zOffset + connTypeZOffset) * SCALE;
                            rightConn.userData.pairIndex = pairIndex;
                            rightConn.userData.ladderNum = connLadderNum;
                            ladderContainer.add(rightConn);

                            pairIndex++;
                        }
                    }
                }

                // Aktualizuj listƒô ≈ÇƒÖcznik√≥w w UI
                updateConnectorList();

                // Renderuj umieszczone uchwyty ≈õciskane
                renderSciskaneHandles();

                // Odtw√≥rz podglƒÖd uchwyt√≥w ≈õciskanych je≈õli tryb aktywny
                if (sciskaneMode) {
                    createSciskanePreview();
                }

                ladderContainer.position.y = 0;
                updateStatus();
            }
            
            function updateStatus() {
                // U≈ºyj danych aktualnie edytowanej drabiny
                syncLadderAliases();
                var totalHeight = getTotalHeightForLadder(currentLadder);
                var statusText = '';

                // Poka≈º kt√≥ra drabina jest edytowana przy attyce
                if (handrailType === 'attic') {
                    statusText = '[Drabina ' + currentLadder + '] ';
                }

                if (numX7Ladders === 0 && finalLadderRungs === 0) {
                    statusText += 'Brak drabin';
                } else if (numX7Ladders === 0 && finalLadderRungs === '7alt') {
                    statusText += 'Drabinka x7 ALT (1825mm)';
                } else if (numX7Ladders === 0) {
                    statusText += 'Drabinka x' + finalLadderRungs;
                } else if (numX7Ladders === 1 && finalLadderRungs === 0) {
                    statusText += 'Drabinka x7';
                } else if (numX7Ladders > 1 && finalLadderRungs === 0) {
                    statusText += numX7Ladders + 'x drabinka x7';
                } else if (numX7Ladders === 1 && finalLadderRungs === '7alt') {
                    statusText += 'Drabinka x7 + x7 ALT';
                } else if (numX7Ladders === 1) {
                    statusText += 'Drabinka x7 + x' + finalLadderRungs;
                } else if (finalLadderRungs === '7alt') {
                    statusText += numX7Ladders + 'x drabinka x7 + x7 ALT';
                } else {
                    statusText += numX7Ladders + 'x drabinka x7 + x' + finalLadderRungs;
                }

                if (totalHeight > 0) {
                    statusText += ' (' + totalHeight + 'mm)';
                }

                statusDiv.innerHTML = statusText;
            }

            // Funkcja aktualizujƒÖca listƒô ≈ÇƒÖcznik√≥w w UI
            function updateConnectorList() {
                // Standardowa lista (tylko dla trybu BEZ attyki)
                if (handrailType !== 'attic') {
                    var listContainer = document.getElementById('connectorList');
                    if (listContainer) {
                        var currentConnectorTypes = getConnectorTypesForLadder(currentLadder);
                        var html = '';
                        for (var i = 0; i < currentConnectorTypes.length; i++) {
                            var label = (i === 0 && handrailType === 'safety') ? 'G√≥rna para' : '≈ÅƒÖczenie ' + (i + 1);
                            if (handrailType === 'safety' && i === 0) {
                                html += '<div class="connector-item"><span>' + label + ':</span> <span>Uchwyt porƒôczy</span></div>';
                            } else {
                                html += '<div class="connector-item">';
                                html += '<span>' + label + ':</span> ';
                                html += '<select onchange="changeConnectorType(' + i + ', this.value, ' + currentLadder + ')">';
                                html += '<option value="uchwyt"' + (currentConnectorTypes[i] === 'uchwyt' ? ' selected' : '') + '>Uchwyt</option>';
                                html += '<option value="lacznik"' + (currentConnectorTypes[i] === 'lacznik' ? ' selected' : '') + '>≈ÅƒÖcznik</option>';
                                html += '</select>';
                                html += '</div>';
                            }
                        }
                        listContainer.innerHTML = html;
                    }
                }

                // Listy dla trybu attyki (tylko gdy attyka w≈ÇƒÖczona)
                if (handrailType === 'attic') {
                    // Lista dla Drabiny 1 (u≈ºywa tego samego elementu co tryb standardowy)
                    var list1 = document.getElementById('connectorList');
                    if (list1) {
                        var types1 = getConnectorTypesForLadder(1);
                        var html1 = '';
                        for (var i = 0; i < types1.length; i++) {
                            var label = (i === 0) ? 'G√≥ra' : '≈ÅƒÖcz. ' + i;
                            html1 += '<div style="margin: 3px 0; display: flex; justify-content: space-between; align-items: center;">';
                            html1 += '<span style="color: #4CAF50;">' + label + ':</span> ';
                            html1 += '<select onchange="changeConnectorType(' + i + ', this.value, 1)" style="padding: 2px; background: #333; color: white; border: 1px solid #4CAF50; border-radius: 3px; font-size: 11px;">';
                            html1 += '<option value="uchwyt"' + (types1[i] === 'uchwyt' ? ' selected' : '') + '>Uchwyt</option>';
                            html1 += '<option value="lacznik"' + (types1[i] === 'lacznik' ? ' selected' : '') + '>≈ÅƒÖcznik</option>';
                            html1 += '</select>';
                            html1 += '</div>';
                        }
                        list1.innerHTML = html1;
                    }

                    // Lista dla Drabiny 2
                    var list2 = document.getElementById('connectorList2');
                    if (list2) {
                        var types2 = getConnectorTypesForLadder(2);
                        var html2 = '';
                        for (var i = 0; i < types2.length; i++) {
                            var label = (i === 0) ? 'G√≥ra' : '≈ÅƒÖcz. ' + i;
                            html2 += '<div style="margin: 3px 0; display: flex; justify-content: space-between; align-items: center;">';
                            html2 += '<span style="color: #2196F3;">' + label + ':</span> ';
                            html2 += '<select onchange="changeConnectorType(' + i + ', this.value, 2)" style="padding: 2px; background: #333; color: white; border: 1px solid #2196F3; border-radius: 3px; font-size: 11px;">';
                            html2 += '<option value="uchwyt"' + (types2[i] === 'uchwyt' ? ' selected' : '') + '>Uchwyt</option>';
                            html2 += '<option value="lacznik"' + (types2[i] === 'lacznik' ? ' selected' : '') + '>≈ÅƒÖcznik</option>';
                            html2 += '</select>';
                            html2 += '</div>';
                        }
                        list2.innerHTML = html2;
                    }
                }
            }

            // Funkcja zmieniajƒÖca typ ≈ÇƒÖcznika
            function changeConnectorType(index, type, ladderNum) {
                // Zapisz do wskazanej drabiny
                ladderNum = ladderNum || currentLadder;
                if (ladderNum === 1) {
                    connectorTypes1[index] = type;
                } else {
                    connectorTypes2[index] = type;
                }
                createLadder();
            }

            // Inicjalizacja - ≈Çadujemy modele, potem tworzymy drabinkƒô
            statusDiv.innerHTML = '≈Åadowanie modeli 3D...';
            loadAllModels(function() {
                statusDiv.innerHTML = 'Modele za≈Çadowane!';
                createLadder();
            });
            
            // Funkcje dodawania/usuwania drabin
            function add7Ladder() {
                var x7Height = getLadderHeight(7);  // 1922mm
                // Przesu≈Ñ uchwyty ≈õciskane w d√≥≈Ç o wysoko≈õƒá nowej x7
                for (var i = 0; i < sciskaneHandles.length; i++) {
                    sciskaneHandles[i].offsetFromBottom += x7Height;
                }
                numX7Ladders++;
                saveLadderAliases();  // Zapisz zmiany do aktualnej drabiny
                createLadder();
            }

            function remove7Ladder() {
                if (numX7Ladders <= 0) {
                    statusDiv.innerHTML = 'Brak drabin x7 do usuniƒôcia!';
                    statusDiv.style.color = 'red';
                    setTimeout(function() {
                        statusDiv.style.color = 'lime';
                        updateStatus();
                    }, 1000);
                    return;
                }
                var x7Height = getLadderHeight(7);  // 1922mm
                // Przesu≈Ñ uchwyty ≈õciskane w g√≥rƒô o wysoko≈õƒá usuwanej x7
                for (var i = 0; i < sciskaneHandles.length; i++) {
                    sciskaneHandles[i].offsetFromBottom -= x7Height;
                }
                numX7Ladders--;
                saveLadderAliases();  // Zapisz zmiany do aktualnej drabiny
                createLadder();
            }
            
            // Zmiana ko≈Ñcowej drabinki (panel Drabina 1)
            document.getElementById('ladderSelect').addEventListener('change', function(e) {
                var value = e.target.value;
                var newValue = value === '0' ? 0 : (value === '7alt' ? '7alt' : parseInt(value));

                // Aktualizuj odpowiedniƒÖ zmiennƒÖ zale≈ºnie od trybu
                if (handrailType === 'attic') {
                    finalLadderRungs1 = newValue;
                } else {
                    var hadKoncowa = (finalLadderRungs !== 0);
                    var oldKoncowaHeight = getKoncowaHeight();

                    finalLadderRungs = newValue;

                    var hasKoncowa = (finalLadderRungs !== 0);
                    var newKoncowaHeight = getKoncowaHeight();

                    // Korekta uchwyt√≥w ≈õciskanych
                    if (!hadKoncowa && hasKoncowa) {
                        for (var i = 0; i < sciskaneHandles.length; i++) {
                            sciskaneHandles[i].offsetFromBottom += newKoncowaHeight;
                        }
                    } else if (hadKoncowa && !hasKoncowa) {
                        for (var i = 0; i < sciskaneHandles.length; i++) {
                            sciskaneHandles[i].offsetFromBottom -= oldKoncowaHeight;
                        }
                    } else if (hadKoncowa && hasKoncowa) {
                        var heightDiff = newKoncowaHeight - oldKoncowaHeight;
                        for (var i = 0; i < sciskaneHandles.length; i++) {
                            sciskaneHandles[i].offsetFromBottom += heightDiff;
                        }
                    }
                    saveLadderAliases();
                }
                createLadder();
            });

            // Funkcja prze≈ÇƒÖczania miƒôdzy standardowymi kontrolkami a attykƒÖ
            function toggleAtticUI(isAttic) {
                var standardControls = document.getElementById('controls');
                var atticControlsTop = document.getElementById('atticControlsTop');
                var ladder1Title = document.getElementById('ladder1Title');
                var ladder2Panel = document.getElementById('ladder2Panel');

                if (isAttic) {
                    // Ukryj standardowe przyciski, poka≈º attykowe
                    standardControls.style.display = 'none';
                    atticControlsTop.style.display = 'block';
                    // Poka≈º tytu≈Ç "Drabina 1" i panel drabiny 2
                    ladder1Title.style.display = 'block';
                    ladder2Panel.style.display = 'block';
                    // Synchronizuj warto≈õci dropdown√≥w
                    document.getElementById('ladderSelect').value = finalLadderRungs1 || '0';
                    document.getElementById('ladderSelect2').value = finalLadderRungs2 || '0';
                } else {
                    // Poka≈º standardowe przyciski, ukryj attykowe
                    standardControls.style.display = 'block';
                    atticControlsTop.style.display = 'none';
                    // Ukryj tytu≈Ç i panel drabiny 2
                    ladder1Title.style.display = 'none';
                    ladder2Panel.style.display = 'none';
                }
            }

            // Zmiana typu porƒôczy
            document.getElementById('handrailSelect').addEventListener('change', function(e) {
                handrailType = e.target.value;
                toggleAtticUI(handrailType === 'attic');
                // Aktualizuj pozycjƒô przycisku oczka po zmianie UI
                setTimeout(function() { window.dispatchEvent(new Event('resize')); }, 50);
                if (handrailType !== 'attic') {
                    switchToLadder(1);
                }
                createLadder();
            });

            // Przyciski dla Drabiny 1
            document.getElementById('add7Btn1').addEventListener('click', function() {
                numX7Ladders1++;
                createLadder();
            });
            document.getElementById('remove7Btn1').addEventListener('click', function() {
                if (numX7Ladders1 > 0) {
                    numX7Ladders1--;
                    createLadder();
                }
            });

            // Przyciski dla Drabiny 2
            document.getElementById('add7Btn2').addEventListener('click', function() {
                numX7Ladders2++;
                createLadder();
            });
            document.getElementById('remove7Btn2').addEventListener('click', function() {
                if (numX7Ladders2 > 0) {
                    numX7Ladders2--;
                    createLadder();
                }
            });
            document.getElementById('ladderSelect2').addEventListener('change', function(e) {
                finalLadderRungs2 = e.target.value === '0' ? 0 : (e.target.value === '7alt' ? '7alt' : parseInt(e.target.value));
                createLadder();
            });

            // Wsp√≥lne przyciski w trybie attyki
            document.getElementById('techBtn2').addEventListener('click', function() {
                document.getElementById('techBtn').click();
            });
            document.getElementById('measureBtn2').addEventListener('click', function() {
                document.getElementById('measureBtn').click();
            });
            document.getElementById('sciskaneBtn2').addEventListener('click', function() {
                document.getElementById('sciskaneBtn').click();
            });

            // Stare przyciski prze≈ÇƒÖczania - usuniƒôte z UI

            function updateLadderSwitcherUI() {
                // Stara funkcja - ju≈º nieu≈ºywana, ale zostawiam dla kompatybilno≈õci
                var btn1 = document.getElementById('ladder1Btn');
                var btn2 = document.getElementById('ladder2Btn');
                if (btn1 && btn2) {
                    if (currentLadder === 1) {
                        btn1.style.background = '#4CAF50';
                        btn2.style.background = '#666';
                    } else {
                        btn1.style.background = '#666';
                        btn2.style.background = '#4CAF50';
                    }
                }
            }

            function updateUIFromCurrentLadder() {
                // Zaktualizuj UI ≈ºeby odzwierciedla≈Ço aktualnƒÖ drabinƒô
                document.getElementById('ladderSelect').value = finalLadderRungs || '0';
                updateConnectorList();
            }

            // Zmiana typu ≈ÇƒÖcznika
            // Przyciski +7 / -7 standardowe
            document.getElementById('add7Btn').addEventListener('click', function(e) {
                e.preventDefault();
                add7Ladder();
            });
            
            document.getElementById('add7Btn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                add7Ladder();
            });
            
            document.getElementById('remove7Btn').addEventListener('click', function(e) {
                e.preventDefault();
                remove7Ladder();
            });
            
            document.getElementById('remove7Btn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                remove7Ladder();
            });

            // Zamykanie tutoriala
            document.getElementById('closeInfo').addEventListener('click', function() {
                document.getElementById('info').style.display = 'none';
            });

            // Przycisk oczka - chowanie/pokazywanie paneli
            var panelsVisible = true;
            var toggleBtn = document.getElementById('togglePanelsBtn');
            var ladderSelector = document.getElementById('ladderSelector');

            function updateToggleBtnPosition() {
                if (panelsVisible) {
                    // Pozycjonuj nad panelami
                    var rect = ladderSelector.getBoundingClientRect();
                    var bottomFromViewport = window.innerHeight - rect.top;
                    toggleBtn.style.bottom = (bottomFromViewport + 5) + 'px';
                } else {
                    // Gdy ukryte - na dole
                    toggleBtn.style.bottom = '10px';
                }
            }

            toggleBtn.addEventListener('click', function() {
                panelsVisible = !panelsVisible;

                if (panelsVisible) {
                    ladderSelector.style.display = 'block';
                    toggleBtn.textContent = 'üëÅ‚Äçüó®';
                } else {
                    ladderSelector.style.display = 'none';
                    toggleBtn.textContent = 'üëÅ';
                }
                // Aktualizuj pozycjƒô po kr√≥tkim op√≥≈∫nieniu (≈ºeby DOM siƒô od≈õwie≈ºy≈Ç)
                setTimeout(updateToggleBtnPosition, 10);
            });

            // Aktualizuj pozycjƒô przy starcie i przy zmianie rozmiaru okna
            setTimeout(updateToggleBtnPosition, 100);
            window.addEventListener('resize', updateToggleBtnPosition);

            // Kontrolki
            var isDragging = false;
            var isPanning = false;
            var previousPosition = { x: 0, y: 0 };
            var targetRotation = { x: 0, y: 0.3 };
            var currentRotation = { x: 0, y: 0.3 };
            var cameraOffset = { x: 0, y: 0 };
            var initialPinchDistance = null;
            var lastZoom = camera.position.z;
            var lastPanCenter = { x: 0, y: 0 };
            
            function onPointerStart(x, y) {
                isDragging = true;
                previousPosition = { x: x, y: y };
            }
            
            function onPointerMove(x, y) {
                if (!isDragging) return;
                
                var deltaX = x - previousPosition.x;
                var deltaY = y - previousPosition.y;
                
                targetRotation.y += deltaX * 0.005;
                targetRotation.x += deltaY * 0.005;
                
                previousPosition = { x: x, y: y };
            }
            
            function onPointerEnd() {
                isDragging = false;
            }

            // Klikanie na ≈ÇƒÖczniki lub miarka lub uchwyty ≈õciskane
            renderer.domElement.addEventListener('click', function(e) {
                // Oblicz pozycjƒô myszy w uk≈Çadzie normalized device coordinates
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Tryb miarki
                if (measureMode) {
                    var intersects = raycaster.intersectObjects(ladderContainer.children, true);
                    if (intersects.length > 0) {
                        addMeasurePoint(intersects[0].point);
                    }
                    return;
                }

                // Tryb uchwyt√≥w ≈õciskanych
                if (sciskaneMode) {
                    // Sprawd≈∫ klikniƒôcie na podglƒÖd (dodanie pary)
                    var intersects = raycaster.intersectObjects(sciskanePreviewObjects, true);
                    if (intersects.length > 0) {
                        var obj = intersects[0].object;
                        while (obj.parent && !obj.userData.isSciskanePreview) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isSciskanePreview) {
                            addSciskaneHandle(obj.userData.previewY, obj.userData.ladderNum);
                            return;
                        }
                    }
                    // Sprawd≈∫ klikniƒôcie na ju≈º umieszczone (usuniƒôcie pary)
                    var placedIntersects = raycaster.intersectObjects(sciskanePlacedObjects, true);
                    if (placedIntersects.length > 0) {
                        var obj = placedIntersects[0].object;
                        while (obj.parent && !obj.userData.isSciskanePlaced) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isSciskanePlaced) {
                            // Usu≈Ñ uchwyt po offsetFromBottom - u≈ºyj ladderNum z klikniƒôtego uchwytu
                            var offsetToRemove = obj.userData.sciskaneOffsetFromBottom;
                            var clickedLadderNum = obj.userData.ladderNum || 1;
                            var targetHandles = (clickedLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                            for (var i = 0; i < targetHandles.length; i++) {
                                if (targetHandles[i].offsetFromBottom === offsetToRemove) {
                                    targetHandles.splice(i, 1);
                                    createLadder();
                                    break;
                                }
                            }
                            return;
                        }
                    }
                    return;
                }

                // Sprawd≈∫ przeciƒôcia z ≈ÇƒÖcznikami
                var intersects = raycaster.intersectObjects(connectorObjects, true);
                if (intersects.length > 0) {
                    // Znajd≈∫ g≈Ç√≥wny obiekt ≈ÇƒÖcznika (parent)
                    var obj = intersects[0].object;
                    while (obj.parent && !obj.userData.isConnector) {
                        obj = obj.parent;
                    }
                    if (obj.userData.isConnector) {
                        openRotationPanel(obj);
                    }
                }
            });

            // Eventy myszy
            renderer.domElement.addEventListener('mousedown', function(e) {
                if (e.shiftKey || e.button === 1) {
                    // Shift lub ≈õrodkowy przycisk myszy = przesuwanie
                    isPanning = true;
                    previousPosition = { x: e.clientX, y: e.clientY };
                    e.preventDefault();
                } else {
                    onPointerStart(e.clientX, e.clientY);
                }
            });
            
            renderer.domElement.addEventListener('mousemove', function(e) {
                if (isPanning) {
                    var deltaX = e.clientX - previousPosition.x;
                    var deltaY = e.clientY - previousPosition.y;
                    
                    cameraOffset.x -= deltaX * 0.02;
                    cameraOffset.y += deltaY * 0.02;
                    
                    previousPosition = { x: e.clientX, y: e.clientY };
                } else {
                    onPointerMove(e.clientX, e.clientY);
                }
            });
            
            renderer.domElement.addEventListener('mouseup', function() {
                isPanning = false;
                onPointerEnd();
            });
            
            renderer.domElement.addEventListener('mouseleave', function() {
                isPanning = false;
                onPointerEnd();
            });
            
            // Eventy dotyku
            var touchStartPos = { x: 0, y: 0 };
            var touchMoved = false;

            renderer.domElement.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchMoved = false;
                    onPointerStart(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                    isDragging = false;
                    
                    var centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    var centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    lastPanCenter = { x: centerX, y: centerY };
                    
                    var dx = e.touches[0].clientX - e.touches[1].clientX;
                    var dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                    lastZoom = camera.position.z;
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', function(e) {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    var dx = e.touches[0].clientX - touchStartPos.x;
                    var dy = e.touches[0].clientY - touchStartPos.y;
                    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                        touchMoved = true;
                    }
                    onPointerMove(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                    
                    var centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    var centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    
                    var panDeltaX = centerX - lastPanCenter.x;
                    var panDeltaY = centerY - lastPanCenter.y;
                    
                    cameraOffset.x -= panDeltaX * 0.02;
                    cameraOffset.y += panDeltaY * 0.02;
                    
                    lastPanCenter = { x: centerX, y: centerY };
                    
                    var dx = e.touches[0].clientX - e.touches[1].clientX;
                    var dy = e.touches[0].clientY - e.touches[1].clientY;
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (initialPinchDistance) {
                        var delta = initialPinchDistance - distance;
                        camera.position.z = lastZoom + delta * 0.05;
                        camera.position.z = Math.max(3, Math.min(100, camera.position.z));
                    }
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', function(e) {
                e.preventDefault();
                onPointerEnd();
                if (e.touches.length < 2) {
                    initialPinchDistance = null;
                }
                // Je≈õli nie przesunƒôli≈õmy palca - traktuj jako tap/klikniƒôcie
                if (!touchMoved && e.changedTouches.length > 0) {
                    var touch = e.changedTouches[0];
                    handleTap(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            // Funkcja obs≈ÇugujƒÖca tap (dotkniƒôcie bez przesuniƒôcia) - ta sama logika co click
            function handleTap(clientX, clientY) {
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // Tryb miarki
                if (measureMode) {
                    var intersects = raycaster.intersectObjects(ladderContainer.children, true);
                    if (intersects.length > 0) {
                        addMeasurePoint(intersects[0].point);
                    }
                    return;
                }

                // Tryb uchwyt√≥w ≈õciskanych
                if (sciskaneMode) {
                    // Sprawd≈∫ klikniƒôcie na podglƒÖd (dodanie pary)
                    var intersects = raycaster.intersectObjects(sciskanePreviewObjects, true);
                    if (intersects.length > 0) {
                        var obj = intersects[0].object;
                        while (obj.parent && !obj.userData.isSciskanePreview) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isSciskanePreview) {
                            addSciskaneHandle(obj.userData.previewY, obj.userData.ladderNum);
                            return;
                        }
                    }
                    // Sprawd≈∫ klikniƒôcie na ju≈º umieszczone (usuniƒôcie pary)
                    var placedIntersects = raycaster.intersectObjects(sciskanePlacedObjects, true);
                    if (placedIntersects.length > 0) {
                        var obj = placedIntersects[0].object;
                        while (obj.parent && !obj.userData.isSciskanePlaced) {
                            obj = obj.parent;
                        }
                        if (obj.userData.isSciskanePlaced) {
                            var offsetToRemove = obj.userData.sciskaneOffsetFromBottom;
                            var clickedLadderNum = obj.userData.ladderNum || 1;
                            var targetHandles = (clickedLadderNum === 1) ? sciskaneHandles1 : sciskaneHandles2;
                            for (var i = 0; i < targetHandles.length; i++) {
                                if (targetHandles[i].offsetFromBottom === offsetToRemove) {
                                    targetHandles.splice(i, 1);
                                    createLadder();
                                    break;
                                }
                            }
                            return;
                        }
                    }
                    return;
                }

                // Sprawd≈∫ przeciƒôcia z ≈ÇƒÖcznikami
                var intersects = raycaster.intersectObjects(connectorObjects, true);
                if (intersects.length > 0) {
                    var obj = intersects[0].object;
                    while (obj.parent && !obj.userData.isConnector) {
                        obj = obj.parent;
                    }
                    if (obj.userData.isConnector) {
                        openRotationPanel(obj);
                    }
                }
            }
            
            // Scroll zoomuje
            renderer.domElement.addEventListener('wheel', function(e) {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.02;
                camera.position.z = Math.max(3, Math.min(100, camera.position.z));
            }, { passive: false });

            // Blokuj domy≈õlne zachowanie ≈õrodkowego przycisku (auto-scroll)
            renderer.domElement.addEventListener('auxclick', function(e) {
                if (e.button === 1) e.preventDefault();
            });
            
            // Animacja
            function animate() {
                requestAnimationFrame(animate);
                
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;
                
                ladderContainer.rotation.x = currentRotation.x;
                ladderContainer.rotation.y = currentRotation.y;
                
                camera.position.x = cameraOffset.x;
                camera.position.y = cameraOffset.y;
                camera.lookAt(cameraOffset.x, cameraOffset.y, 0);
                
                renderer.render(scene, camera);
            }
            
            // Responsywnosc
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
            
            // ============ RYSUNEK TECHNICZNY ============
            
            var techCanvas = document.getElementById('techDrawing');
            var techCtx = techCanvas.getContext('2d');
            var closeBtn = document.getElementById('closeDrawing');
            var switchBtn = document.getElementById('switchView');
            var currentView = 'front'; // 'front' lub 'side'
            
            function drawDimension(x1, y1, x2, y2, text, orientation, offset) {
                offset = offset || 0;
                
                techCtx.strokeStyle = '#000';
                techCtx.fillStyle = '#000';
                techCtx.lineWidth = 1;
                techCtx.setLineDash([]);
                
                if (orientation === 'vertical') {
                    var x = x1 + offset;
                    
                    // Linie pomocnicze
                    techCtx.setLineDash([3, 3]);
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y1);
                    techCtx.lineTo(x, y1);
                    techCtx.stroke();
                    techCtx.beginPath();
                    techCtx.moveTo(x2, y2);
                    techCtx.lineTo(x, y2);
                    techCtx.stroke();
                    techCtx.setLineDash([]);
                    
                    // Linia wymiaru
                    techCtx.beginPath();
                    techCtx.moveTo(x, y1);
                    techCtx.lineTo(x, y2);
                    techCtx.stroke();
                    
                    // Strza≈Çki
                    var arrowSize = 8;
                    techCtx.beginPath();
                    techCtx.moveTo(x, y1);
                    techCtx.lineTo(x - arrowSize / 2, y1 + arrowSize);
                    techCtx.lineTo(x + arrowSize / 2, y1 + arrowSize);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    techCtx.beginPath();
                    techCtx.moveTo(x, y2);
                    techCtx.lineTo(x - arrowSize / 2, y2 - arrowSize);
                    techCtx.lineTo(x + arrowSize / 2, y2 - arrowSize);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    // Tekst
                    techCtx.save();
                    techCtx.translate(x + 20, (y1 + y2) / 2);
                    techCtx.rotate(-Math.PI / 2);
                    techCtx.font = 'bold 12px Arial';
                    techCtx.textAlign = 'center';
                    techCtx.fillText(text, 0, 0);
                    techCtx.restore();
                } else {
                    var y = y1 + offset;
                    
                    // Linie pomocnicze
                    techCtx.setLineDash([3, 3]);
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y1);
                    techCtx.lineTo(x1, y);
                    techCtx.stroke();
                    techCtx.beginPath();
                    techCtx.moveTo(x2, y2);
                    techCtx.lineTo(x2, y);
                    techCtx.stroke();
                    techCtx.setLineDash([]);
                    
                    // Linia wymiaru
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y);
                    techCtx.lineTo(x2, y);
                    techCtx.stroke();
                    
                    // Strza≈Çki
                    var arrowSize = 8;
                    techCtx.beginPath();
                    techCtx.moveTo(x1, y);
                    techCtx.lineTo(x1 + arrowSize, y - arrowSize / 2);
                    techCtx.lineTo(x1 + arrowSize, y + arrowSize / 2);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    techCtx.beginPath();
                    techCtx.moveTo(x2, y);
                    techCtx.lineTo(x2 - arrowSize, y - arrowSize / 2);
                    techCtx.lineTo(x2 - arrowSize, y + arrowSize / 2);
                    techCtx.closePath();
                    techCtx.fill();
                    
                    // Tekst
                    techCtx.font = 'bold 12px Arial';
                    techCtx.textAlign = 'center';
                    techCtx.fillText(text, (x1 + x2) / 2, y - 15);
                }
            }
            
            function drawTechnicalDrawing() {
                techCanvas.width = window.innerWidth;
                techCanvas.height = window.innerHeight;
                
                techCtx.fillStyle = '#ffffff';
                techCtx.fillRect(0, 0, techCanvas.width, techCanvas.height);
                
                var sections = getLadderSections();
                var totalHeight = getTotalHeight();
                
                var totalHeightWithHandrails = totalHeight;
                if (handrailType === 'safety') {
                    totalHeightWithHandrails += DIMS.handrailVertical;
                } else if (handrailType === 'attic') {
                    totalHeightWithHandrails += DIMS.atticRailHeight;
                }
                
                var availableHeight = techCanvas.height - 250;
                var availableWidth = techCanvas.width - 200;
                var scaleByHeight = availableHeight / totalHeightWithHandrails;
                var scaleByWidth = availableWidth / (DIMS.rungLength * 2.5);
                var scale = Math.min(scaleByHeight, scaleByWidth, 0.5);
                
                // Ramka tytu≈Çowa
                techCtx.strokeStyle = '#000';
                techCtx.lineWidth = 2;
                techCtx.strokeRect(10, 10, techCanvas.width - 20, techCanvas.height - 20);
                
                techCtx.font = 'bold 16px Arial';
                techCtx.fillStyle = '#000';
                techCtx.textAlign = 'center';
                techCtx.fillText('RYSUNEK TECHNICZNY', techCanvas.width / 2, 30);
                
                var titleText = '';
                if (numX7Ladders === 0 && finalLadderRungs === 0) {
                    titleText = 'BRAK DRABIN';
                } else if (numX7Ladders === 0 && finalLadderRungs === '7alt') {
                    titleText = 'DRABINKA x7 ALT';
                } else if (numX7Ladders === 0) {
                    titleText = 'DRABINKA x' + finalLadderRungs;
                } else if (numX7Ladders === 1 && finalLadderRungs === 0) {
                    titleText = 'DRABINKA x7';
                } else if (numX7Ladders > 1 && finalLadderRungs === 0) {
                    titleText = numX7Ladders + 'x DRABINKA x7';
                } else if (numX7Ladders === 1 && finalLadderRungs === '7alt') {
                    titleText = 'DRABINKA x7 + x7 ALT';
                } else if (numX7Ladders === 1) {
                    titleText = 'DRABINKA x7 + x' + finalLadderRungs;
                } else if (finalLadderRungs === '7alt') {
                    titleText = numX7Ladders + 'x DRABINKA x7 + x7 ALT';
                } else {
                    titleText = numX7Ladders + 'x DRABINKA x7 + x' + finalLadderRungs;
                }
                
                if (totalHeight > 0) {
                    if (handrailType !== "none") {
                        titleText += ' - ' + totalHeight + 'mm + porƒôcze ' + DIMS.handrailVertical + 'mm';
                    } else {
                        titleText += ' - ' + totalHeight + 'mm';
                    }
                }
                
                techCtx.font = 'bold 14px Arial';
                techCtx.fillText(titleText, techCanvas.width / 2, 50);
                
                // Pozycje widoku - wy≈õrodkowany
                var viewY = 40;
                var viewPos = {
                    x: techCanvas.width / 2,
                    y: techCanvas.height / 2
                };
                
                if (currentView === 'front') {
                    // ====== WIDOK Z PRZODU ======
                techCtx.save();
                techCtx.translate(viewPos.x, viewPos.y);
                
                techCtx.font = 'bold 14px Arial';
                techCtx.fillStyle = '#000';
                techCtx.textAlign = 'center';
                var titleOffset = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 - 30 : -totalHeight * scale / 2 - 30;
                techCtx.fillText('WIDOK Z PRZODU', 0, titleOffset);
                
                var halfHeight = totalHeight * scale / 2;
                var halfRungLength = DIMS.rungLength * scale / 2;
                var railW = DIMS.railDepth * scale;
                var railOffset = 265 * scale;
                
                var ladderYOffset = 0;
                if (handrailType === 'safety') {
                    ladderYOffset = DIMS.handrailVertical * scale;
                } else if (handrailType === 'attic') {
                    ladderYOffset = DIMS.atticRailHeight * scale;
                }
                
                // Rysuj porƒôcze asekuracyjne lub przej≈õcie przez attykƒô
                if (handrailType === 'safety') {
                    // PORƒòCZE ASEKURACYJNE - widok z przodu
                    var handrailVertH = DIMS.handrailVertical * scale;
                    var handrailHorH = DIMS.handrailHorizontal * scale;
                    var handrailW = DIMS.handrailWidth * scale;
                    
                    techCtx.fillStyle = '#d0d0d0';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    
                    // Lewa i prawa porƒôcz - pionowe przed≈Çu≈ºenia
                    techCtx.fillRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);
                    techCtx.strokeRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);
                    
                    techCtx.fillRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);
                    techCtx.strokeRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, handrailVertH);
                } else if (handrailType === 'attic') {
                    // PRZEJ≈öCIE PRZEZ ATTYKƒò - widok z przodu
                    var atticRailH = DIMS.atticRailHeight * scale;
                    
                    techCtx.fillStyle = '#c0c0c0';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    
                    // Lewa i prawa pod≈Çu≈ºnica attyki
                    techCtx.fillRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    techCtx.strokeRect(-railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    
                    techCtx.fillRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    techCtx.strokeRect(railOffset - railW/2, -totalHeightWithHandrails * scale / 2, railW, atticRailH);
                    
                    // 2 szczeble attyki - liczone od DO≈ÅU pod≈Çu≈ºnic
                    var rungH = DIMS.rungHeight * scale;
                    var halfRungLength = DIMS.rungLength * scale / 2;
                    techCtx.fillStyle = '#a0a0a0';
                    
                    // Pierwszy szczebel: 135mm od do≈Çu pod≈Çu≈ºnic attyki
                    var rung1Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 135 * scale;
                    techCtx.fillRect(-halfRungLength, rung1Y - rungH/2, DIMS.rungLength * scale, rungH);
                    techCtx.strokeRect(-halfRungLength, rung1Y - rungH/2, DIMS.rungLength * scale, rungH);
                    
                    // Drugi szczebel: 410mm od do≈Çu pod≈Çu≈ºnic attyki
                    var rung2Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 410 * scale;
                    techCtx.fillRect(-halfRungLength, rung2Y - rungH/2, DIMS.rungLength * scale, rungH);
                    techCtx.strokeRect(-halfRungLength, rung2Y - rungH/2, DIMS.rungLength * scale, rungH);
                }
                
                techCtx.strokeStyle = '#000';
                techCtx.lineWidth = 2;
                techCtx.fillStyle = '#e0e0e0';
                
                var ladderStartY = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 + ladderYOffset : -halfHeight;
                
                techCtx.fillRect(-railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                techCtx.strokeRect(-railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                
                techCtx.fillRect(railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                techCtx.strokeRect(railOffset - railW/2, ladderStartY, railW, totalHeight * scale);
                
                // Szczeble
                var rungH = DIMS.rungHeight * scale;
                var currentHeightOffset = 0;
                var firstRungY = ladderStartY + DIMS.firstRungFromTop * scale;
                
                for (var s = 0; s < sections.length; s++) {
                    var section = sections[s];
                    var numRungs = section.rungs;
                    var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(numRungs);
                    
                    if (section.type === 'standard') {
                        techCtx.fillStyle = '#a0a0a0';
                    } else if (section.type === 'alt') {
                        techCtx.fillStyle = '#d8a060';
                    } else {
                        techCtx.fillStyle = '#b8b8b8';
                    }
                    
                    for (var i = 0; i < numRungs; i++) {
                        var yPos = ladderStartY + currentHeightOffset * scale + DIMS.firstRungFromTop * scale + (i * DIMS.rungSpacing * scale);
                        
                        techCtx.fillRect(-halfRungLength, yPos - rungH/2, DIMS.rungLength * scale, rungH);
                        techCtx.strokeRect(-halfRungLength, yPos - rungH/2, DIMS.rungLength * scale, rungH);
                    }
                    
                    // Wymiary sekcji
                    var labelText = section.type === 'alt' ? 
                        'x7 ALT (' + sectionHeight + 'mm)' : 
                        'x' + numRungs + ' (' + sectionHeight + 'mm)';
                    
                    if (s === 0) {
                        var sectionEndY = ladderStartY + (currentHeightOffset + sectionHeight) * scale;
                        var firstSectionHeight = sectionHeight - DIMS.firstRungFromTop;
                        
                        drawDimension(
                            halfRungLength + 100,
                            firstRungY,
                            halfRungLength + 100,
                            sectionEndY,
                            labelText,
                            'vertical',
                            0
                        );
                    } else if (s < sections.length - 1) {
                        var sectionEndY = ladderStartY + (currentHeightOffset + sectionHeight) * scale;
                        
                        drawDimension(
                            halfRungLength + 100,
                            ladderStartY + currentHeightOffset * scale,
                            halfRungLength + 100,
                            sectionEndY,
                            labelText,
                            'vertical',
                            0
                        );
                    } else {
                        var sectionStartY = ladderStartY + currentHeightOffset * scale;
                        var sectionEndY = ladderStartY + (currentHeightOffset + sectionHeight) * scale;
                        
                        drawDimension(
                            halfRungLength + 100,
                            sectionStartY,
                            halfRungLength + 100,
                            sectionEndY,
                            labelText,
                            'vertical',
                            0
                        );
                    }
                    
                    currentHeightOffset += sectionHeight;
                }
                
                if (handrailType !== "none") {
                    var handrailWithTopHeight = DIMS.handrailVertical + DIMS.firstRungFromTop;
                    
                    drawDimension(
                        halfRungLength + 100,
                        -totalHeightWithHandrails * scale / 2,
                        halfRungLength + 100,
                        firstRungY,
                        handrailWithTopHeight + 'mm (porƒôcz)',
                        'vertical',
                        0
                    );
                }
                
                techCtx.setLineDash([]);
                techCtx.fillStyle = '#000';
                
                drawDimension(
                    -halfRungLength - 80,
                    ladderStartY,
                    -halfRungLength - 80,
                    ladderStartY + totalHeight * scale,
                    totalHeight + 'mm (ca≈Çkowita)',
                    'vertical',
                    0
                );
                
                drawDimension(
                    -halfRungLength,
                    ladderStartY + totalHeight * scale,
                    halfRungLength,
                    ladderStartY + totalHeight * scale,
                    DIMS.rungLength + 'mm',
                    'horizontal',
                    35
                );
                
                // Rysuj ceowniki na wszystkich po≈ÇƒÖczeniach (obr√≥cone - widaƒá ramiona 30mm)
                techCtx.fillStyle = '#606060';
                techCtx.strokeStyle = '#000';
                techCtx.lineWidth = 2;
                
                var connectorH = DIMS.connectorHeight * scale;
                var connectorArmD = DIMS.connectorArmDepth * scale;  // 30mm ramiona (teraz widoczne z przodu)
                var connectorOffset = 15 * scale;  // 15mm przesuniƒôcie do ≈õrodka
                var connectorDownShift = 50 * scale;  // 50mm przesuniƒôcie w d√≥≈Ç
                
                // 1. Ceownik na g√≥rze (je≈õli sƒÖ porƒôcze)
                if (handrailType !== "none" && sections.length > 0) {
                    var topY = ladderStartY - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                    
                    // Lewy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                    techCtx.fillRect(-railOffset + connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                    techCtx.strokeRect(-railOffset + connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                    
                    // Prawy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                    techCtx.fillRect(railOffset - connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                    techCtx.strokeRect(railOffset - connectorOffset - connectorArmD/2, topY - connectorH/2, connectorArmD, connectorH);
                }
                
                // 2. Ceowniki miƒôdzy sekcjami
                var currentOffset = 0;
                for (var s = 0; s < sections.length; s++) {
                    var section = sections[s];
                    var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                    currentOffset += sectionHeight;
                    
                    if (s < sections.length - 1) {
                        var connY = ladderStartY + currentOffset * scale - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                        
                        // Lewy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                        techCtx.fillRect(-railOffset + connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                        techCtx.strokeRect(-railOffset + connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                        
                        // Prawy ceownik - prostokƒÖt 30mm, przesuniƒôty o 15mm do ≈õrodka i 50mm w d√≥≈Ç
                        techCtx.fillRect(railOffset - connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                        techCtx.strokeRect(railOffset - connectorOffset - connectorArmD/2, connY - connectorH/2, connectorArmD, connectorH);
                    }
                }
                
                techCtx.restore();
                
                } else {
                // ====== WIDOK Z BOKU ======
                    techCtx.save();
                    techCtx.translate(viewPos.x, viewPos.y);
                    
                    techCtx.font = 'bold 14px Arial';
                    techCtx.fillStyle = '#000';
                    techCtx.textAlign = 'center';
                    var sideTitleOffset = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 - 30 : -totalHeight * scale / 2 - 30;
                    techCtx.fillText('WIDOK Z BOKU', 0, sideTitleOffset);
                    
                    var halfHeight = totalHeight * scale / 2;
                    var rungH = DIMS.rungHeight * scale;
                    var railD = DIMS.railDepth * scale;
                    var rungW = DIMS.rungWidth * scale;
                    
                    // Rysuj porƒôcze asekuracyjne lub przej≈õcie przez attykƒô
                    if (handrailType === 'safety') {
                        // PORƒòCZE ASEKURACYJNE - widok z boku
                        var handrailVertH = DIMS.handrailVertical * scale;
                        var handrailHorH = DIMS.handrailHorizontal * scale;
                        var handrailW = DIMS.handrailWidth * scale;
                        
                        techCtx.fillStyle = '#d0d0d0';
                        techCtx.strokeStyle = '#000';
                        techCtx.lineWidth = 2;
                        
                        // Pionowe przed≈Çu≈ºenie
                        techCtx.fillRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, handrailVertH);
                        techCtx.strokeRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, handrailVertH);
                        
                        // Ramiƒô poziome
                        techCtx.fillRect(-railD/2, -totalHeightWithHandrails * scale / 2 - handrailW/2, handrailHorH, handrailW);
                        techCtx.strokeRect(-railD/2, -totalHeightWithHandrails * scale / 2 - handrailW/2, handrailHorH, handrailW);
                        
                        drawDimension(
                            -railD/2,
                            -totalHeightWithHandrails * scale / 2 - handrailW/2 - 20,
                            -railD/2 + handrailHorH,
                            -totalHeightWithHandrails * scale / 2 - handrailW/2 - 20,
                            DIMS.handrailHorizontal + 'mm',
                            'horizontal',
                            0
                        );
                    } else if (handrailType === 'attic') {
                        // PRZEJ≈öCIE PRZEZ ATTYKƒò - widok z boku
                        var atticRailH = DIMS.atticRailHeight * scale;
                        
                        techCtx.fillStyle = '#c0c0c0';
                        techCtx.strokeStyle = '#000';
                        techCtx.lineWidth = 2;
                        
                        // Pod≈Çu≈ºnica attyki
                        techCtx.fillRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, atticRailH);
                        techCtx.strokeRect(-railD/2, -totalHeightWithHandrails * scale / 2, railD, atticRailH);
                        
                        // 2 szczeble attyki - liczone od DO≈ÅU pod≈Çu≈ºnic
                        techCtx.fillStyle = '#a0a0a0';
                        
                        // Pierwszy szczebel: 135mm od do≈Çu pod≈Çu≈ºnic attyki
                        var rung1Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 135 * scale;
                        techCtx.fillRect(-rungW/2, rung1Y - rungH/2, rungW, rungH);
                        techCtx.strokeRect(-rungW/2, rung1Y - rungH/2, rungW, rungH);
                        
                        // Drugi szczebel: 410mm od do≈Çu pod≈Çu≈ºnic attyki
                        var rung2Y = (-totalHeightWithHandrails * scale / 2) + atticRailH - 410 * scale;
                        techCtx.fillRect(-rungW/2, rung2Y - rungH/2, rungW, rungH);
                        techCtx.strokeRect(-rungW/2, rung2Y - rungH/2, rungW, rungH);
                    }
                    
                    var ladderYOffset = 0;
                    if (handrailType === 'safety') {
                        ladderYOffset = DIMS.handrailVertical * scale;
                    } else if (handrailType === 'attic') {
                        ladderYOffset = DIMS.atticRailHeight * scale;
                    }
                    var ladderStartY = handrailType !== "none" ? -totalHeightWithHandrails * scale / 2 + ladderYOffset : -halfHeight;
                    
                    techCtx.fillStyle = '#e0e0e0';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    techCtx.fillRect(-railD/2, ladderStartY, railD, totalHeight * scale);
                    techCtx.strokeRect(-railD/2, ladderStartY, railD, totalHeight * scale);
                    
                    var currentHeightOffset = 0;
                    for (var s = 0; s < sections.length; s++) {
                        var section = sections[s];
                        var numRungs = section.rungs;
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(numRungs);
                        
                        if (section.type === 'standard') {
                            techCtx.fillStyle = '#a0a0a0';
                        } else if (section.type === 'alt') {
                            techCtx.fillStyle = '#d8a060';
                        } else {
                            techCtx.fillStyle = '#b8b8b8';
                        }
                        
                        for (var i = 0; i < numRungs; i++) {
                            var yPos = ladderStartY + currentHeightOffset * scale + DIMS.firstRungFromTop * scale + (i * DIMS.rungSpacing * scale);
                            
                            techCtx.fillRect(-rungW/2, yPos - rungH/2, rungW, rungH);
                            techCtx.strokeRect(-rungW/2, yPos - rungH/2, rungW, rungH);
                        }
                        
                        currentHeightOffset += sectionHeight;
                    }
                    
                    // Rysuj ceowniki na wszystkich po≈ÇƒÖczeniach - widok z boku pokazuje kszta≈Çt [
                    techCtx.fillStyle = '#606060';
                    techCtx.strokeStyle = '#000';
                    techCtx.lineWidth = 2;
                    
                    var connectorH = DIMS.connectorHeight * scale;
                    var connectorBackW = DIMS.connectorBackWidth * scale;  // 56mm tylna ≈õcianka (50mm + 6mm)
                    var connectorArmD = (DIMS.connectorArmDepth + 3) * scale;    // 33mm ramiona (30mm + 3mm przesuniƒôcie tylnej ≈õcianki)
                    var connectorT = DIMS.connectorThickness * scale;  // 3mm grubo≈õƒá
                    var connectorDownShift = 50 * scale;  // 50mm przesuniƒôcie w d√≥≈Ç
                    
                    // 1. Ceownik na g√≥rze (je≈õli sƒÖ porƒôcze)
                    if (handrailType !== "none" && sections.length > 0) {
                        var topY = ladderStartY - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                        
                        // Tylna ≈õcianka (pionowa) - od strony zewnƒôtrznej
                        techCtx.fillRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorT, connectorH);
                        techCtx.strokeRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorT, connectorH);
                        
                        // G√≥rne ramiƒô (poziome) - skierowane do ≈õrodka
                        techCtx.fillRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorArmD, connectorT);
                        techCtx.strokeRect(-connectorArmD + connectorT/2, topY - connectorH/2, connectorArmD, connectorT);
                        
                        // Dolne ramiƒô (poziome) - skierowane do ≈õrodka
                        techCtx.fillRect(-connectorArmD + connectorT/2, topY + connectorH/2 - connectorT, connectorArmD, connectorT);
                        techCtx.strokeRect(-connectorArmD + connectorT/2, topY + connectorH/2 - connectorT, connectorArmD, connectorT);
                    }
                    
                    // 2. Ceowniki miƒôdzy sekcjami
                    var currentOffset = 0;
                    for (var s = 0; s < sections.length; s++) {
                        var section = sections[s];
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        currentOffset += sectionHeight;
                        
                        if (s < sections.length - 1) {
                            var connY = ladderStartY + currentOffset * scale - (DIMS.connectorHeight / 2 * scale) - connectorDownShift;
                            
                            // Ceownik - kszta≈Çt [ skierowany do ≈õrodka
                            techCtx.fillRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorT, connectorH);
                            techCtx.strokeRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorT, connectorH);
                            
                            techCtx.fillRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorArmD, connectorT);
                            techCtx.strokeRect(-connectorArmD + connectorT/2, connY - connectorH/2, connectorArmD, connectorT);
                            
                            techCtx.fillRect(-connectorArmD + connectorT/2, connY + connectorH/2 - connectorT, connectorArmD, connectorT);
                            techCtx.strokeRect(-connectorArmD + connectorT/2, connY + connectorH/2 - connectorT, connectorArmD, connectorT);
                        }
                    }
                    
                    techCtx.font = 'bold 11px Arial';
                    techCtx.fillStyle = '#000';
                    techCtx.textAlign = 'left';
                    var textX = railD/2 + 20;
                    var textYStart = ladderStartY + 20;
                    techCtx.fillText('Pod≈Çu≈ºnica:', textX, textYStart);
                    techCtx.fillText('30√ó50mm', textX, textYStart + 15);
                    techCtx.fillText('Szczebel:', textX, textYStart + 35);
                    techCtx.fillText('30√ó30mm', textX, textYStart + 50);
                    
                    techCtx.restore();
                }
                
                // Specyfikacja na dole (zawsze widoczna)
                techCtx.font = '11px Arial';
                techCtx.fillStyle = '#000';
                techCtx.textAlign = 'center';
                var specY = techCanvas.height - 60;
                
                techCtx.font = 'bold 12px Arial';
                techCtx.fillText('SPECYFIKACJA', techCanvas.width / 2, specY);
                techCtx.font = '10px Arial';
                
                var specText = '';
                if (sections.length === 0) {
                    specText = 'Brak drabin';
                } else {
                    for (var s = 0; s < sections.length; s++) {
                        var section = sections[s];
                        if (s > 0) specText += ' + ';
                        var sectionHeight = section.type === 'alt' ? getLadderHeight('7alt') : getLadderHeight(section.rungs);
                        var label = section.type === 'alt' ? 'x7 ALT' : 'x' + section.rungs;
                        specText += label + ' (' + sectionHeight + 'mm)';
                    }
                    specText += ' = ' + totalHeight + 'mm';
                }
                
                techCtx.fillText(specText, techCanvas.width / 2, specY + 15);
                techCtx.fillText('Rozstaw szczebli: ' + DIMS.rungSpacing + 'mm | Pierwszy szczebel: ' + DIMS.firstRungFromTop + 'mm | D≈Çugo≈õƒá: ' + DIMS.rungLength + 'mm', 
                    techCanvas.width / 2, specY + 30);
                
                if (handrailType === 'safety') {
                    techCtx.fillText('Porƒôcze asekuracyjne: ' + DIMS.handrailVertical + 'mm (pion) + ' + DIMS.handrailHorizontal + 'mm (poziom)', 
                        techCanvas.width / 2, specY + 45);
                } else if (handrailType === 'attic') {
                    techCtx.fillText('Przej≈õcie przez attykƒô: ' + DIMS.atticRailHeight + 'mm (pod≈Çu≈ºnice) + ' + DIMS.atticRungs + ' szczeble', 
                        techCanvas.width / 2, specY + 45);
                }
                
                techCanvas.classList.add('active');
                closeBtn.classList.add('active');
                switchBtn.classList.add('active');
            }
            
            document.getElementById('techBtn').addEventListener('click', function(e) {
                e.preventDefault();
                drawTechnicalDrawing();
            });
            
            document.getElementById('techBtn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                drawTechnicalDrawing();
            });

            // Przycisk miarki
            document.getElementById('measureBtn').addEventListener('click', function(e) {
                e.preventDefault();
                toggleMeasureMode();
            });

            document.getElementById('measureBtn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleMeasureMode();
            });

            // Przycisk uchwyt√≥w ≈õciskanych
            document.getElementById('sciskaneBtn').addEventListener('click', function(e) {
                e.preventDefault();
                toggleSciskaneMode();
            });

            document.getElementById('sciskaneBtn').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                toggleSciskaneMode();
            });

            function closeTechnicalDrawing() {
                techCanvas.classList.remove('active');
                closeBtn.classList.remove('active');
                switchBtn.classList.remove('active');
                currentView = 'front'; // Reset do widoku z przodu
            }
            
            closeBtn.addEventListener('click', closeTechnicalDrawing);
            closeBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                closeTechnicalDrawing();
            });
            
            // Prze≈ÇƒÖczanie widok√≥w
            function switchView() {
                if (currentView === 'front') {
                    currentView = 'side';
                    switchBtn.innerHTML = 'Widok z przodu';
                } else {
                    currentView = 'front';
                    switchBtn.innerHTML = 'Widok z boku';
                }
                drawTechnicalDrawing();
            }
            
            switchBtn.addEventListener('click', function(e) {
                e.preventDefault();
                switchView();
            });
            
            switchBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                switchView();
            });
            
        } catch (error) {
            statusDiv.innerHTML = 'BLAD: ' + error.message;
            statusDiv.style.color = 'red';
            console.error('Blad 3D:', error);
        }
    </script>
</body>
</html>
